difficulty,generated_instruction,accurate_implementation,slightly_different_implementation,buggy_implementation
easy,"""Design a Verilog module for a 2-input AND gate with inputs a and b, and output y.""","module and_gate (
    input a,
    input b,
    output y
);
    assign y = a & b;
endmodule","module AND2 (
    input wire in1,
    input wire in2,
    output reg out
);
    always @* begin
        out = in1 && in2;
    end
endmodule","module and_gate (
    input a,
    input b,
    output y
);
    assign y = a | b;
endmodule"
easy,"""Write a Verilog module for a 2-input OR gate with inputs 'a' and 'b' and output 'y'.""","module or_gate(input a, b, output y);
    assign y = a | b;
endmodule","module or_gate(
    input wire a,
    input wire b,
    output reg y
);
    always @(*) begin
        y = a | b;
    end
endmodule","module or_gate(input a, b, output y);
    assign y = a & b;
endmodule"
easy,"""Design a Verilog module for a 2-input XOR gate with inputs `a` and `b` and output `y`.""","module xor_gate (
    input a, b,
    output y
);
    assign y = a ^ b;
endmodule","module xor_gate (
    input a, b,
    output y
);
    assign y = (a & ~b) | (~a & b);
endmodule","module xor_gate (
    input a, b,
    output y
);
    assign y = a | b;
endmodule"
easy,"""Write a Verilog module for a 2-to-1 multiplexer with inputs a, b, and sel, and output y that selects b when sel is high, otherwise a.""","module mux2to1 (
    input a, b,
    input sel,
    output y
);
    assign y = sel ? b : a;
endmodule","module mux2to1 (
    input a, b,
    input sel,
    output reg y
);
    always @(*) begin
        case (sel)
            1'b0: y = a;
            1'b1: y = b;
        endcase
    end
endmodule","module mux2to1 (
    input a, b,
    input sel,
    output y
);
    assign y = sel ? a : b;
endmodule"
easy,"""Write a Verilog module for a 1-bit full adder with inputs a, b, cin and outputs sum, cout. Use continuous assignments for the logic.""","module full_adder(
    input a, b, cin,
    output sum, cout
);
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
endmodule","module full_adder(
    input a, b, cin,
    output reg sum, cout
);
    always @(*) begin
        sum = a + b + cin;
        cout = (a & b) | ((a ^ b) & cin);
    end
endmodule","module full_adder(
    input a, b, cin,
    output sum, cout
);
    assign sum = a ^ b;
    assign cout = (a & b) | (b & cin) | (cin & a);
endmodule"
easy,"""Write a Verilog module for a 1-bit half adder with inputs a and b, and outputs sum (XOR of inputs) and cout (AND of inputs).""","module half_adder(
    input a, b,
    output sum, cout
);
    assign sum = a ^ b;
    assign cout = a & b;
endmodule","module half_adder(
    input wire a, b,
    output wire sum, cout
);
    xor(sum, a, b);
    and(cout, a, b);
endmodule","module half_adder(
    input a, b,
    output sum, cout
);
    assign sum = a | b;
    assign cout = a & b;
endmodule"
easy,"""Write a Verilog module for a D flip-flop with an asynchronous reset. The flip-flop should reset to 0 when the reset signal is high and store the input on the rising clock edge otherwise.""","module dff_async_reset (
    input clk,
    input rst,
    input d,
    output reg q
);
    always @(posedge clk or posedge rst) begin
        if (rst)
            q <= 1'b0;
        else
            q <= d;
    end
endmodule","module dff_async_reset (
    input wire clk, rst, d,
    output reg q
);
    always @(posedge clk, posedge rst) begin
        q <= rst ? 1'b0 : d;
    end
endmodule","module dff_async_reset (
    input clk,
    input rst,
    input d,
    output reg q
);
    always @(posedge clk) begin
        if (rst)
            q <= 1'b0;
        else
            q <= d;
    end
endmodule"
easy,"""Write a Verilog module for a T flip-flop with active-high reset and clock enable. The output toggles when the input 't' is high.""","module t_ff (
    input clk, rst,
    input t,
    output reg q
);
    always @(posedge clk or posedge rst) begin
        if (rst) q <= 1'b0;
        else if (t) q <= ~q;
    end
endmodule","module t_ff (
    input clk, rst,
    input t,
    output reg q
);
    wire next_state = t ? ~q : q;
    always @(posedge clk or posedge rst) begin
        if (rst) q <= 1'b0;
        else q <= next_state;
    end
endmodule","module t_ff (
    input clk, rst,
    input t,
    output reg q
);
    always @(posedge clk) begin
        if (rst) q <= 1'b0;
        else if (t) q <= ~q;
    end
endmodule"
easy,"""Write a Verilog module for a 2-bit up-counter with clock and reset inputs. The counter should reset to 0 and increment on each clock edge.""
---
The generated instruction is concise, specifies the key requirements (2-bit, up-counter, clock/reset behavior), and avoids unnecessary details while ensuring accurate implementation. The two correct implementations differ in style (direct output reg vs. separate reg+assign), while the buggy version omits the reset from the sensitivity list.","module counter_2bit (
    input clk,
    input reset,
    output reg [1:0] count
);
    always @(posedge clk or posedge reset) begin
        if (reset)
            count <= 2'b00;
        else
            count <= count + 1;
    end
endmodule
---","module counter_2bit (
    input clk,
    input reset,
    output [1:0] count
);
    reg [1:0] cnt_reg;
    assign count = cnt_reg;
    always @(posedge clk, posedge reset) begin
        if (reset)
            cnt_reg <= 0;
        else
            cnt_reg <= cnt_reg + 2'b01;
    end
endmodule
---","module counter_2bit (
    input clk,
    input reset,
    output reg [1:0] count
);
    always @(posedge clk) begin
        if (reset)
            count <= 2'b00;
        else
            count <= count + 1;
    end
endmodule
---"
easy,"""Write a Verilog module for a 2-bit down counter with a clock and reset input. The counter should decrement on every clock edge and reset to 2'b11.""","module down_counter(
    input clk,
    input reset,
    output reg [1:0] count
);
always @(posedge clk or posedge reset) begin
    if (reset)
        count <= 2'b11;
    else
        count <= count - 1;
end
endmodule
---","module down_counter(
    input clk,
    input reset,
    output [1:0] count
);
reg [1:0] cnt_reg;
assign count = cnt_reg;
always @(posedge clk) begin
    if (reset)
        cnt_reg <= 2'b11;
    else if (cnt_reg == 2'b00)
        cnt_reg <= 2'b11;
    else
        cnt_reg <= cnt_reg - 1;
end
endmodule
---","module down_counter(
    input clk,
    input reset,
    output reg [1:0] count
);
always @(posedge clk) begin
    if (reset)
        count <= 2'b11;
    else
        count <= count + 1;
end
endmodule
---"
easy,"""Design a 4-to-1 multiplexer using a case statement.""","module mux_4to1 (
    input [3:0] data_in,
    input [1:0] sel,
    output reg out
);
    always @(*) begin
        case (sel)
            2'b00: out = data_in[0];
            2'b01: out = data_in[1];
            2'b10: out = data_in[2];
            2'b11: out = data_in[3];
            default: out = 1'b0;
        endcase
    end
endmodule","module mux_4to1 (
    input [3:0] data_in,
    input [1:0] sel,
    output wire out
);
    assign out = (sel == 2'b00) ? data_in[0] :
                 (sel == 2'b01) ? data_in[1] :
                 (sel == 2'b10) ? data_in[2] :
                                  data_in[3];
endmodule","module mux_4to1 (
    input [3:0] data_in,
    input [1:0] sel,
    output reg out
);
    always @(*) begin
        case (sel)
            2'b00: out = data_in[1];
            2'b01: out = data_in[1];
            2'b10: out = data_in[2];
            2'b11: out = data_in[3];
        endcase
    end
endmodule"
easy,"""Write a Verilog module for a 2-to-4 decoder that takes a 2-bit input and activates one of four outputs based on the input value. Use a case statement.""","module decoder_2to4 (
    input [1:0] in,
    output reg [3:0] out
);
always @(*) begin
    case(in)
        2'b00: out = 4'b0001;
        2'b01: out = 4'b0010;
        2'b10: out = 4'b0100;
        2'b11: out = 4'b1000;
    endcase
end
endmodule","module decoder_2to4 (
    input [1:0] in,
    output [3:0] out
);
assign out = (in == 2'b00) ? 4'b0001 :
             (in == 2'b01) ? 4'b0010 :
             (in == 2'b10) ? 4'b0100 :
             4'b1000;
endmodule","module decoder_2to4 (
    input [1:0] in,
    output reg [3:0] out
);
always @(*) begin
    case(in)
        2'b00: out = 4'b0001;
        2'b01: out = 4'b0010;
        2'b10: out = 4'b0100;
    endcase
end
endmodule
---"
easy,"""Write a Verilog module for a 4-bit register with synchronous reset. The reset should clear the output to zero on the rising clock edge.""","module register_4bit (
    input clk,
    input rst,
    input [3:0] d,
    output reg [3:0] q
);
always @(posedge clk) begin
    if (rst) q <= 4'b0;
    else q <= d;
end
endmodule
###","module register_4bit (
    input wire clk,
    input wire rst,
    input wire [3:0] d,
    output reg [3:0] q
);
always @(posedge clk or posedge rst) begin
    if (rst) q <= 4'b0;
    else q <= d;
end
endmodule
###","module register_4bit (
    input clk,
    input rst,
    input [3:0] d,
    output reg [3:0] q
);
always @(posedge clk) begin
    if (!rst) q <= d;
end
endmodule
###"
easy,"""Write a Verilog module for a 4-bit register with clock and enable inputs. The register should store the input data on the rising clock edge when enabled.""","module register_4bit (
    input wire clk,
    input wire en,
    input wire [3:0] d,
    output reg [3:0] q
);
    always @(posedge clk) begin
        if (en) q <= d;
    end
endmodule","module register_4bit (
    input wire clk,
    input wire enable,
    input wire [3:0] data_in,
    output reg [3:0] data_out
);
    always @(posedge clk) begin
        data_out <= enable ? data_in : data_out;
    end
endmodule","module register_4bit (
    input wire clk,
    input wire en,
    input wire [3:0] d,
    output reg [3:0] q
);
    always @(posedge clk) begin
        if (en) q = d;
    end
endmodule"
easy,"Write a Verilog module for a 4-bit adder with inputs a, b, cin and outputs sum, cout. Use a single line to compute the sum and carry.","module adder_4bit (
    input [3:0] a, b,
    input cin,
    output [3:0] sum,
    output cout
);
    assign {cout, sum} = a + b + cin;
endmodule","module adder_4bit (
    input [3:0] a, b,
    input cin,
    output [3:0] sum,
    output cout
);
    wire [4:0] result;
    assign result = a + b + cin;
    assign sum = result[3:0];
    assign cout = result[4];
endmodule","module adder_4bit (
    input [3:0] a, b,
    input cin,
    output [3:0] sum,
    output cout
);
    assign {cout, sum} = a + b;
endmodule"
easy,"""Write a Verilog module for a 4-bit subtractor with inputs a and b, outputs diff and borrow.""","module subtractor_4bit (
    input [3:0] a,
    input [3:0] b,
    output [3:0] diff,
    output borrow
);
    assign {borrow, diff} = a - b;
endmodule","module subtractor_4bit (
    input [3:0] a,
    input [3:0] b,
    output [3:0] diff,
    output borrow
);
    wire [4:0] result;
    assign result = {1'b0, a} - {1'b0, b};
    assign diff = result[3:0];
    assign borrow = result[4];
endmodule","module subtractor_4bit (
    input [3:0] a,
    input [3:0] b,
    output [3:0] diff
);
    assign diff = a - b;
endmodule"
easy,"""Write a Verilog module for a 2-input NAND gate with inputs a and b, and output y.""","module nand_gate (
    input a, b,
    output y
);
    assign y = ~(a & b);
endmodule","module nand_gate (
    input wire a, b,
    output reg y
);
    always @(*) begin
        y = ~(a & b);
    end
endmodule","module nand_gate (
    input a, b,
    output y
);
    assign y = ~a & b;
endmodule"
easy,"""Implement a 2-input NOR gate in Verilog.""","module nor_gate (
    input a,
    input b,
    output y
);
    assign y = ~(a | b);
endmodule","module nor_gate (
    input wire a, b,
    output wire y
);
    wire or_out;
    assign or_out = a | b;
    assign y = ~or_out;
endmodule","module nor_gate (
    input a,
    input b,
    output y
);
    assign y = ~a | ~b;
endmodule"
easy,"""Write a Verilog module for a 2-input XNOR gate.""","module xnor_gate(
    input a, b,
    output y
);
    assign y = ~(a ^ b);
endmodule","module xnor_gate(
    input a, b,
    output y
);
    assign y = (a & b) | (~a & ~b);
endmodule","module xnor_gate(
    input a, b,
    output y
);
    assign y = a ^ b;
endmodule"
easy,"""Design a 4-bit comparator in Verilog that outputs 1 when input A is greater than input B.""","module comparator_4bit (
    input [3:0] A,
    input [3:0] B,
    output reg A_gt_B
);
    always @(*) begin
        A_gt_B = (A > B);
    end
endmodule","module comparator_4bit (
    input [3:0] A,
    input [3:0] B,
    output A_gt_B
);
    assign A_gt_B = (A[3] > B[3]) |
                   ((A[3] == B[3]) && (A[2] > B[2])) |
                   ((A[3:2] == B[3:2]) && (A[1] > B[1])) |
                   ((A[3:1] == B[3:1]) && (A[0] > B[0]));
endmodule","module comparator_4bit (
    input [3:0] A,
    input [3:0] B,
    output reg A_gt_B
);
    always @(*) begin
        A_gt_B = (A >= B);
    end
endmodule"
easy,"""Write a Verilog module for a 2-to-1 demultiplexer with inputs 'data' and 'sel', and outputs 'out0' and 'out1'. When sel=0, route data to out0. When sel=1, route data to out1.""","module demux_2to1 (
    input data,
    input sel,
    output reg out0,
    output reg out1
);
    always @(*) begin
        out0 = (sel == 0) ? data : 0;
        out1 = (sel == 1) ? data : 0;
    end
endmodule","module demux_2to1 (
    input data,
    input sel,
    output out0,
    output out1
);
    assign out0 = ~sel & data;
    assign out1 = sel & data;
endmodule","module demux_2to1 (
    input data,
    input sel,
    output reg out0,
    output reg out1
);
    always @(*) begin
        out0 = (sel == 0) ? data : 1;
        out1 = (sel == 1) ? data : 0;
    end
endmodule"
easy,"""Write a Verilog module for a 4-to-2 encoder using a case statement. The output should be 00 for input 0001, 01 for 0010, 10 for 0100, and 11 for 1000, with a default output of 00.""","module encoder_4to2 (
    input [3:0] in,
    output reg [1:0] out
);
always @(*) begin
    case (in)
        4'b0001: out = 2'b00;
        4'b0010: out = 2'b01;
        4'b0100: out = 2'b10;
        4'b1000: out = 2'b11;
        default: out = 2'b00;
    endcase
end
endmodule","module encoder_4to2 (
    input [3:0] in,
    output [1:0] out
);
assign out = (in[0]) ? 2'b00 :
             (in[1]) ? 2'b01 :
             (in[2]) ? 2'b10 :
             (in[3]) ? 2'b11 : 2'b00;
endmodule","module encoder_4to2 (
    input [3:0] in,
    output reg [1:0] out
);
always @(*) begin
    case (in)
        4'b0001: out = 2'b00;
        4'b0010: out = 2'b01;
        4'b0100: out = 2'b10;
        4'b1000: out = 2'b11;
    endcase
end
endmodule"
easy,"""Design a 2-bit magnitude comparator with 'eq', 'lt', and 'gt' outputs.""","module mag_compare_2bit(
    input [1:0] a,
    input [1:0] b,
    output eq,
    output lt,
    output gt
);
    assign eq = (a == b);
    assign lt = (a < b);
    assign gt = (a > b);
endmodule","module mag_compare_2bit(
    input [1:0] a,
    input [1:0] b,
    output reg eq,
    output reg lt,
    output reg gt
);
    always @(*) begin
        eq = (a == b);
        lt = (a < b);
        gt = (a > b);
    end
endmodule","module mag_compare_2bit(
    input [1:0] a,
    input [1:0] b,
    output eq,
    output lt,
    output gt
);
    assign eq = (a[0] == b[0]) & (a[1] == b[1]);
    assign lt = (a < b);
    assign gt = (a > b);
endmodule"
easy,"""Write a Verilog module for a 2-bit up/down counter with clock, reset, and mode input (1=up, 0=down). Reset asynchronously sets count to 0.""
---
The generated instruction is minimal, clear, and sufficient for an LLM to reproduce the accurate implementation.","module up_down_counter(
    input clk, rst, mode,
    output reg [1:0] count
);
always @(posedge clk or posedge rst) begin
    if (rst)
        count <= 2'b00;
    else if (mode)
        count <= count + 1;
    else
        count <= count - 1;
end
endmodule","module up_down_counter(
    input clk, rst, up_not_down,
    output reg [1:0] out
);
always @(posedge clk) begin
    if (rst)
        out <= 0;
    else
        out <= up_not_down ? out + 1 : out - 1;
end
endmodule","module up_down_counter(
    input clk, rst, mode,
    output reg [1:0] count
);
always @(posedge clk) begin
    if (rst) count <= 2'b00;
    if (mode) count <= count + 1;
    else count <= count - 1;
end
endmodule"
easy,"""Write a Verilog module for a 2-bit shift register with clock, reset, and data input, that shifts bits from input to output on clock edges.""","module shift_reg_2bit (
    input clk,
    input reset,
    input din,
    output reg [1:0] dout
);
always @(posedge clk or posedge reset) begin
    if (reset)
        dout <= 2'b00;
    else
        dout <= {dout[0], din};
end
endmodule","module shift_reg_2bit (
    input clk,
    input rst,
    input data_in,
    output [1:0] data_out
);
reg [1:0] reg_data;
assign data_out = reg_data;
always @(posedge clk) begin
    if (rst)
        reg_data <= 2'b0;
    else
        reg_data <= {reg_data[0], data_in};
end
endmodule","module shift_reg_2bit (
    input clk,
    input reset,
    input din,
    output reg [1:0] dout
);
always @(posedge clk) begin
    if (reset)
        dout = 2'b00;
    else
        dout <= {din, dout[0]};
end
endmodule"
easy,"""Design a 2-bit ring counter that cycles through 2-bit patterns. Include clock and reset inputs. Initialize to '01' on reset.""","module ring_counter (
    input clk,
    input rst,
    output reg [1:0] out
);
    always @(posedge clk or posedge rst) begin
        if (rst) out <= 2'b01;
        else out <= {out[0], out[1]};
    end
endmodule","module ring_counter (
    input clk,
    input rst,
    output reg [1:0] out
);
    always @(posedge clk) begin
        if (rst) out <= 2'b10;
        else out <= out << 1;
    end
endmodule","module ring_counter (
    input clk,
    input rst,
    output reg [1:0] out
);
    always @(posedge clk) begin
        if (rst) out <= 2'b01;
        else out <= {out[0]};
    end
endmodule"
easy,"""Write a Verilog module for a 2-bit Johnson counter with a clock and reset. The counter should cycle through the states 00, 10, 11, 01.""","module johnson_counter (
    input clk, rst,
    output reg [1:0] out
);
    always @(posedge clk or posedge rst) begin
        if (rst)
            out <= 2'b00;
        else
            out <= {~out[0], out[1]};
    end
endmodule","module johnson_counter (
    input clk, rst,
    output reg [1:0] count = 2'b00
);
    always @(posedge clk) begin
        if (rst)
            count <= 2'b00;
        else
            count <= {count[0], ~count[1]};
    end
endmodule","module johnson_counter (
    input clk, rst,
    output reg [1:0] out
);
    always @(posedge clk) begin
        if (rst)
            out <= 2'b00;
        else
            out <= {out[0], out[1]};
    end
endmodule"
easy,"*""Design a Verilog module for a 2-bit parity generator. The output should be the XOR of the two input bits.""*","module parity_gen_2bit (
    input [1:0] data,
    output parity
);
    assign parity = data[0] ^ data[1];
endmodule","module parity_gen_2bit (
    input [1:0] data,
    output reg parity
);
    always @(*) begin
        parity = data[0] ^ data[1];
    end
endmodule","module parity_gen_2bit (
    input [1:0] data,
    output parity
);
    assign parity = ~(data[0] & data[1]);
endmodule
---"
easy,"""Write a Verilog module for a 2-bit parity checker that outputs the XOR of the two input bits.""
---
The generated instruction is concise and unambiguous, ensuring the LLM produces the correct implementation (like the first one). The other implementations are included for comparison. The buggy version incorrectly uses an AND operation instead of XOR.","module parity_checker(
    input [1:0] data,
    output parity
);
    assign parity = ^data;
endmodule","module parity_checker(
    input [1:0] data,
    output reg parity
);
    always @(*) begin
        parity = data[0] ^ data[1];
    end
endmodule","module parity_checker(
    input [1:0] data,
    output parity
);
    assign parity = data[0] & data[1];
endmodule"
easy,"""Design a Verilog module for a 2-bit incrementer that takes a 2-bit input and outputs the input plus one.""","module incrementer_2bit (
    input [1:0] a,
    output reg [1:0] b
);
    always @(*) begin
        b = a + 1'b1;
    end
endmodule","module incrementer_2bit (
    input [1:0] a,
    output [1:0] b
);
    assign b = (a == 2'b11) ? 2'b00 : a + 1;
endmodule","module incrementer_2bit (
    input [1:0] a,
    output [1:0] b
);
    always @(*) begin
        b = a + 1'b0;
    end
endmodule"
medium,"""Write a Verilog module for an 8-to-1 multiplexer with 8 data inputs, 3-bit select input, and 1 output. Use a case statement inside an always block.""","module mux_8to1 (
    input [7:0] data,
    input [2:0] sel,
    output reg out
);
    always @(*) begin
        case (sel)
            3'b000: out = data[0];
            3'b001: out = data[1];
            3'b010: out = data[2];
            3'b011: out = data[3];
            3'b100: out = data[4];
            3'b101: out = data[5];
            3'b110: out = data[6];
            3'b111: out = data[7];
        endcase
    end
endmodule","module mux_8to1 (
    input [7:0] data,
    input [2:0] sel,
    output out
);
    assign out = data[sel];
endmodule","module mux_8to1 (
    input [7:0] data,
    input [2:0] sel,
    output reg out
);
    always @(*) begin
        case (sel)
            3'b000: out = data[0];
            3'b001: out = data[1];
            3'b010: out = data[2];
            3'b011: out = data[3];
            3'b100: out = data[4];
            3'b101: out = data[5];
            3'b110: out = data[6];
        endcase
    end
endmodule"
medium,"""Write a Verilog module for a 3-to-8 decoder using a case statement to map each 3-bit input to an 8-bit output with one-hot encoding.""","module decoder_3to8 (
    input [2:0] in,
    output reg [7:0] out
);
always @(*) begin
    case (in)
        3'b000: out = 8'b00000001;
        3'b001: out = 8'b00000010;
        3'b010: out = 8'b00000100;
        3'b011: out = 8'b00001000;
        3'b100: out = 8'b00010000;
        3'b101: out = 8'b00100000;
        3'b110: out = 8'b01000000;
        3'b111: out = 8'b10000000;
        default: out = 8'b00000000;
    endcase
end
endmodule
---","module decoder_3to8 (
    input [2:0] in,
    output [7:0] out
);
assign out = (1 << in);
endmodule
---","module decoder_3to8 (
    input [2:0] in,
    output reg [7:0] out
);
always @(*) begin
    case (in)
        3'b000: out = 8'b00000001;
        3'b001: out = 8'b00000010;
        3'b010: out = 8'b00000100;
        3'b011: out = 8'b00001000;
        3'b100: out = 8'b00010000;
        3'b101: out = 8'b00100000;
        3'b110: out = 8'b01000000;
        default: out = 8'b00000000;
    endcase
end
endmodule
---"
medium,"""Design a 4-bit up/down counter in Verilog with clock, reset, and up/down control inputs.""","module up_down_counter(
  input clk, rst, up,
  output reg [3:0] count
);
always @(posedge clk or posedge rst) begin
  if (rst)
    count <= 4'b0;
  else if (up)
    count <= count + 1;
  else
    count <= count - 1;
end
endmodule","module up_down_counter(
  input clk, rst, up,
  output reg [3:0] count
);
always @(posedge clk) begin
  if (rst)
    count <= 0;
  else begin
    case(up)
      1'b1: count <= count + 1'b1;
      1'b0: count <= count - 1'b1;
    endcase
  end
end
endmodule","module up_down_counter(
  input clk, rst, up,
  output reg [3:0] count
);
always @(posedge clk) begin
  if (rst)
    count <= 4'b0;
  else if (up)
    count <= count + 1;
end
endmodule"
medium,"""Write a Verilog module for a 4-bit even parity generator that takes a 4-bit input and outputs the parity bit.""","module parity_gen (
    input [3:0] data,
    output parity
);
    assign parity = ^data;
endmodule","module parity_gen (
    input [3:0] data,
    output reg parity
);
    always @(*) begin
        parity = data[0] ^ data[1] ^ data[2] ^ data[3];
    end
endmodule","module parity_gen (
    input [3:0] data,
    output parity
);
    assign parity = data[0] ^ data[1] ^ data[2];
endmodule"
medium,"""Design a Verilog module for a 4-bit odd parity checker. The module should have a 4-bit input and output 1 if there's an odd number of 1s in the input.""","module parity_checker (
    input [3:0] data,
    output odd_parity
);
    assign odd_parity = ^data;
endmodule","module parity_checker (
    input [3:0] data,
    output reg odd_parity
);
    always @(*) begin
        odd_parity = data[0] ^ data[1] ^ data[2] ^ data[3];
    end
endmodule","module parity_checker (
    input [3:0] data,
    output odd_parity
);
    assign odd_parity = ~^data;
endmodule"
medium,"""Design a 4-bit magnitude comparator with outputs for A > B, A == B, and A < B using continuous assignments in Verilog.""","module magnitude_comparator(
    input [3:0] A, B,
    output A_gt_B, A_eq_B, A_lt_B
);
    assign A_gt_B = (A > B);
    assign A_eq_B = (A == B);
    assign A_lt_B = (A < B);
endmodule","module magnitude_comparator(
    input [3:0] A, B,
    output reg [2:0] result
);
    always @(*) begin
        if (A > B) result = 3'b100;
        else if (A == B) result = 3'b010;
        else result = 3'b001;
    end
endmodule","module magnitude_comparator(
    input [3:0] A, B,
    output A_gt_B, A_eq_B, A_lt_B
);
    assign A_gt_B = (A >= B);
    assign A_eq_B = (A == B);
    assign A_lt_B = (A <= B);
endmodule"
medium,"""Write a Verilog module that converts 4-bit binary input to Gray code using XOR operations between adjacent bits, with the MSB remaining unchanged.""","module bin_to_gray(
    input [3:0] bin,
    output [3:0] gray
);
    assign gray[3] = bin[3];
    assign gray[2] = bin[3] ^ bin[2];
    assign gray[1] = bin[2] ^ bin[1];
    assign gray[0] = bin[1] ^ bin[0];
endmodule","module bin_to_gray(
    input [3:0] bin,
    output [3:0] gray
);
    always @(*) begin
        gray[3] = bin[3];
        gray[2] = bin[3] ^ bin[2];
        gray[1] = bin[2] ^ bin[1];
        gray[0] = bin[1] ^ bin[0];
    end
endmodule","module bin_to_gray(
    input [3:0] bin,
    output [3:0] gray
);
    assign gray[3] = bin[3];
    assign gray[2] = bin[2] ^ bin[1];
    assign gray[1] = bin[1] ^ bin[0];
    assign gray[0] = bin[0];
endmodule"
medium,"Design a 4-bit Gray code to binary converter using XOR operations, where each binary bit is computed as the XOR of all higher-order Gray bits.","module gray_to_binary (
    input [3:0] gray,
    output [3:0] binary
);
    assign binary[3] = gray[3];
    assign binary[2] = gray[3] ^ gray[2];
    assign binary[1] = gray[3] ^ gray[2] ^ gray[1];
    assign binary[0] = gray[3] ^ gray[2] ^ gray[1] ^ gray[0];
endmodule
###","module gray_to_binary (
    input [3:0] gray,
    output [3:0] binary
);
    assign binary = {
        gray[3],
        gray[3] ^ gray[2],
        gray[3] ^ gray[2] ^ gray[1],
        gray[3] ^ gray[2] ^ gray[1] ^ gray[0]
    };
endmodule
###","module gray_to_binary (
    input [3:0] gray,
    output [3:0] binary
);
    assign binary[3] = gray[3];
    assign binary[2] = gray[3] & gray[2];
    assign binary[1] = gray[3] ^ gray[2] ^ gray[1];
    assign binary[0] = gray[3] ^ gray[2] ^ gray[1] ^ gray[0];
endmodule
###"
medium,"""Write a Verilog module for a 4-bit ring counter with async reset that initializes to 0001 and rotates left on each clock cycle.""","module ring_counter(
    input clk,
    input rst,
    output reg [3:0] count
);
always @(posedge clk or posedge rst) begin
    if (rst) begin
        count <= 4'b0001;
    end else begin
        count <= {count[2:0], count[3]};
    end
end
endmodule","module ring_counter(
    input clk,
    input reset,
    output reg [3:0] out
);
always @(posedge clk) begin
    if (reset)
        out <= 1;
    else
        out <= (out << 1) | (out >> 3);
end
endmodule","module ring_counter(
    input clk,
    input rst,
    output reg [3:0] count
);
always @(posedge clk) begin
    if (rst) begin
        count <= 4'b1000;
    end else begin
        count <= count << 1;
    end
end
endmodule"
medium,"""Write a Verilog module for a 4-bit Johnson counter with asynchronous reset.""","module johnson_counter (
    input clk,
    input rst,
    output reg [3:0] count
);
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            count <= 4'b0000;
        end else begin
            count <= {~count[0], count[3:1]};
        end
    end
endmodule","module johnson_counter (
    input clk,
    input rst,
    output reg [3:0] count
);
    always @(posedge clk) begin
        if (rst) begin
            count <= 4'b0000;
        end else begin
            count <= {count[2:0], ~count[3]};
        end
    end
endmodule","module johnson_counter (
    input clk,
    input rst,
    output reg [3:0] count
);
    always @(posedge clk) begin
        if (rst) begin
            count <= 4'b0000;
        end else begin
            count <= {count[2:0], count[3]};
        end
    end
endmodule"
medium,"""Design a 4-bit right shift register with clock, reset, and load control. It should load parallel data when load is high, shift right otherwise, and reset synchronously.""","module shift_register (
  input clk,
  input rst,
  input load,
  input [3:0] data_in,
  output reg [3:0] data_out
);
always @(posedge clk or posedge rst) begin
  if (rst) begin
    data_out <= 4'b0;
  end else if (load) begin
    data_out <= data_in;
  end else begin
    data_out <= {1'b0, data_out[3:1]};
  end
end
endmodule","module shift_register (
  input clk,
  input rst,
  input load,
  input [3:0] data_in,
  output reg [3:0] data_out
);
always @(posedge clk) begin
  if (rst)
    data_out <= 4'b0;
  else if (load)
    data_out <= data_in;
end
always @(posedge clk) begin
  if (~rst && ~load)
    data_out <= {1'b0, data_out[3:1]};
end
endmodule","module shift_register (
  input clk,
  input rst,
  input load,
  input [3:0] data_in,
  output reg [3:0] data_out
);
always @(posedge clk or posedge rst) begin
  if (rst) begin
    data_out <= 4'b0;
  end else begin
    data_out <= {1'b0, data_out[3:1]};
  end
end
endmodule"
medium,"Design a 4-bit left shift register with clock and reset inputs, and serial input. It should shift bits to the left by one on each clock cycle, discarding the MSB and inserting the serial input in the LSB position.","module shift_register (
    input clk,
    input reset,
    input data_in,
    output reg [3:0] data_out
);
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            data_out <= 4'b0;
        end else begin
            data_out <= {data_out[2:0], data_in};
        end
    end
endmodule","module shift_register (
    input clk,
    input reset,
    input serial_in,
    output [3:0] parallel_out
);
    reg [3:0] reg_data;
    assign parallel_out = reg_data;
    always @(posedge clk) begin
        if (reset) begin
            reg_data <= 4'b0000;
        end else begin
            reg_data <= {reg_data[2:0], serial_in};
        end
    end
endmodule","module shift_register (
    input clk,
    input reset,
    input data_in,
    output [3:0] data_out
);
    reg [3:0] data;
    assign data_out = data;
    always @(posedge clk) begin
        if (reset) begin
            data <= 2'b00;
        end else begin
            data <= {data[1:0], data_in};
        end
    end
endmodule"
medium,"Design a 4-bit universal shift register with a clock, reset, 2-bit mode control (00=hold, 01=shift right, 10=shift left, 11=parallel load), serial input, parallel input, and 4-bit output. The register should reset to 0.","module universal_shift_register (
    input clk,
    input rst,
    input [1:0] mode,
    input ser_in,
    input [3:0] par_in,
    output reg [3:0] q
);
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            q <= 4'b0;
        end else begin
            case (mode)
                2'b00: q <= q;
                2'b01: q <= {ser_in, q[3:1]};
                2'b10: q <= {q[2:0], ser_in};
                2'b11: q <= par_in;
                default: q <= q;
            endcase
        end
    end
endmodule
---
###","module universal_shift_register (
    input clk,
    input rst,
    input [1:0] mode,
    input ser_in,
    input [3:0] par_in,
    output reg [3:0] q
);
    always @(posedge clk) begin
        if (rst) begin
            q <= 4'd0;
        end else begin
            if (mode == 2'b00) q <= q;
            else if (mode == 2'b01) q <= {ser_in, q[3:1]};
            else if (mode == 2'b10) q <= {q[2:0], ser_in};
            else if (mode == 2'b11) q <= par_in;
        end
    end
endmodule
---
###","module universal_shift_register (
    input clk,
    input rst,
    input [1:0] mode,
    input ser_in,
    input [3:0] par_in,
    output reg [3:0] q
);
    always @(posedge clk) begin
        if (rst) begin
            q <= 4'b0;
        end else begin
            case (mode)
                2'b00: q <= q;
                2'b01: q <= {q[2:0], ser_in};
                2'b10: q <= {ser_in, q[3:1]};
                2'b11: q <= par_in;
            endcase
        end
    end
endmodule
---
###"
medium,"""Design a Verilog module for a 4-bit incrementer that takes a 4-bit input and outputs its value plus one.""","module inc4bit (
    input [3:0] a,
    output [3:0] b
);
    assign b = a + 1'b1;
endmodule","module inc4bit (
    input [3:0] a,
    output reg [3:0] b
);
    always @(*) begin
        b = a + 1;
    end
endmodule","module inc4bit (
    input [3:0] a,
    output [3:0] b
);
    assign b = a + 1'b0;
endmodule"
medium,"""Design a Verilog module for a 4-bit decrementer that takes a 4-bit input and outputs the input value minus 1.""","module decrementer (
    input [3:0] in,
    output [3:0] out
);
    assign out = in - 1;
endmodule","module decrementer (
    input [3:0] in,
    output reg [3:0] out
);
    always @(*) begin
        out = in - 1;
    end
endmodule","module decrementer (
    input [3:0] in,
    output [3:0] out
);
    assign out = in + 1;
endmodule"
hard,"""Design a 4-bit ALU with inputs a and b (4-bit each) and op (2-bit), that supports add (00), subtract (01), AND (10), and OR (11) operations. The output should be 4-bit.""","module alu_4bit (
    input [3:0] a, b,
    input [1:0] op,
    output reg [3:0] out
);
    always @(*) begin
        case (op)
            2'b00: out = a + b;
            2'b01: out = a - b;
            2'b10: out = a & b;
            2'b11: out = a | b;
        endcase
    end
endmodule","module alu_4bit (
    input [3:0] a, b,
    input [1:0] op,
    output [3:0] out
);
    assign out = (op == 2'b00) ? (a + b) :
                 (op == 2'b01) ? (a - b) :
                 (op == 2'b10) ? (a & b) :
                 (a | b);
endmodule","module alu_4bit (
    input [3:0] a, b,
    input [1:0] op,
    output reg [3:0] out
);
    always @(*) begin
        case (op)
            2'b00: out = a + b;
            2'b01: out = a & b;
            2'b10: out = a | b;
            2'b11: out = a - b;
        endcase
    end
endmodule"
hard,"Write a Verilog module for a 4-bit multiplier. The inputs are two 4-bit signals, and the output is their 8-bit product.","module multiplier_4bit (
    input [3:0] A,
    input [3:0] B,
    output [7:0] Product
);
    assign Product = A * B;
endmodule","module multiplier_4bit (
    input [3:0] A,
    input [3:0] B,
    output reg [7:0] Product
);
    always @(*) begin
        Product = A * B;
    end
endmodule","module multiplier_4bit (
    input [3:0] A,
    input [3:0] B,
    output [6:0] Product
);
    assign Product = A * B;
endmodule"
hard,"""Design a 4-bit barrel shifter with inputs `data_in[3:0]` and `shift_amount[1:0]`, and output `shifted_data[3:0]`. The shifter should left-shift `data_in` by `shift_amount` bits, filling with zeros. Use a case statement for implementation.""
---
This instruction is concise, includes all necessary details, and would reliably reproduce the accurate implementation when given to an LLM.","module barrel_shifter (
    input [3:0] data_in,
    input [1:0] shift_amount,
    output reg [3:0] shifted_data
);
    always @(*) begin
        case (shift_amount)
            2'b00: shifted_data = data_in;
            2'b01: shifted_data = {data_in[2:0], 1'b0};
            2'b10: shifted_data = {data_in[1:0], 2'b0};
            2'b11: shifted_data = {data_in[0], 3'b0};
        endcase
    end
endmodule","module barrel_shifter (
    input [3:0] data_in,
    input [1:0] shift_amount,
    output [3:0] shifted_data
);
    assign shifted_data = data_in << shift_amount;
endmodule","module barrel_shifter (
    input [3:0] data_in,
    input [1:0] shift_amount,
    output reg [3:0] shifted_data
);
    always @(*) begin
        case (shift_amount)
            2'b00: shifted_data = data_in;
            2'b01: shifted_data = {data_in[2:0], 1'b1};
            2'b10: shifted_data = {data_in[1:0], 2'b0};
            2'b11: shifted_data = {data_in[0], 3'b0};
        endcase
    end
endmodule"
hard,"""Design a 4-bit sequence detector in Verilog that detects '1011' using a Moore FSM. Include clock and reset inputs, a serial data input, and a detection output.""","module seq_detector(
    input clk, rst,
    input in,
    output reg out
);
    reg [2:0] state, next_state;
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    always @(posedge clk or posedge rst) begin
        if (rst) state <= S0;
        else state <= next_state;
    end
    always @(*) begin
        case (state)
            S0: next_state = in ? S1 : S0;
            S1: next_state = in ? S1 : S2;
            S2: next_state = in ? S3 : S0;
            S3: next_state = in ? (out = 1'b1, S1) : S2;
        endcase
    end
    always @(*) out = (state == S3 && in);
endmodule","module seq_detector(
    input clk, rst,
    input in,
    output reg out
);
    reg [1:0] state;
    parameter WAIT=0, GOT1=1, GOT10=2, GOT101=3;
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= WAIT;
            out <= 0;
        end
        else begin
            case (state)
                WAIT: state <= in ? GOT1 : WAIT;
                GOT1: state <= in ? GOT1 : GOT10;
                GOT10: state <= in ? GOT101 : WAIT;
                GOT101: begin
                    state <= in ? GOT1 : GOT10;
                    out <= in;
                end
            endcase
        end
    end
endmodule","module seq_detector(
    input clk, rst,
    input in,
    output reg out
);
    reg [2:0] state;
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    always @(posedge clk or posedge rst) begin
        if (rst) state <= S0;
        else begin
            case (state)
                S0: state <= in ? S1 : S0;
                S1: state <= in ? S1 : S2;
                S2: state <= in ? S3 : S0;
                S3: begin
                    state <= in ? S1 : S2;
                    out <= in;
                end
            endcase
        end
    end
endmodule"
hard,"""Design a 4-bit LFSR with taps at bits 3 and 2, initialized to 0001 on reset. Use positive-edge clock and synchronous reset.""","module lfsr4 (
    input clk,
    input reset,
    output reg [3:0] out
);
    always @(posedge clk) begin
        if (reset)
            out <= 4'b0001;
        else
            out <= {out[2:0], out[3] ^ out[2]};
    end
endmodule","module lfsr4 (
    input clk,
    input reset,
    output [3:0] out
);
    reg [3:0] state;
    assign out = state;
    always @(posedge clk) begin
        if (reset)
            state <= 4'b1111;
        else begin
            state[3] <= state[2];
            state[2] <= state[1];
            state[1] <= state[0];
            state[0] <= state[3] ^ state[2];
        end
    end
endmodule","module lfsr4 (
    input clk,
    input reset,
    output reg [3:0] out
);
    always @(posedge clk) begin
        if (reset)
            out <= 4'b1000;
        else
            out <= {out[2:0], out[3] ^ out[1]};
    end
endmodule"
