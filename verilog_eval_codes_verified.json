[
  {
    "problem_number": 1,
    "problem_name": "zero",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - output zero\n\nThe module should always outputs a LOW.",
    "reference_implementation": "module RefModule (\n  output zero\n);\n\n  assign zero = 1'b0;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  output zero\n);\n\n  assign zero = 1'b0;\n\nendmodule",
    "buggy_implementation": "module TopModule (\n  output zero\n);\n  reg zero;\n  always @(*) zero = 1'b1;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 2,
    "problem_name": "m2014_q4i",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - output out\n\nThe module should always drive 0 (or logic low).",
    "reference_implementation": "module RefModule (\n  output out\n);\n\n  assign out = 1'b0;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  output out\n);\n\n  assign out = 1'b0;\n\nendmodule",
    "buggy_implementation": "module TopModule (\n  output out\n);\n  assign out = 1'b1;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 3,
    "problem_name": "step_one",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - output one\n\nThe module should always drive 1 (or logic high).",
    "reference_implementation": "module RefModule (\n  output one\n);\n\n  assign one = 1'b1;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  output one\n);\n\n  assign one = 1'b1;\n\nendmodule",
    "buggy_implementation": "module TopModule (\n  output one\n);\n  reg one = 1'b0;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 4,
    "problem_name": "vector2",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in  (32 bits)\n - output out (32 bits)\n\nThe module should reverse the byte order of a 32-bit vector.",
    "reference_implementation": "module RefModule (\n  input [31:0] in,\n  output [31:0] out\n);\n\n  assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [31:0] in,\n  output [31:0] out\n);\n  assign out[7:0] = in[31:24];\n  assign out[15:8] = in[23:16];\n  assign out[23:16] = in[15:8];\n  assign out[31:24] = in[7:0];\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [31:0] in,\n  output [31:0] out\n);\n  assign out = {in[15:8], in[7:0], in[31:24], in[23:16]};\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 5,
    "problem_name": "notgate",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in\n - output out\n\nThe module should implement a NOT gate.",
    "reference_implementation": "module RefModule (\n  input in,\n  output out\n);\n\n  assign out = ~in;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input in,\n  output out\n);\n  wire tmp;\n  assign tmp = in;\n  assign out = ~tmp;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input in,\n  output out\n);\n  assign out = in;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 6,
    "problem_name": "vectorr",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in  (8 bits)\n - output out (8 bits)\n\nThe module should reverse the bit ordering of the input port and write\nthe result to the output port.",
    "reference_implementation": "module RefModule (\n  input [7:0] in,\n  output [7:0] out\n);\n\n  assign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [7:0] in,\n  output [7:0] out\n);\n  assign out[0] = in[7];\n  assign out[1] = in[6];\n  assign out[2] = in[5];\n  assign out[3] = in[4];\n  assign out[4] = in[3];\n  assign out[5] = in[2];\n  assign out[6] = in[1];\n  assign out[7] = in[0];\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [7:0] in,\n  output [7:0] out\n);\n  assign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = {in[0],in[1],in[2],in[3],in[4],in[5],in[6]};\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 7,
    "problem_name": "wire",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in\n - output out\n\nThe module should behave like a wire.",
    "reference_implementation": "module RefModule (\n  input in,\n  output out\n);\n\n  assign out = in;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input  in,\n  output out\n);\n  wire temp;\n  assign temp = in;\n  assign out = temp;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input in,\n  output out\n);\n  reg out;\n  always @(in) begin\n    out <= in;\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 8,
    "problem_name": "m2014_q4h",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in\n - output out\n\nThe module should assign the output port to the same value as the input\nport combinationally.",
    "reference_implementation": "module RefModule (\n  input in,\n  output out\n);\n\n  assign out = in;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input in,\n  output out\n);\n\n  assign out = in;\n\nendmodule",
    "buggy_implementation": "module TopModule (\n  input in,\n  output out\n);\n  reg out;\n  always @(*) out = ~in;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 9,
    "problem_name": "popcount3",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in  (3 bits)\n - output out (2 bits)\n\nThe module should implement a \"population count\" circuit that counts the\nnumber of '1's in the input vector.",
    "reference_implementation": "module RefModule (\n  input [2:0] in,\n  output [1:0] out\n);\n\n  assign out = in[0]+in[1]+in[2];\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [2:0] in,\n  output [1:0] out\n);\n  wire [1:0] temp;\n  assign temp[0] = in[0] ^ in[1];\n  assign temp[1] = in[0] & in[1];\n  assign out = temp + in[2];\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [2:0] in,\n  output [1:0] out\n);\n  assign out = in[0] + in[1];\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 10,
    "problem_name": "mt2015_q4a",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  x\n - input  y\n - output z\n\nThe module should implement the boolean function z = (x^y) & x.",
    "reference_implementation": "module RefModule (\n  input x,\n  input y,\n  output z\n);\n\n  assign z = (x^y) & x;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input x,\n  input y,\n  output z\n);\n  wire tmp;\n  assign tmp = x ^ y;\n  assign z = tmp & x;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input x,\n  input y,\n  output z\n);\n  assign z = (x^y) | x;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 11,
    "problem_name": "norgate",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - output out\n\nThe module should implement a NOR gate.",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  output out\n);\n\n  assign out = ~(a | b);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  output out\n);\n  wire temp;\n  assign temp = a | b;\n  assign out = ~temp;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  output out\n);\n  assign out = ~(a & b);\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 12,
    "problem_name": "xnorgate",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - output out\n\nThe module should implement an XNOR gate.",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  output out\n);\n\n  assign out = ~(a^b);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  output out\n);\n  assign out = (a&b) | (~a & ~b);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  output out\n);\n  assign out = ~a^b;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 13,
    "problem_name": "m2014_q4e",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in1\n - input  in2\n - output out\n\nThe module should implement a 2-input NOR gate.",
    "reference_implementation": "module RefModule (\n  input in1,\n  input in2,\n  output logic out\n);\n\n  assign out = ~(in1 | in2);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input  in1,\n  input  in2,\n  output out\n);\n  wire temp;\n  assign temp = in1 | in2;\n  assign out = ~temp;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input  in1,\n  input  in2,\n  output out\n);\n  assign out = ~in1 | in2;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 14,
    "problem_name": "andgate",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - output out\n\nThe module should implement a 2-input AND gate.",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  output out\n);\n\n  assign out = a & b;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  output out\n);\n  assign out = b & a;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  output out\n);\n  assign out = a | b;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 15,
    "problem_name": "vector1",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in     (16 bits)\n - output out_hi ( 8 bits)\n - output out_lo ( 8 bits)\n\nThe module should implement a combinational circuit that splits an input\nhalf-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.",
    "reference_implementation": "module RefModule (\n  input [15:0] in,\n  output [7:0] out_hi,\n  output [7:0] out_lo\n);\n\n  assign {out_hi, out_lo} = in;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [15:0] in,\n  output [7:0] out_hi,\n  output [7:0] out_lo\n);\n  assign out_hi = in[15:8];\n  assign out_lo = in[7:0];\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [15:0] in,\n  output [7:0] out_hi,\n  output [7:0] out_lo\n);\n  assign out_hi = in[7:0];\n  assign out_lo = in[15:8];\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 16,
    "problem_name": "m2014_q4j",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  x   (4 bits)\n - input  y   (4 bits)\n - output sum (5 bits)\n\nImplement a 4-bit adder with full adders. The output sum should include\nthe overflow bit.",
    "reference_implementation": "module RefModule (\n  input [3:0] x,\n  input [3:0] y,\n  output [4:0] sum\n);\n\n  assign sum = x+y;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [3:0] x,\n  input [3:0] y,\n  output [4:0] sum\n);\n  wire [3:0] temp_sum;\n  wire temp_cout;\n  assign {temp_cout, temp_sum} = x + y;\n  assign sum = {temp_cout, temp_sum};\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [3:0] x,\n  input [3:0] y,\n  output [4:0] sum\n);\n  assign sum = x + y[2:0];\nendmodule",
    "difficulty": "easy",
    "category": "arithmetic"
  },
  {
    "problem_number": 17,
    "problem_name": "mux2to1v",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a   (100 bits)\n - input  b   (100 bits)\n - input  sel\n - output out (100 bits)\n\nThe module should implement a 2-1 multiplexer. When sel=0, choose a. When\nsel=1, choose b.",
    "reference_implementation": "module RefModule (\n  input [99:0] a,\n  input [99:0] b,\n  input sel,\n  output [99:0] out\n);\n\n  assign out = sel ? b : a;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [99:0] a,\n  input [99:0] b,\n  input sel,\n  output [99:0] out\n);\n  assign out = (sel == 1'b1) ? b : a;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [99:0] a,\n  input [99:0] b,\n  input sel,\n  output [99:0] out\n);\n  assign out = sel ? b[98:0] : a;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 18,
    "problem_name": "mux256to1",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in  (256 bits)\n - input  sel (  8 bits)\n - output out\n\nThe module should implement a 1-bit wide, 256-to-1 multiplexer. The 256\ninputs are all packed into a single 256-bit input vector. sel=0 should\nselect in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.",
    "reference_implementation": "module RefModule (\n  input [255:0] in,\n  input [7:0] sel,\n  output  out\n);\n\n  assign out = in[sel];\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [255:0] in,\n  input [7:0] sel,\n  output out\n);\n  wire [255:0] in_bus = in;\n  assign out = in_bus[sel];\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [255:0] in,\n  input [7:0] sel,\n  output out\n);\n  assign out = in[sel + 1];\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 19,
    "problem_name": "m2014_q4f",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in1\n - input  in2\n - output out\n\nThe module should implement the following circuit in Verilog. Two inputs\n(in1 and in2) go to an AND gate, but the in2 input to the AND gate has a\nbubble. The output of the AND gate is connected to 'out'.",
    "reference_implementation": "module RefModule (\n  input in1,\n  input in2,\n  output logic out\n);\n\n  assign out = in1 & ~in2;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input in1,\n  input in2,\n  output logic out\n);\n  wire temp = ~in2;\n  assign out = in1 & temp;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input in1,\n  input in2,\n  output logic out\n);\n  assign out = in1 & in2;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 20,
    "problem_name": "mt2015_eq2",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  A (2 bits)\n - input  B (2 bits)\n - output z\n\nThe module should implement a circuit that has two 2-bit inputs A[1:0]\nand B[1:0], and produces an output z. The value of z should be 1 if A =\nB, otherwise z should be 0.",
    "reference_implementation": "module RefModule (\n  input [1:0] A,\n  input [1:0] B,\n  output z\n);\n\n  assign z = A[1:0]==B[1:0];\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [1:0] A,\n  input [1:0] B,\n  output z\n);\n\n  assign z = (A == B);\n\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [1:0] A,\n  input [1:0] B,\n  output z\n);\n  assign z = A[0]==B[0];\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 21,
    "problem_name": "mux256to1v",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in  (1024 bits)\n - input  sel (   8 bits)\n - output out (   4 bits)\n\nThe module should implement a 4-bit wide, 256-to-1 multiplexer. The 256\n4-bit inputs are all packed into a single 1024-bit input vector. sel=0\nshould select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects\nbits in[11:8], etc.",
    "reference_implementation": "module RefModule (\n  input [1023:0] in,\n  input [7:0] sel,\n  output [3:0] out\n);\n\n  assign out = {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]};\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [1023:0] in,\n  input [7:0] sel,\n  output [3:0] out\n);\n  wire [3:0] temp;\n  assign temp = {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4]};\n  assign out = temp;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [1023:0] in,\n  input [7:0] sel,\n  output [3:0] out\n);\n  assign out = {in[sel*4+3], in[sel*4+2], in[sel*4+1]};\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 22,
    "problem_name": "mux2to1",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  sel\n - output out\n\nThe module should implement a one-bit wide, 2-to-1 multiplexer. When\nsel=0, choose a. When sel=1, choose b.",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input sel,\n  output out\n);\n\n  assign out = sel ? b : a;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  input sel,\n  output out\n);\n\n  assign out = sel ? b : a;\n\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  input sel,\n  output out\n);\n  assign out = sel ? a : b;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 23,
    "problem_name": "vector100r",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in  (100 bits)\n - output out (100 bits)\n\nThe module should reverse the bit ordering of the input and write to the\noutput.",
    "reference_implementation": "module RefModule (\n  input [99:0] in,\n  output reg [99:0] out\n);\n\n  always_comb\n    for (int i=0;i<$bits(out);i++)\n      out[i] = in[$bits(out)-i-1];\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [99:0] in,\n  output reg [99:0] out\n);\n  always @* begin\n    for (int j=0; j<100; j=j+1)\n      out[j] = in[99-j];\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [99:0] in,\n  output reg [99:0] out\n);\n  always_comb\n    for (int i=0;i<$bits(out);i++)\n      out[i] = in[$bits(out)-i];\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 24,
    "problem_name": "hadd",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - output sum\n - output cout\n\nThe module should implement a half adder. A half adder adds two bits\n(with no carry-in) and produces a sum and carry-out.",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  output sum,\n  output cout\n);\n\n  assign {cout, sum} = a+b;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  output sum,\n  output cout\n);\n  assign sum = a ^ b;\n  assign cout = a & b;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  output sum,\n  output cout\n);\n  assign sum = a | b;\n  assign cout = a & b;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 25,
    "problem_name": "reduction",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in     (8 bits)\n - output parity\n\nParity checking is often used as a simple method of detecting errors when\ntransmitting data through an imperfect channel. The module should compute\na parity bit for an 8-bit byte (which will add a 9th bit to the byte). We\nwill use \"even\" parity, where the parity bit is just the XOR of all 8\ndata bits.",
    "reference_implementation": "module RefModule (\n  input [7:0] in,\n  output parity\n);\n\n  assign parity = ^in;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [7:0] in,\n  output parity\n);\n  wire [7:0] tmp;\n  assign tmp = in;\n  assign parity = ^tmp;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [7:0] in,\n  output parity\n);\n  assign parity = ^in[6:0];\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 26,
    "problem_name": "alwaysblock1",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - output out_assign\n - output out_alwaysblock\n\nThe module should implement an AND gate using both an assign statement\nand a combinational always block.",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  output out_assign,\n  output reg out_alwaysblock\n);\n\n  assign out_assign = a & b;\n  always @(*) out_alwaysblock = a & b;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  output out_assign,\n  output reg out_alwaysblock\n);\n  always @(*) out_alwaysblock = a & b;\n  assign out_assign = a & b;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  output out_assign,\n  output reg out_alwaysblock\n);\n  assign out_assign = a | b;\n  always @(*) out_alwaysblock = a & b;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 27,
    "problem_name": "fadd",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  cin\n - output cout\n - output sum\n\nThe module should impement a full adder. A full adder adds three bits\n(including carry-in) and produces a sum and carry-out.",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input cin,\n  output cout,\n  output sum\n);\n\n  assign {cout, sum} = a+b+cin;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  input cin,\n  output cout,\n  output sum\n);\n  wire temp_sum = a ^ b;\n  assign sum = temp_sum ^ cin;\n  assign cout = (a & b) | (temp_sum & cin);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  input cin,\n  output cout,\n  output sum\n);\n  assign sum = a ^ b ^ cin;\n  assign cout = (a | b) & (a | cin);\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 28,
    "problem_name": "m2014_q4a",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  d\n - input  ena\n - output q\n\nThe module should impement a D latch using an always block.",
    "reference_implementation": "module RefModule (\n  input d,\n  input ena,\n  output logic q\n);\n\n  always@(*) begin\n    if (ena)\n      q = d;\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input d,\n  input ena,\n  output reg q\n);\nalways @(ena or d) begin\n  if (ena)\n    q <= d;\nend\nendmodule",
    "buggy_implementation": "module TopModule (\n  input d,\n  input ena,\n  output reg q\n);\nalways @(*) begin\n  if (!ena)\n    q = d;\nend\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 29,
    "problem_name": "m2014_q4g",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in1\n - input  in2\n - input  in3\n - output out\n\nThe module should impement the following circuit: A two-input XNOR\n(connected to 'in1' and 'in2) has an output connected to the input of a\ntwo-input XOR. The second input of the XOR is 'in3.' The output of the\nXOR is 'out'.",
    "reference_implementation": "module RefModule (\n  input in1,\n  input in2,\n  input in3,\n  output logic out\n);\n\n  assign out = (~(in1 ^ in2)) ^ in3;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input in1,\n  input in2,\n  input in3,\n  output out\n);\n  wire xnor_out;\n  assign xnor_out = ~(in1 ^ in2);\n  assign out = xnor_out ^ in3;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input in1,\n  input in2,\n  input in3,\n  output out\n);\n  assign out = (~(in1 | in2)) ^ in3;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 30,
    "problem_name": "popcount255",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in  (255 bits)\n - output out (  8 bits)\n\nA \"population count\" circuit counts the number of '1's in an input\nvector. The module should implement a population count circuit for a\n255-bit input vector.",
    "reference_implementation": "module RefModule (\n  input [254:0] in,\n  output reg [7:0] out\n);\n\n  always_comb  begin\n    out = 0;\n    for (int i=0;i<255;i++)\n      out = out + in[i];\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [254:0] in,\n  output reg [7:0] out\n);\n  always @(*) begin\n    out = 8'b0;\n    for (integer i = 0; i < 255; i = i + 1)\n      out = out + in[i];\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [254:0] in,\n  output reg [7:0] out\n);\n  always_comb begin\n    out = 0;\n    for (int i=0; i<254; i++)\n      out = out + in[i];\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 31,
    "problem_name": "dff",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input clk\n - input d\n - input q\n\nThe module should implement a single D flip-flop. Assume all sequential\nlogic is triggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input d,\n  output reg q\n);\n\n  initial\n    q = 1'hx;\n\n  always @(posedge clk)\n    q <= d;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input d,\n  output reg q\n);\n  always @(posedge clk) begin\n    q <= d;\n  end\n  initial\n    q = 1'b0;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input d,\n  output reg q\n);\n  initial\n    q = 1'hx;\n  always @(negedge clk)\n    q <= d;\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 32,
    "problem_name": "vector0",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  vec  (3 bits)\n - output outv (3 bits)\n - output o2\n - output o1\n - output o0\n\nThe module has one 3-bit input, then outputs the same vector, and also\nsplits it into three separate 1-bit outputs. Connect output o0 to the\ninput vector's position 0, o1 to position 1, etc.",
    "reference_implementation": "module RefModule (\n  input [2:0] vec,\n  output [2:0] outv,\n  output o2,\n  output o1,\n  output o0\n);\n\n  assign outv = vec;\n  assign {o2, o1, o0} = vec;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [2:0] vec,\n  output [2:0] outv,\n  output o2,\n  output o1,\n  output o0\n);\n  assign {o2, o1, o0} = vec;\n  assign outv = {o2, o1, o0};\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [2:0] vec,\n  output [2:0] outv,\n  output o2,\n  output o1,\n  output o0\n);\n  assign outv = vec;\n  assign {o1, o0} = vec[1:0];\n  assign o2 = vec[2];\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 33,
    "problem_name": "ece241_2014_q1c",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a (8 bits)\n - input  b (8 bits)\n - output s (8 bits)\n - output overflow\n\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0].\nThe module should add these numbers to produce s[7:0]. Also compute\nwhether a (signed) overflow has occurred.",
    "reference_implementation": "module RefModule (\n  input [7:0] a,\n  input [7:0] b,\n  output [7:0] s,\n  output overflow\n);\n\n  wire [8:0] sum = a+b;\n  assign s = sum[7:0];\n  assign overflow = !(a[7]^b[7]) && (a[7] != s[7]);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [7:0] a,\n  input [7:0] b,\n  output [7:0] s,\n  output overflow\n);\n  wire [8:0] sum;\n  assign sum = {1'b0, a} + {1'b0, b};\n  assign s = sum[7:0];\n  assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [7:0] a,\n  input [7:0] b,\n  output [7:0] s,\n  output overflow\n);\n  wire [8:0] sum = a + b;\n  assign s = sum[6:0];\n  assign overflow = !(a[7]^b[7]) && (a[7] != s[7]);\nendmodule",
    "difficulty": "medium",
    "category": "arithmetic"
  },
  {
    "problem_number": 34,
    "problem_name": "dff8",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  d   (8 bits)\n - output q   (8 bits)\n\nThe module should include 8 D flip-flops. All DFFs should be triggered by\nthe positive edge of clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input [7:0] d,\n  output reg [7:0] q\n);\n\n  initial\n    q = 8'h0;\n\n  always @(posedge clk)\n    q <= d;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input [7:0] d,\n  output reg [7:0] q\n);\n  always @(posedge clk) begin\n    q <= d;\n  end\n  initial begin\n    q = 8'h0;\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input [7:0] d,\n  output reg [7:0] q\n);\n  initial\n    q = 8'h0;\n  always @(posedge clk)\n    q <= d[6:0];\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 35,
    "problem_name": "count1to10",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output q (4 bits)\n\nThe module should implement a decade counter that counts 1 through 10,\ninclusive. Assume all sequential logic is triggered on the positive edge\nof the clock. The reset input is active high synchronous, and should\nreset the counter to 1.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n\n  always @(posedge clk)\n    if (reset || q == 10)\n      q <= 1;\n    else\n      q <= q+1;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n  always @(posedge clk) begin\n    if (reset)\n      q <= 1;\n    else if (q == 10)\n      q <= 1;\n    else\n      q <= q + 1;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n  always @(posedge clk)\n    if (reset || q == 4'b1010)\n      q <= 4'd0;\n    else\n      q <= q + 1;\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 36,
    "problem_name": "ringer",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  ring\n - input  vibrate_mode\n - output ringer\n - output motor\n\nThe module should implement a circuit to control a cellphone's ringer and\nvibration motor. Whenever the phone needs to ring from an incoming call\n(input ring), your circuit must either turn on the ringer (output ringer\n= 1) or the motor (output motor = 1), but not both. If the phone is in\nvibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn\non the ringer.",
    "reference_implementation": "module RefModule (\n  input ring,\n  input vibrate_mode,\n  output ringer,\n  output motor\n);\n\n  assign ringer = ring & ~vibrate_mode;\n  assign motor = ring & vibrate_mode;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input ring,\n  input vibrate_mode,\n  output ringer,\n  output motor\n);\n  assign motor = ring && vibrate_mode;\n  assign ringer = ring && !vibrate_mode;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input ring,\n  input vibrate_mode,\n  output ringer,\n  output motor\n);\n  assign ringer = ring & vibrate_mode;\n  assign motor = ring & vibrate_mode;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 37,
    "problem_name": "review2015_count1k",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output q (10 bits)\n\nThe module should implement a counter that counts from 0 to 999,\ninclusive, with a period of 1000 cycles. Assume all sequential logic is\ntriggered on the positive edge of the clock. The reset input is active\nhigh synchronous, and should reset the counter to 0.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  output reg [9:0] q\n);\n\n  always @(posedge clk)\n    if (reset || q == 999)\n      q <= 0;\n    else\n      q <= q+1;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  output reg [9:0] q\n);\n  always @(posedge clk) begin\n    if (reset)\n      q <= 0;\n    else if (q == 999)\n      q <= 0;\n    else\n      q <= q + 1;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input reset,\n  output reg [9:0] q\n);\n  always @(posedge clk)\n    if (reset || q == 1000)\n      q <= 0;\n    else\n      q <= q+1;\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 38,
    "problem_name": "count15",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output q (4 bits)\n\nThe module should implement a 4-bit binary counter that counts from 0\nthrough 15, inclusive, with a period of 16. Assume all sequential logic\nis triggered on the positive edge of the clock. The reset input is active\nhigh synchronous, and should reset the counter to 0.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n\n  always @(posedge clk)\n    if (reset)\n      q <= 0;\n    else\n      q <= q+1;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n  always @(posedge clk) begin\n    if (reset) q <= 4'b0000;\n    else       q <= q + 4'b0001;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n  always @(posedge clk)\n    if (!reset)\n      q <= q+1;\n    else\n      q <= 0;\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 39,
    "problem_name": "always_if",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  sel_b1\n - input  sel_b2\n - output out_assign\n - output out_always\n\nThe module should implement a 2-to-1 mux that chooses between a and b.\nChoose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the\nsame twice, once using assign statements and once using a procedural if\nstatement.",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input sel_b1,\n  input sel_b2,\n  output out_assign,\n  output reg out_always\n);\n\n  assign out_assign = (sel_b1 & sel_b2) ? b : a;\n  always @(*) out_always = (sel_b1 & sel_b2) ? b : a;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  input sel_b1,\n  input sel_b2,\n  output out_assign,\n  output reg out_always\n);\n  assign out_assign = sel_b1 && sel_b2 ? b : a;\n  always @(*) begin\n    if (sel_b1 && sel_b2) out_always = b;\n    else out_always = a;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  input sel_b1,\n  input sel_b2,\n  output out_assign,\n  output reg out_always\n);\n  assign out_assign = (sel_b1 | sel_b2) ? b : a;\n  always @(*) out_always = (sel_b1 & sel_b2) ? b : a;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 40,
    "problem_name": "count10",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output q (4 bits)\n\nThe module should implement a decade counter that counts from 0 through\n9, inclusive, with a period of 10. Assume all sequential logic is\ntriggered on the positive edge of the clock. The reset input is active\nhigh synchronous, and should reset the counter to 0.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n\n  always @(posedge clk)\n    if (reset || q == 9)\n      q <= 0;\n    else\n      q <= q+1;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n  always @(posedge clk) begin\n    if (reset)\n      q <= 0;\n    else if (q == 9)\n      q <= 0;\n    else\n      q <= q + 1;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n  always @(posedge clk)\n    if (reset || q == 10)\n      q <= 0;\n    else\n      q <= q + 1;\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 41,
    "problem_name": "dff8r",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  d (8 bits)\n - output q (8 bits)\n\nThe module should include 8 D flip-flops with active high synchronous\nreset setting the output to zero. All DFFs should be triggered by the\npositive edge of clk.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input [7:0] d,\n  input reset,\n  output reg [7:0] q\n);\n\n  always @(posedge clk)\n    if (reset)\n      q <= 0;\n    else\n      q <= d;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  input [7:0] d,\n  output reg [7:0] q\n);\n  always @(posedge clk) begin\n    if (reset == 1'b1)\n      q <= 8'b00000000;\n    else\n      q <= d;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input reset,\n  input [7:0] d,\n  output reg [7:0] q\n);\n  always @(posedge clk)\n    if (reset)\n      q <= 0;\n    else\n      q <= d[6:0];\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 42,
    "problem_name": "vector4",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in  (8  bits)\n - output out (32 bits)\n\nOne common place to see a replication operator is when sign-extending a\nsmaller number to a larger one, while preserving its signed value. This\nis done by replicating the sign bit (the most significant bit) of the\nsmaller number to the left. For example, sign-extending 4'b0101 (5) to 8\nbits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8\nbits results in 8'b11111101 (-3). Implement a module that sign-extends an\n8-bit number to 32 bits. This requires a concatenation of 24 copies of\nthe sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit\nnumber itself.",
    "reference_implementation": "module RefModule (\n  input [7:0] in,\n  output [31:0] out\n);\n\n  assign out = { {24{in[7]}}, in };\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [7:0] in,\n  output [31:0] out\n);\n  wire [23:0] sign_extend_bits = {24{in[7]}};\n  assign out = {sign_extend_bits, in};\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [7:0] in,\n  output [31:0] out\n);\n  assign out = { {24{in[3]}}, in };\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 43,
    "problem_name": "vector5",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  c\n - input  d\n - input  e\n - output out (25 bits)\n\nImplement a module that given five 1-bit signals (a, b, c, d, and e),\ncompute all 25 pairwise one-bit comparisons in the 25-bit output vector.\nThe output should be 1 if the two bits being compared are equal. Example:\nout[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ...\nout[ 1] = ~e ^ d; out[ 0] = ~e ^ e.",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  input e,\n  output [24:0] out\n);\n\n  assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  input e,\n  output [24:0] out\n);\n  wire [4:0] inputs = {a, b, c, d, e};\n  assign out = ~({5{inputs}} ^ {inputs[4], inputs[4], inputs[4], inputs[4], inputs[4],\n                               inputs[3], inputs[3], inputs[3], inputs[3], inputs[3],\n                               inputs[2], inputs[2], inputs[2], inputs[2], inputs[2],\n                               inputs[1], inputs[1], inputs[1], inputs[1], inputs[1],\n                               inputs[0], inputs[0], inputs[0], inputs[0], inputs[0]});\nendmodule",
    "buggy_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  input e,\n  output [24:0] out\n);\n  assign out = ~{ {4{a}}, {4{b}}, {4{c}}, {4{d}}, {4{e}} } ^ {5{a,b,c,d,e}};\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 44,
    "problem_name": "vectorgates",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a              (3 bits)\n - input  b              (3 bits)\n - output out_or_bitwise (3 bits)\n - output out_or_logical\n - output out_not        (6 bits)\n\nImplement a module with two 3-bit inputs that computes the bitwise-OR of\nthe two vectors, the logical-OR of the two vectors, and the inverse (NOT)\nof both vectors. Place the inverse of b in the upper half of out_not\n(i.e., bits [5:3]), and the inverse of a in the lower half.",
    "reference_implementation": "module RefModule (\n  input [2:0] a,\n  input [2:0] b,\n  output [2:0] out_or_bitwise,\n  output out_or_logical,\n  output [5:0] out_not\n);\n\n  assign out_or_bitwise = a | b;\n  assign out_or_logical = a || b;\n  assign out_not = {~b,~a};\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [2:0] a,\n  input [2:0] b,\n  output [2:0] out_or_bitwise,\n  output out_or_logical,\n  output [5:0] out_not\n);\n  assign out_or_logical = |a || |b;\n  assign out_or_bitwise = a | b;\n  assign out_not = {~b[2:0], ~a[2:0]};\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [2:0] a,\n  input [2:0] b,\n  output [2:0] out_or_bitwise,\n  output out_or_logical,\n  output [5:0] out_not\n);\n  assign out_or_bitwise = a | b;\n  assign out_or_logical = |a | |b;\n  assign out_not = {~b[2:1], ~a};\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 45,
    "problem_name": "edgedetect2",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input clk\n - input in       (8 bits)\n - output anyedge (8 bits)\n\nImplement a module that for each bit in an 8-bit input vector, detect\nwhen the input signal changes from one clock cycle to the next (detect\nany edge). The output bit of anyedge should be set to 1 the cycle \nafter the input bit has 0 to 1 or 1 to 0 transition occurs. Assume all \nsequential logic is triggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input [7:0] in,\n  output reg [7:0] anyedge\n);\n\n  reg [7:0] d_last;\n\n  always @(posedge clk) begin\n    d_last <= in;\n    anyedge <= in ^ d_last;\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input [7:0] in,\n  output reg [7:0] anyedge\n);\n  reg [7:0] d_last;\n  always @(posedge clk) begin\n    anyedge <= in ^ d_last;\n    d_last <= in;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input [7:0] in,\n  output reg [7:0] anyedge\n);\n  reg [6:0] d_last;\n  always @(posedge clk) begin\n    d_last <= in[6:0];\n    anyedge <= in ^ d_last;\n  end\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 46,
    "problem_name": "dff8p",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  d (8 bits)\n - output q (8 bits)\n\nImplement a module that includes 8 D flip-flops with active high\nsynchronous reset. The flip-flops must be reset to 0x34 rather than zero.\nAll DFFs should be triggered by the negative edge of clk.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input [7:0] d,\n  input reset,\n  output reg [7:0] q\n);\n\n  always @(negedge clk)\n    if (reset)\n      q <= 8'h34;\n    else\n      q <= d;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input [7:0] d,\n  input reset,\n  output reg [7:0] q\n);\n  always @(negedge clk) begin\n    if (reset) begin\n      q <= 8'h34;\n    end else begin\n      q <= d;\n    end\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input [7:0] d,\n  input reset,\n  output reg [7:0] q\n);\n  always @(negedge clk)\n    if (reset)\n      q <= 8'h35;\n    else\n      q <= d;\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 47,
    "problem_name": "dff8ar",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  d      (8 bits)\n - output q      (8 bits)\n\nThe module should include 8 D flip-flops with active high asynchronous\nreset. The output should be reset to 0. All DFFs should be triggered by\nthe positive edge of clk.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input [7:0] d,\n  input areset,\n  output reg [7:0] q\n);\n\n  always @(posedge clk, posedge areset)\n    if (areset)\n      q <= 0;\n    else\n      q <= d;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input [7:0] d,\n  input areset,\n  output reg [7:0] q\n);\n  always @(posedge clk or posedge areset)\n    if (areset)\n      q <= 8'b0;\n    else\n      q <= d;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input [7:0] d,\n  input areset,\n  output reg [7:0] q\n);\n  always @(posedge clk or posedge areset)\n    if (areset)\n      q <= 1'b0;\n    else\n      q <= d;\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 48,
    "problem_name": "m2014_q4c",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  d\n - input  r\n - output q\n\nThe module should implement a simple D flip flop with active high\nsynchronous reset (reset output to 0).",
    "reference_implementation": "module RefModule (\n  input clk,\n  input d,\n  input r,\n  output logic q\n);\n\n  always@(posedge clk) begin\n    if (r)\n      q <= 0;\n    else\n      q <= d;\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input d,\n  input r,\n  output reg q\n);\n  always @(posedge clk) begin\n    if (r == 1'b1)\n      q <= 1'b0;\n    else\n      q <= d;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input d,\n  input r,\n  output reg q\n);\n  always @(posedge clk) begin\n    if (r)\n      q <= d;\n    else\n      q <= 0;\n  end\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 49,
    "problem_name": "m2014_q4b",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  ar\n - input  d\n - output q\n\nThe module should implement a D flip flop, positive edge triggered, with\nan asynchronous reset \"ar\".",
    "reference_implementation": "module RefModule (\n  input clk,\n  input d,\n  input ar,\n  output logic q\n);\n\n  always@(posedge clk or posedge ar) begin\n    if (ar)\n      q <= 0;\n    else\n      q <= d;\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input d,\n  input ar,\n  output logic q\n);\n  always @(posedge clk, posedge ar) begin\n    if (ar) q <= 0;\n    else    q <= d;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input d,\n  input ar,\n  output logic q\n);\n  always @(posedge clk) begin\n    if (ar)\n      q <= 0;\n    else\n      q <= d;\n  end\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 50,
    "problem_name": "kmap1",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  c\n - output out\n\nThe module should implement the circuit described by the Karnaugh map\nbelow.\n\n          a\n   bc   0   1\n   00 | 0 | 1 |\n   01 | 1 | 1 |\n   11 | 1 | 1 |\n   10 | 1 | 1 |",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  output out\n);\n\n  assign out = (a | b | c);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  output out\n);\n  assign out = (b | c | a);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  output out\n);\n  assign out = (a | b);\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 51,
    "problem_name": "gates4",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in (4 bits)\n - output out_and\n - output out_or\n - output out_xor\n\nThe module should implement a combinational circuit with four inputs,\nin[3:0]. There are 3 outputs:\n\n  (1) out_and : output of a 4-input AND gate\n  (2) out_or  : output of a 4-input OR  gate\n  (3) out_xor : output of a 4-input XOR gate",
    "reference_implementation": "module RefModule (\n  input [3:0] in,\n  output out_and,\n  output out_or,\n  output out_xor\n);\n\n  assign out_and = &in;\n  assign out_or = |in;\n  assign out_xor = ^in;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [3:0] in,\n  output out_and,\n  output out_or,\n  output out_xor\n);\n  assign out_and = in[0] & in[1] & in[2] & in[3];\n  assign out_or = in[0] | in[1] | in[2] | in[3];\n  assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [3:0] in,\n  output out_and,\n  output out_or,\n  output out_xor\n);\n  assign out_and = &in[2:0];\n  assign out_or = |in;\n  assign out_xor = ^in;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 52,
    "problem_name": "gates100",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in (100 bits)\n - output out_and\n - output out_or\n - output out_xor\n\nThe module should implement a combinational circuit with 100 inputs,\nin[99:0]. There are 3 outputs:\n\n  (1) out_and : output of a 100-input AND gate\n  (2) out_or  : output of a 100-input OR  gate\n  (3) out_xor : output of a 100-input XOR gate",
    "reference_implementation": "module RefModule (\n  input [99:0] in,\n  output out_and,\n  output out_or,\n  output out_xor\n);\n\n  assign out_and = &in;\n  assign out_or = |in;\n  assign out_xor = ^in;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [99:0] in,\n  output out_and,\n  output out_or,\n  output out_xor\n);\n  assign out_and = in[99] & in[98] & in[97] & in[96] & in[95] &\n                  in[94] & in[93] & in[92] & in[91] & in[90] &\n                  in[89] & in[88] & in[87] & in[86] & in[85] &\n                  in[84] & in[83] & in[82] & in[81] & in[80] &\n                  in[79] & in[78] & in[77] & in[76] & in[75] &\n                  in[74] & in[73] & in[72] & in[71] & in[70] &\n                  in[69] & in[68] & in[67] & in[66] & in[65] &\n                  in[64] & in[63] & in[62] & in[61] & in[60] &\n                  in[59] & in[58] & in[57] & in[56] & in[55] &\n                  in[54] & in[53] & in[52] & in[51] & in[50] &\n                  in[49] & in[48] & in[47] & in[46] & in[45] &\n                  in[44] & in[43] & in[42] & in[41] & in[40] &\n                  in[39] & in[38] & in[37] & in[36] & in[35] &\n                  in[34] & in[33] & in[32] & in[31] & in[30] &\n                  in[29] & in[28] & in[27] & in[26] & in[25] &\n                  in[24] & in[23] & in[22] & in[21] & in[20] &\n                  in[19] & in[18] & in[17] & in[16] & in[15] &\n                  in[14] & in[13] & in[12] & in[11] & in[10] &\n                  in[9] & in[8] & in[7] & in[6] & in[5] &\n                  in[4] & in[3] & in[2] & in[1] & in[0];\n  assign out_or = |in;\n  assign out_xor = ^in;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [99:0] in,\n  output out_and,\n  output out_or,\n  output out_xor\n);\n  assign out_and = &in[98:0];\n  assign out_or = |in;\n  assign out_xor = ^in;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 53,
    "problem_name": "m2014_q4d",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  in\n - output out\n\nThe module should implement the following circuit: A D flip-flop takes as\ninput the output of a two-input XOR. The flip-flop is positive edge\ntriggered by clk, but there is no reset. The XOR takes as input 'in'\nalong with the output 'out' of the flip-flop.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input in,\n  output logic out\n);\n\n  initial\n    out = 0;\n\n  always@(posedge clk) begin\n    out <= in ^ out;\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input in,\n  output reg out\n);\n  always @(posedge clk) begin\n    out <= out ^ in;\n  end\n  initial\n    out = 1'b0;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input in,\n  output reg out\n);\n  always @(posedge clk) begin\n    out <= in & out;\n  end\n  initial\n    out = 1'b0;\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 54,
    "problem_name": "edgedetect",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  in    (8 bits)\n - output pedge (8 bits)\n\nThe module should examine each bit in an 8-bit vector and detect when the\ninput signal changes from 0 in one clock cycle to 1 the next (similar to\npositive edge detection). The output bit should be set the cycle after a\n0 to 1 transition occurs.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input [7:0] in,\n  output reg [7:0] pedge\n);\n\n  reg [7:0] d_last;\n\n  always @(posedge clk) begin\n    d_last <= in;\n    pedge <= in & ~d_last;\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input [7:0] in,\n  output reg [7:0] pedge\n);\n  reg [7:0] d_last;\n  always @(posedge clk) begin\n    pedge <= in & ~d_last;\n    d_last <= in;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input [7:0] in,\n  output reg [7:0] pedge\n);\n  reg [7:0] d_last;\n  always @(posedge clk) begin\n    d_last <= in;\n    pedge <= in | ~d_last;\n  end\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 55,
    "problem_name": "conditional",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a   (8 bits)\n - input  b   (8 bits)\n - input  c   (8 bits)\n - input  d   (8 bits)\n - output min (8 bits)\n\nThe module should find the minimum of the four input values. Unsigned\nnumbers can be compared with standard comparison operators (a < b).",
    "reference_implementation": "module RefModule (\n  input [7:0] a,\n  input [7:0] b,\n  input [7:0] c,\n  input [7:0] d,\n  output reg [7:0] min\n);\n\n  always_comb begin\n    min = a;\n    if (min > b) min = b;\n    if (min > c) min = c;\n    if (min > d) min = d;\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [7:0] a,\n  input [7:0] b,\n  input [7:0] c,\n  input [7:0] d,\n  output reg [7:0] min\n);\n  always_comb begin\n    if (a <= b && a <= c && a <= d) min = a;\n    else if (b <= c && b <= d) min = b;\n    else if (c <= d) min = c;\n    else min = d;\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [7:0] a,\n  input [7:0] b,\n  input [7:0] c,\n  input [7:0] d,\n  output reg [7:0] min\n);\n  always_comb begin\n    min = a;\n    if (min > b) min = b;\n    if (min > c) min = b;\n    if (min > d) min = d;\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 56,
    "problem_name": "ece241_2013_q7",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  j\n - input  k\n - output Q\n\nThe module should implement a JK flip-flop with the following truth\ntable. Note: Qold is the output of the flip-flop before the positive\nclock edge.\n\n  J | K | Q\n  0 | 0 | Qold\n  0 | 1 | 0\n  1 | 0 | 1\n  1 | 1 | ~Qold",
    "reference_implementation": "module RefModule (\n  input clk,\n  input j,\n  input k,\n  output reg Q\n);\n\n  always @(posedge clk)\n    Q <= j&~Q | ~k&Q;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input j,\n  input k,\n  output reg Q\n);\n  always @(posedge clk) begin\n    if (j == 0 && k == 0)\n      Q <= Q;\n    else if (j == 0 && k == 1)\n      Q <= 0;\n    else if (j == 1 && k == 0)\n      Q <= 1;\n    else\n      Q <= ~Q;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input j,\n  input k,\n  output reg Q\n);\n  always @(posedge clk)\n    Q <= j&~Q | ~k;\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 57,
    "problem_name": "kmap2",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  c\n - input  d\n - output out\n\nThe module should implement the circuit described by the Karnaugh map\nbelow.\n\n              ab\n   cd   00  01  11  10\n   00 | 1 | 1 | 0 | 1 |\n   01 | 1 | 0 | 0 | 1 |\n   11 | 0 | 1 | 1 | 1 |\n   10 | 1 | 1 | 0 | 0 |",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out\n);\n\n  assign out = (~c & ~b) | (~d&~a) | (a&c&d) | (b&c&d);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out\n);\n  assign out = (a & c & d) | (~b & ~c) | (b & c & d) | (~a & ~d);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out\n);\n  assign out = (~c & ~b) | (~d & ~a) | (a & c & d) | (b & c & ~d);\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 58,
    "problem_name": "alwaysblock2",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  a\n - input  b\n - output out_assign\n - output out_always_comb\n - output out_always_ff\n\nThe module should implement an XOR gate three ways, using an assign\nstatement (output out_assign), a combinational always block (output\nout_always_comb), and a clocked always block (output out_always_ff). Note\nthat the clocked always block produces a different circuit from the other\ntwo: There is a flip- flop so the output is delayed. Assume all\nsequential logic is triggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input a,\n  input b,\n  output out_assign,\n  output reg out_always_comb,\n  output reg out_always_ff\n);\n\n  assign out_assign = a ^ b;\n  always @(*) out_always_comb = a ^ b;\n  always @(posedge clk) out_always_ff <= a ^ b;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input a,\n  input b,\n  output out_assign,\n  output reg out_always_comb,\n  output reg out_always_ff\n);\n  assign out_assign = a ^ b;\n  always @(a or b) out_always_comb = a ^ b;\n  always @(posedge clk)\n    out_always_ff <= a ^ b;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input a,\n  input b,\n  output out_assign,\n  output reg out_always_comb,\n  output reg out_always_ff\n);\n  assign out_assign = a || b;\n  always @(*) out_always_comb = a ^ b;\n  always @(posedge clk) out_always_ff <= b ^ a;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 59,
    "problem_name": "wire4",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  c\n - output w\n - output x\n - output y\n - output z\n\nThe module should behave like wires that makes these connections:\n\n  a -> w\n  b -> x\n  b -> y\n  c -> z",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  output w,\n  output x,\n  output y,\n  output z\n);\n\n  assign {w,x,y,z} = {a,b,b,c};\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  output w,\n  output x,\n  output y,\n  output z\n);\n  assign w = a;\n  assign x = b;\n  assign y = b;\n  assign z = c;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  output w,\n  output x,\n  output y,\n  output z\n);\n  assign {w,x,y,z} = {a,b,c,b};\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 60,
    "problem_name": "m2014_q4k",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  resetn\n - input  in\n - output out\n\nThe module should implement a shift register with four D flops. Assume\nall sequential logic is triggered on the positive edge of the clock.\nReset is active-low synchronous resettable.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input resetn,\n  input in,\n  output out\n);\n\n  reg [3:0] sr;\n  always @(posedge clk) begin\n    if (~resetn)\n      sr <= '0;\n    else\n      sr <= {sr[2:0], in};\n  end\n\n  assign out = sr[3];\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input resetn,\n  input in,\n  output out\n);\n  reg [3:0] sr;\n  always @(posedge clk) begin\n    if (!resetn)\n      sr <= 4'b0;\n    else\n      sr <= {in, sr[3:1]};\n  end\n  assign out = sr[0];\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input resetn,\n  input in,\n  output out\n);\n  reg [2:0] sr;\n  always @(posedge clk) begin\n    if (~resetn)\n      sr <= '0;\n    else\n      sr <= {sr[1:0], in};\n  end\n  assign out = sr[2];\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 61,
    "problem_name": "2014_q4a",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  w\n - input  R\n - input  E\n - input  L\n - output Q\n\nThe module will be one stage in a larger n-bit shift register circuit.\nInput E is for enabling shift, R for value to load, L is asserted when it\nshould load, and w is the input from the prevous stage of the shift\nregister. Assume all sequential logic is triggered on the positive edge\nof the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input w,\n  input R,\n  input E,\n  input L,\n  output reg Q\n);\n\n  always @(posedge clk)\n    if (L)\n      Q <= R;\n    else if (E)\n      Q <= w;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input w,\n  input R,\n  input E,\n  input L,\n  output reg Q\n);\n  always @(posedge clk) begin\n    if (L)\n      Q <= R;\n    else\n      if (E) Q <= w;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input w,\n  input R,\n  input E,\n  input L,\n  output reg Q\n);\n  always @(posedge clk)\n    if (L)\n      Q <= R;\n    else if (E)\n      Q <= R;\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 62,
    "problem_name": "bugs_mux2",
    "original_prompt": "Consider the following implementation of an 8-bit 2-to-1 mux:\n\n  module TopModule (\n      input        sel,\n      input  [7:0] a,\n      input  [7:0] b,\n      output       out\n  );\n\n      assign out = (~sel & a) | (sel & b);\n\n  endmodule\n\nUnfortunately, this module has a bug. Implement a new version of this\nmodule that fixes the bug.",
    "reference_implementation": "module RefModule (\n  input sel,\n  input [7:0] a,\n  input [7:0] b,\n  output reg [7:0] out\n);\n\n  // assign out = (~sel & a) | (sel & b);\n  assign out = sel ? a : b;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] out\n);\n\n    assign out = sel ? a : b;\n\nendmodule",
    "buggy_implementation": "module TopModule (\n    input        sel,\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] out\n);\n    assign out = sel ? a[6:0] : b;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 63,
    "problem_name": "review2015_shiftcount",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  shift_ena\n - input  count_ena\n - input  data\n - output q (4 bits)\n\nThe module should implement a four-bit shift register that also acts as a\ndown counter. Data is shifted in most-significant-bit first when\nshift_ena is 1. The number currently in the shift register is decremented\nwhen count_ena is 1. Since the full system doesn't ever use shift_ena and\ncount_ena together, it does not matter what your circuit does if both\ncontrol inputs are 1 (this mainly means that it doesn't matter which case\ngets higher priority). Assume all sequential logic is triggered on the\npositive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input shift_ena,\n  input count_ena,\n  input data,\n  output reg [3:0] q\n);\n\n  always @(posedge clk) begin\n    if (shift_ena)\n      q <= { q[2:0], data };\n    else if (count_ena)\n      q <= q - 1'b1;\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input shift_ena,\n  input count_ena,\n  input data,\n  output reg [3:0] q\n);\n  always @(posedge clk) begin\n    if (count_ena)\n      q <= q - 1'b1;\n    else if (shift_ena)\n      q <= { q[2:0], data };\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input shift_ena,\n  input count_ena,\n  input data,\n  output reg [3:0] q\n);\n  always @(posedge clk) begin\n    if (shift_ena)\n      q <= { q[1:0], data };\n    else if (count_ena)\n      q <= q - 1'b1;\n  end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 64,
    "problem_name": "vector3",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a (5 bits)\n - input  b (5 bits)\n - input  c (5 bits)\n - input  d (5 bits)\n - input  e (5 bits)\n - input  f (5 bits)\n - output w (8 bits)\n - output x (8 bits)\n - output y (8 bits)\n - output z (8 bits)\n\nThe module should concatenate the input vectors together then split them\nup into several output vectors. There are six 5-bit input vectors: a, b,\nc, d, e, and f, for a total of 30 bits of input. There are four 8-bit\noutput vectors: w, x, y, and z, for 32 bits of output. The output should\nbe a concatenation of the input vectors followed by two 1 bits (the two 1\nbits should be in the LSB positions).",
    "reference_implementation": "module RefModule (\n  input [4:0] a,\n  input [4:0] b,\n  input [4:0] c,\n  input [4:0] d,\n  input [4:0] e,\n  input [4:0] f,\n  output [7:0] w,\n  output [7:0] x,\n  output [7:0] y,\n  output [7:0] z\n);\n\n  assign { w,x,y,z} = {a,b,c,d,e,f,2'b11};\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [4:0] a,\n  input [4:0] b,\n  input [4:0] c,\n  input [4:0] d,\n  input [4:0] e,\n  input [4:0] f,\n  output [7:0] w,\n  output [7:0] x,\n  output [7:0] y,\n  output [7:0] z\n);\n  wire [29:0] concat_inputs = {a,b,c,d,e,f};\n  assign {w,x,y,z} = {concat_inputs, 2'b11};\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [4:0] a,\n  input [4:0] b,\n  input [4:0] c,\n  input [4:0] d,\n  input [4:0] e,\n  input [4:0] f,\n  output [7:0] w,\n  output [7:0] x,\n  output [7:0] y,\n  output [7:0] z\n);\n  assign { w,x,y,z} = {a,b,c,d,f,e,2'b11};\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 65,
    "problem_name": "7420",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  p1a\n - input  p1b\n - input  p1c\n - input  p1d\n - input  p2a\n - input  p2b\n - input  p2c\n - input  p2d\n - output p1y\n - output p2y\n\nThe 7400-series integrated circuits are a series of digital chips with a\nfew gates each. The 7420 is a chip with two 4-input NAND gates. The\nmodule should implement the same functionality as the 7420 chip.",
    "reference_implementation": "module RefModule (\n  input p1a,\n  input p1b,\n  input p1c,\n  input p1d,\n  output p1y,\n  input p2a,\n  input p2b,\n  input p2c,\n  input p2d,\n  output p2y\n);\n\n  assign p1y = ~&( {p1a, p1b, p1c, p1d} );\n  assign p2y = ~&( {p2a, p2b, p2c, p2d} );\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input p1a,\n  input p1b,\n  input p1c,\n  input p1d,\n  output p1y,\n  input p2a,\n  input p2b,\n  input p2c,\n  input p2d,\n  output p2y\n);\n  wire [3:0] p1_inputs = {p1a, p1b, p1c, p1d};\n  wire [3:0] p2_inputs = {p2a, p2b, p2c, p2d};\n  assign p1y = ~(&p1_inputs);\n  assign p2y = ~(&p2_inputs);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input p1a,\n  input p1b,\n  input p1c,\n  input p1d,\n  output p1y,\n  input p2a,\n  input p2b,\n  input p2c,\n  input p2d,\n  output p2y\n);\n  assign p1y = ~|( {p1a, p1b, p1c} );\n  assign p2y = ~&( {p2a, p2b, p2c, p2d} );\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 66,
    "problem_name": "edgecapture",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  in    (32 bits)\n - output out   (32 bits)\n\nThe module should examine each bit in the 32-bit input vector, and\ncapture when the input signal changes from 1 in one clock cycle to 0 the\nnext. \"Capture\" means that the output will remain 1 until the register is\nreset (active high synchronous reset). Assume all sequential logic is\ntriggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input [31:0] in,\n  output reg [31:0] out\n);\n\n  reg [31:0] d_last;\n\n  always @(posedge clk) begin\n    d_last <= in;\n    if (reset)\n      out <= '0;\n    else\n      out <= out | (~in & d_last);\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  input [31:0] in,\n  output reg [31:0] out\n);\n\n  reg [31:0] d_last;\n\n  always @(posedge clk) begin\n    if (reset)\n      out <= 32'b0;\n    else\n      out <= out | (~in & d_last);\n    d_last <= in;\n  end\n\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input [31:0] in,\n  output reg [31:0] out\n);\n  reg [31:0] d_last;\n  always @(posedge clk) begin\n    d_last <= in;\n    if (reset)\n      out <= '0;\n    else\n      out <= out | (~in[31:28] & d_last[31:28]);\n  end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 67,
    "problem_name": "countslow",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  slowena\n - output q (4 bits)\n\nThe module should implement a decade counter that counts from 0 through\n9, inclusive, with a period of 10. The reset input is active high\nsynchronous, and should reset the counter to 0. We want to be able to\npause the counter rather than always incrementing every clock cycle, so\nthe \"slowena\" input if high indicates when the counter should increment.\nAssume all sequential logic is triggered on the positive edge of the\nclock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input slowena,\n  input reset,\n  output reg [3:0] q\n);\n\n  always @(posedge clk)\n    if (reset)\n      q <= 0;\n    else if (slowena) begin\n      if (q == 9)\n        q <= 0;\n      else\n        q <= q+1;\n    end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input slowena,\n  input reset,\n  output reg [3:0] q\n);\n  always @(posedge clk) begin\n    if (reset) begin\n      q <= 0;\n    end\n    else if (slowena && q != 9) begin\n      q <= q + 1;\n    end\n    else if (slowena) begin\n      q <= 0;\n    end\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input slowena,\n  input reset,\n  output reg [3:0] q\n);\n  always @(posedge clk)\n    if (reset)\n      q <= 0;\n    else if (slowena) begin\n      if (q == 10)\n        q <= 0;\n      else\n        q <= q+1;\n    end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 68,
    "problem_name": "countbcd",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output ena (3 bits)\n - output q   (16 bits)\n\nThe module should implement a 4-digit BCD (binary-coded decimal) counter.\nEach decimal digit is encoded using 4 bits: q[3:0] is the ones digit,\nq[7:4] is the tens digit, etc. For digits [3:1], also output an enable\nsignal indicating when each of the upper three digits should be\nincremented. Include a synchronous active-high reset. Assume all\nsequential logic is triggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  output [3:1] ena,\n  output reg [15:0] q\n);\n\n  wire [3:0] enable = { q[11:0]==12'h999, q[7:0]==8'h99, q[3:0] == 4'h9, 1'b1};\n  assign ena = enable[3:1];\n  always @(posedge clk)\n    for (int i=0;i<4;i++) begin\n      if (reset || (q[i*4 +:4] == 9 && enable[i]))\n        q[i*4 +:4] <= 0;\n      else if (enable[i])\n        q[i*4 +:4] <= q[i*4 +:4]+1;\n    end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  output [3:1] ena,\n  output reg [15:0] q\n);\n\n  wire [3:0] enable = { q[11:0] == 12'h999, q[7:0] == 8'h99, q[3:0] == 4'h9, 1'b1 };\n  assign ena = enable[3:1];\n\n  always @(posedge clk) begin\n    if (reset) begin\n      q <= 16'b0;\n    end else begin\n      if (enable[0]) begin\n        if (q[3:0] == 4'h9)\n          q[3:0] <= 4'b0;\n        else\n          q[3:0] <= q[3:0] + 1;\n      end\n\n      if (enable[1]) begin\n        if (q[7:4] == 4'h9)\n          q[7:4] <= 4'b0;\n        else\n          q[7:4] <= q[7:4] + 1;\n      end\n\n      if (enable[2]) begin\n        if (q[11:8] == 4'h9)\n          q[11:8] <= 4'b0;\n        else\n          q[11:8] <= q[11:8] + 1;\n      end\n\n      if (enable[3]) begin\n        if (q[15:12] == 4'h9)\n          q[15:12] <= 4'b0;\n        else\n          q[15:12] <= q[15:12] + 1;\n      end\n    end\n  end\n\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input reset,\n  output [3:1] ena,\n  output reg [15:0] q\n);\n  wire [3:0] enable = { q[11:0]==12'h999, q[7:0]==8'h99, q[3:0]==4'h9, 1'b1};\n  assign ena = enable[3:1];\n  always @(posedge clk)\n    for (int i=0;i<4;i++) begin\n      if (reset || (q[i*4 +:4] >= 9 && enable[i]))\n        q[i*4 +:4] <= 0;\n      else if (enable[i])\n        q[i*4 +:4] <= q[i*4 +:4]+1;\n    end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 69,
    "problem_name": "truthtable1",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  x3\n - input  x2\n - input  x1\n - output f\n\nThe module should implement a combinational circuit for the following\ntruth table:\n\n  x3 | x2 | x1 | f\n  0  | 0  | 0  | 0\n  0  | 0  | 1  | 0\n  0  | 1  | 0  | 1\n  0  | 1  | 1  | 1\n  1  | 0  | 0  | 0\n  1  | 0  | 1  | 1\n  1  | 1  | 0  | 0\n  1  | 1  | 1  | 1",
    "reference_implementation": "module RefModule (\n  input x3,\n  input x2,\n  input x1,\n  output f\n);\n\n  assign f = ( ~x3 & x2 & ~x1 ) |\n        ( ~x3 & x2 & x1 ) |\n        ( x3 & ~x2 & x1 ) |\n        ( x3 & x2 & x1 ) ;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    assign f = (x3 ? (x2 ? x1 : x1) : x2) ;\nendmodule",
    "buggy_implementation": "module TopModule (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    assign f = ( ~x3 & x2 & ~x1 ) |\n          ( ~x3 & x2 & x1 ) |\n          ( x3 & ~x2 & x1 ) |\n          ( x3 & x2 & ~x1 ) ;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 70,
    "problem_name": "ece241_2013_q2",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n  - input  a\n  - input  b\n  - input  c\n  - input  d\n  - output out_sop\n  - output out_pos\n\nThe module should implement a digital system with four inputs (a,b,c,d)\nthat generates a logic-1 when 2, 7, or 15 appears on the inputs, and a\nlogic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input\nconditions for the numbers 3, 8, 11, and 12 never occur in this system.\nFor example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.\nDetermine the output out_sop in minimum sum-of-products form, and the\noutput out_pos in minimum product-of-sums form.",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out_sop,\n  output out_pos\n);\n\n  wire pos0, pos1;\n  assign out_sop = c&d | ~a&~b&c;\n  assign pos0 = c & (~b|d)&(~a|b);\n  assign pos1 = c & (~b|d)&(~a|d);\n\n  assign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out_sop,\n  output out_pos\n);\n  wire pos0, pos1;\n  assign out_sop = c&d | c&~b&~a;\n  assign pos0 = c & (~b|d) & (b|~a);\n  assign pos1 = c & (~b|d) & (~a|d);\n  assign out_pos = pos0 & pos1;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out_sop,\n  output out_pos\n);\n  wire pos0, pos1;\n  assign out_sop = c&d | ~a&~b&c;\n  assign pos0 = c & (~b|d) & (~a|b);\n  assign pos1 = c & (~b) & (~a|d);\n  assign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 71,
    "problem_name": "always_casez",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in  (8 bits)\n - output pos (3 bits)\n\nThe module should implement a priority encoder for an 8-bit input. Given\nan 8-bit vector, the output should report the first (least significant)\nbit in the vector that is 1. Report zero if the input vector has no bits\nthat are high. For example, the input 8'b10010000 should output 3'd4,\nbecause bit[4] is first bit that is high.",
    "reference_implementation": "module RefModule (\n  input [7:0] in,\n  output reg [2:0] pos\n);\n\n  always @(*) begin\n    casez (in)\n      default : pos = 2'h0;\n      8'bzzzzzzz1: pos = 3'h0;\n      8'bzzzzzz1z: pos = 3'h1;\n      8'bzzzzz1zz: pos = 3'h2;\n      8'bzzzz1zzz: pos = 3'h3;\n      8'bzzz1zzzz: pos = 3'h4;\n      8'bzz1zzzzz: pos = 3'h5;\n      8'bz1zzzzzz: pos = 3'h6;\n      8'b1zzzzzzz: pos = 3'h7;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [7:0] in,\n  output reg [2:0] pos\n);\n\n  always @(*) begin\n    casez (in)\n      8'bzzzzzzz1: pos = 3'h0;\n      8'bzzzzzz10: pos = 3'h1;\n      8'bzzzzz100: pos = 3'h2;\n      8'bzzzz1000: pos = 3'h3;\n      8'bzzz10000: pos = 3'h4;\n      8'bzz100000: pos = 3'h5;\n      8'bz1000000: pos = 3'h6;\n      8'b10000000: pos = 3'h7;\n      default: pos = 3'h0;\n    endcase\n  end\n\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [7:0] in,\n  output reg [2:0] pos\n);\n  always @(*) begin\n    casez (in)\n      8'bzzzzzz1z: pos = 3'h0;\n      8'bzzzzz1zz: pos = 3'h1;\n      8'bzzzz1zzz: pos = 3'h2;\n      8'bzzz1zzzz: pos = 3'h3;\n      8'bzz1zzzzz: pos = 3'h4;\n      8'bz1zzzzzz: pos = 3'h5;\n      8'b1zzzzzzz: pos = 3'h6;\n      default : pos = 3'h7;\n    endcase\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 72,
    "problem_name": "thermostat",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  mode\n - input  too_cold\n - input  too_hot\n - input  fan_on\n - output heater\n - output aircon\n - output fan\n\nThe module should implement a heating/cooling thermostat controller which\ncontrols both a heater (during winter) and an air conditioner (during\nsummer). The module should on and off the heater, air conditioning, and\nblower fan as appropriate. The thermostat can be in one of two modes:\nheating (mode = 1) and cooling (mode = 0). In heating mode, turn the\nheater on when it is too cold (too_cold = 1) but do not use the air\nconditioner. In cooling mode, turn the air conditioner on when it is too\nhot (too_hot = 1), but do not turn on the heater. When the heater or air\nconditioner are on, also turn on the fan to circulate the air. In\naddition, the user can also request the fan to turn on (fan_on = 1), even\nif the heater and air conditioner are off.",
    "reference_implementation": "module RefModule (\n  input mode,\n  input too_cold,\n  input too_hot,\n  input fan_on,\n  output heater,\n  output aircon,\n  output fan\n);\n\n  assign fan = (mode ? too_cold : too_hot) | fan_on;\n  assign heater = (mode & too_cold);\n  assign aircon = (~mode & too_hot);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input mode,\n  input too_cold,\n  input too_hot,\n  input fan_on,\n  output heater,\n  output aircon,\n  output fan\n);\n  assign heater = too_cold & mode;\n  assign aircon = too_hot & ~mode;\n  assign fan = fan_on | aircon | heater;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input mode,\n  input too_cold,\n  input too_hot,\n  input fan_on,\n  output heater,\n  output aircon,\n  output fan\n);\n  assign fan = (mode ? too_cold : too_hot) & fan_on;\n  assign heater = (mode & too_cold);\n  assign aircon = (~mode & too_hot);\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 73,
    "problem_name": "dff16e",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  resetn\n - input  byteena ( 2 bits)\n - input  d       (16 bits)\n - output q       (16 bits)\n\nThe module should include 16 D flip-flops. It's sometimes useful to only\nmodify parts of a group of flip-flops. The byte-enable inputs control\nwhether each byte of the 16 registers should be written to on that cycle.\nbyteena[1] controls the upper byte d[15:8], while byteena[0] controls the\nlower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs\nshould be triggered by the positive edge of clk.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input resetn,\n  input [1:0] byteena,\n  input [15:0] d,\n  output reg [15:0] q\n);\n\n  always @(posedge clk) begin\n    if (!resetn)\n      q <= 0;\n    else begin\n      if (byteena[0])\n        q[7:0] <= d[7:0];\n      if (byteena[1])\n        q[15:8] <= d[15:8];\n    end\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input resetn,\n  input [1:0] byteena,\n  input [15:0] d,\n  output reg [15:0] q\n);\n  always @(posedge clk) begin\n    if (!resetn) begin\n      q <= 16'b0;\n    end else begin\n      q <= q;\n      if (byteena[0])\n        q[7:0] <= d[7:0];\n      if (byteena[1])\n        q[15:8] <= d[15:8];\n    end\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input resetn,\n  input [1:0] byteena,\n  input [15:0] d,\n  output reg [15:0] q\n);\n  always @(posedge clk) begin\n    if (!resetn)\n      q <= 0;\n    else begin\n      if (byteena[0])\n        q[7:0] <= d[15:8];\n      if (byteena[1])\n        q[15:8] <= d[7:0];\n    end\n  end\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 74,
    "problem_name": "ece241_2014_q4",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  x\n - output z\n\nThe module should implement a finite state machine with the following\nbehavior. Input x goes to three different two-input gates: an XOR, an\nAND, and a OR gate. Each of the three gates is connected to the input of\na D flip-flop and then the flip-flop outputs all go to a three-input\nNOR gate, whose output is Z. The second input of the XOR is its corresponding\nflip-flop's output, the second input of the AND is its corresponding\nflip-flop's complemented output, and finally the second input of the OR\nis its corresponding flip-flop's complementary output.\n\nAssume that the D flip-flops are initially reset to zero before the\nmachine begins. Assume all sequential logic is triggered on the positive\nedge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input x,\n  output z\n);\n\n  reg [2:0] s = 0;\n\n  always @(posedge clk) begin\n    s <= { s[2] ^ x, ~s[1] & x, ~s[0] | x };\n  end\n\n  assign z = ~|s;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input x,\n  output z\n);\n  reg [2:0] s = 0;\n  always @(posedge clk) begin\n    s[2] <= s[2] ^ x;\n    s[1] <= ~s[1] & x;\n    s[0] <= ~s[0] | x;\n  end\n  assign z = ~(s[0] | s[1] | s[2]);\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input x,\n  output z\n);\n  reg [2:0] s = 0;\n  always @(posedge clk) begin\n    s <= { s[2] ^ x, ~s[1] | x, ~s[0] & x };\n  end\n  assign z = ~|s;\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 75,
    "problem_name": "counter_2bc",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  train_valid\n - input  train_taken\n - output state (2 bits)\n\nThe module should implement a two-bit saturating counter. The counter\nincrements (up to a maximum of 3) when train_valid = 1 and\ntrain_taken = 1. It decrements (down to a minimum of 0) when\ntrain_valid = 1 and train_taken = 0. When not training (train_valid = 0),\nthe counter keeps its value unchanged. areset is a positive edge\ntriggered asynchronous reset that resets the counter to weakly not-taken\n(2'b01). Output state[1:0] is the two-bit counter value. Assume all\nsequential logic is triggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input train_valid,\n  input train_taken,\n  output logic [1:0] state\n);\n\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= 1;\n    else if (train_valid) begin\n      if(state < 3 && train_taken)\n        state <= state + 1;\n      else if(state > 0 && !train_taken)\n        state <= state - 1;\n    end\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input areset,\n  input train_valid,\n  input train_taken,\n  output reg [1:0] state\n);\n\n  always @(posedge clk or posedge areset) begin\n    if (areset)\n      state <= 2'b01;\n    else if (train_valid) begin\n      if (train_taken && state < 2'b11)\n        state <= state + 1;\n      else if (!train_taken && state > 2'b00)\n        state <= state - 1;\n    end\n  end\n\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input areset,\n  input train_valid,\n  input train_taken,\n  output logic [1:0] state\n);\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= 1;\n    else if (train_valid) begin\n      if (train_taken)\n        state <= state + 1;\n      else if (state > 0)\n        state <= state - 1;\n    end\n  end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 76,
    "problem_name": "always_case",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  sel   (3 bits)\n - input  data0 (4 bits)\n - input  data1 (4 bits)\n - input  data2 (4 bits)\n - input  data3 (4 bits)\n - input  data4 (4 bits)\n - input  data5 (4 bits)\n - output out   (4 bits)\n);\n\nThe module should implement a 6-to-1 multiplexer. When sel is between 0\nand 5, choose the corresponding data input. Otherwise, output 0. The data\ninputs and outputs are all 4 bits wide.",
    "reference_implementation": "module RefModule (\n  input [2:0] sel,\n  input [3:0] data0,\n  input [3:0] data1,\n  input [3:0] data2,\n  input [3:0] data3,\n  input [3:0] data4,\n  input [3:0] data5,\n  output reg [3:0] out\n);\n\n  always @(*) begin\n    case (sel)\n      3'h0: out = data0;\n      3'h1: out = data1;\n      3'h2: out = data2;\n      3'h3: out = data3;\n      3'h4: out = data4;\n      3'h5: out = data5;\n      default: out = 4'b0;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [2:0] sel,\n  input [3:0] data0,\n  input [3:0] data1,\n  input [3:0] data2,\n  input [3:0] data3,\n  input [3:0] data4,\n  input [3:0] data5,\n  output reg [3:0] out\n);\n  always @(sel or data0 or data1 or data2 or data3 or data4 or data5) begin\n    case (sel)\n      3'd0: out = data0;\n      3'd1: out = data1;\n      3'd2: out = data2;\n      3'd3: out = data3;\n      3'd4: out = data4;\n      3'd5: out = data5;\n      default: out = 4'b0000;\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [2:0] sel,\n  input [3:0] data0,\n  input [3:0] data1,\n  input [3:0] data2,\n  input [3:0] data3,\n  input [3:0] data4,\n  input [3:0] data5,\n  output reg [3:0] out\n);\n  always @(*) begin\n    case (sel)\n      3'h0: out = data0;\n      3'h1: out = data1;\n      3'h3: out = data3;\n      3'h4: out = data4;\n      3'h5: out = data5;\n      default: out = 4'b0;\n    endcase\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 77,
    "problem_name": "wire_decl",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  c\n - input  d\n - output out\n - output out_n\n\nThe module should implement the following circuit. Create two\nintermediate wires (named anything you want) to connect the AND and OR\ngates together. Note that the wire that feeds the NOT gate is really wire\n`out`, so you do not necessarily need to declare a third wire here.\nNotice how wires are driven by exactly one source (output of a gate), but\ncan feed multiple inputs.\n\nThe circuit is composed of two layers. The first layer, counting from the\ninput, is two AND gates: one whose input is connected to a and b, and the\nsecond is connected to c and d. The second layer there is an OR gate to\nOR the two AND outputs, connected the output 'out'. Additionally, there\nis an inverted output 'out_n'.",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out,\n  output out_n\n);\n\n  wire w1, w2;\n  assign w1 = a&b;\n  assign w2 = c&d;\n  assign out = w1|w2;\n  assign out_n = ~out;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out,\n  output out_n\n);\n  wire w1, w2;\n  assign out = w1|w2;\n  assign w1 = a&b;\n  assign w2 = c&d;\n  assign out_n = ~out;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out,\n  output out_n\n);\n  wire w1, w2;\n  assign w1 = a|b;\n  assign w2 = c&d;\n  assign out = w1|w2;\n  assign out_n = ~out;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 78,
    "problem_name": "dualedge",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  d\n - output q\n\nA dual-edge triggered flip-flop is triggered on both edges of the clock.\nHowever, FPGAs don't have dual-edge triggered flip-flops, and using an\nalways @(posedge clk or negedge clk) is not accepted as a legal\nsensitivity list. Build a circuit that functionally behaves like a\ndual-edge triggered flip-flop.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input d,\n  output reg q\n);\n\n  /*always @(posedge clk, negedge clk) begin\n    q <= d;\n  end*/\n\n  reg qp, qn;\n  always @(posedge clk)\n    qp <= d;\n  always @(negedge clk)\n    qn <= d;\n\n  // This causes q to change too early when clk changes. Need delay by\n  // delta cycle\n  // assign q = clk ? qp : qn;\n  always @(*)\n    q <= clk ? qp : qn;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input d,\n  output reg q\n);\n  reg qp, qn;\n  always @(posedge clk)\n    qp = d;\n  always @(negedge clk)\n    qn = d;\n  always @(*)\n    q = clk ? qp : qn;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input d,\n  output reg q\n);\n  reg qp, qn;\n  always @(posedge clk)\n    qp <= d;\n  always @(negedge clk)\n    qn <= d;\n  always @(*)\n    q <= clk ? qn : qp;\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 79,
    "problem_name": "fsm3onehot",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in\n - input  state (4 bits)\n - output next_state (4 bits)\n - output out\n\nThe module should implement the state transition table for a Moore state\nmachine with one input, one output, and four states. Use the following\none-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.\nDerive state transition and output logic equations by inspection assuming\na one-hot encoding. Implement only the state transition logic and output\nlogic (the combinational logic portion) for this state machine.\n\n  State | Next state in=0, Next state in=1 | Output\n  A     | A, B                             | 0\n  B     | C, B                             | 0\n  C     | A, D                             | 0\n  D     | C, B                             | 1",
    "reference_implementation": "module RefModule (\n  input in,\n  input [3:0] state,\n  output reg [3:0] next_state,\n  output out\n);\n\n  parameter A=0, B=1, C=2, D=3;\n\n  assign next_state[A] = (state[A] | state[C]) & ~in;\n  assign next_state[B] = (state[A] | state[B] | state[D]) & in;\n  assign next_state[C] = (state[B] | state[D]) & ~in;\n  assign next_state[D] = state[C] & in;\n\n  assign out = (state[D]);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input in,\n  input [3:0] state,\n  output reg [3:0] next_state,\n  output out\n);\n  parameter A=0, B=1, C=2, D=3;\n  always @(*) begin\n    next_state[A] = (~in & (state[A] | state[C]));\n    next_state[B] = (in & (state[A] | state[B] | state[D]));\n    next_state[C] = (~in & (state[B] | state[D]));\n    next_state[D] = (in & state[C]);\n  end\n  assign out = state[D];\nendmodule",
    "buggy_implementation": "module TopModule (\n  input in,\n  input [3:0] state,\n  output reg [3:0] next_state,\n  output out\n);\n  parameter A=0, B=1, C=2, D=3;\n  assign next_state[A] = (state[A] | state[B]) & ~in;\n  assign next_state[B] = (state[A] | state[B] | state[D]) & in;\n  assign next_state[C] = (state[B] | state[D]) & ~in;\n  assign next_state[D] = state[C] & in;\n  assign out = (state[D]);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 80,
    "problem_name": "timer",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk,\n - input  load,\n - input  data (10 bits)\n - output tc\n\nThe module should implement a timer that counts down for a given number\nof clock cycles, then asserts a signal to indicate that the given\nduration has elapsed. A good way to implement this is with a down-counter\nthat asserts an output signal when the count becomes 0. At each clock\ncycle:\n\n  (1) If load = 1, load the internal counter with the 10-bit data, the\n  number of clock cycles the timer should count before timing out. The\n  counter can be loaded at any time, including when it is still counting\n  and has not yet reached 0.\n\n  (2) If load = 0, the internal counter should decrement by 1. The output\n  signal tc (\"terminal count\") indicates whether the internal counter has\n  reached 0. Once the internal counter has reached 0, it should stay 0\n  (stop counting) until the counter is loaded again.\n\nThe module should implement a single D flip-flop. Assume all sequential\nlogic is triggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input load,\n  input [9:0] data,\n  output tc\n);\n\n  logic [9:0] count_value;\n\n  always @(posedge clk)\n    if(load) count_value <= data;\n    else if(count_value != 0) count_value <= count_value - 1;\n\n  assign tc = count_value == 0;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input load,\n  input [9:0] data,\n  output tc\n);\n  reg [9:0] count_value;\n  always @(posedge clk) begin\n    if (load)\n        count_value <= data;\n    else\n        if (|count_value) count_value <= count_value - 1'b1;\n  end\n  assign tc = ~|count_value;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input load,\n  input [9:0] data,\n  output tc\n);\n  logic [9:0] count_value;\n  always @(posedge clk)\n    if(load) count_value <= data;\n    else if(count_value != 1) count_value <= count_value - 1;\n  assign tc = count_value == 0;\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 81,
    "problem_name": "7458",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  p1a\n - input  p1b\n - input  p1c\n - input  p1d\n - input  p1e\n - input  p1f\n - input  p2a\n - input  p2b\n - input  p2c\n - input  p2d\n - output p1y\n - output p2y\n\nThe 7458 is a chip with four AND gates and two OR gates. Implement a\nmodule with the same functionality as the 7458 chip. It has 10 inputs and\n2 outputs. You may choose to use an `assign` statement to drive each of\nthe output wires, or you may choose to declare (four) wires for use as\nintermediate signals, where each internal wire is driven by the output of\none of the AND gates.\n\nIn this circuit, p1y should be the OR of two 3-input AND gates: one that\nANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The\noutput p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b,\nand the second that ANDs p2c and p2d.",
    "reference_implementation": "module RefModule (\n  input p1a,\n  input p1b,\n  input p1c,\n  input p1d,\n  input p1e,\n  input p1f,\n  output p1y,\n  input p2a,\n  input p2b,\n  input p2c,\n  input p2d,\n  output p2y\n);\n\n  assign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n  assign p2y = &{p2a, p2b} | &{p2c, p2d};\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input p1a,\n  input p1b,\n  input p1c,\n  input p1d,\n  input p1e,\n  input p1f,\n  output p1y,\n  input p2a,\n  input p2b,\n  input p2c,\n  input p2d,\n  output p2y\n);\n  wire and1 = p1a & p1b & p1c;\n  wire and2 = p1d & p1e & p1f;\n  wire and3 = p2a & p2b;\n  wire and4 = p2c & p2d;\n  assign p1y = and1 | and2;\n  assign p2y = and3 | and4;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input p1a,\n  input p1b,\n  input p1c,\n  input p1d,\n  input p1e,\n  input p1f,\n  output p1y,\n  input p2a,\n  input p2b,\n  input p2c,\n  input p2d,\n  output p2y\n);\n  assign p1y = &{p1a, p1b} | &{p1d, p1e, p1f};\n  assign p2y = &{p2a, p2b} | &{p2c, p2d};\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 82,
    "problem_name": "lfsr32",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output q (32 bits)\n\nA linear feedback shift register is a shift register usually with a few\nXOR gates to produce the next state of the shift register. A Galois LFSR\nis one particular arrangement that shifts right, where a bit position with\na \"tap\" is XORed with the LSB output bit (q[0]) to produce its next value,\nwhile bit positions without a tap shift right unchanged. \n\nThe module should implement a 32-bit Galois LFSR with taps at bit\npositions 32, 22, 2, and 1. Reset should be active high synchronous, and\nshould reset the output q to 32'h1. Assume all sequential logic is\ntriggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  output reg [31:0] q\n);\n\n  logic [31:0] q_next;\n  always@(q) begin\n    q_next = q[31:1];\n    q_next[31] = q[0];\n    q_next[21] ^= q[0];\n    q_next[1] ^= q[0];\n    q_next[0] ^= q[0];\n  end\n\n  always @(posedge clk) begin\n    if (reset)\n      q <= 32'h1;\n    else\n      q <= q_next;\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  output reg [31:0] q\n);\n\n  reg [31:0] q_next;\n  \n  always @(*) begin\n    q_next = q >> 1;\n    q_next[31] = q[0];\n    q_next[21] = q[22] ^ q[0];\n    q_next[1] = q[2] ^ q[0];\n    q_next[0] = q[1] ^ q[0];\n  end\n\n  always @(posedge clk) begin\n    if (reset)\n      q <= 32'h1;\n    else\n      q <= q_next;\n  end\n\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input reset,\n  output reg [31:0] q\n);\n  logic [31:0] q_next;\n  always @(q) begin\n    q_next = q[31:1];\n    q_next[31] = q[0];\n    q_next[21] ^= q[0];\n    q_next[1] ^= q[0];\n  end\n  always @(posedge clk) begin\n    if (reset)\n      q <= 32'h1;\n    else\n      q <= q_next;\n  end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 83,
    "problem_name": "mt2015_q4b",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  x\n - input  y\n - output z\n\nThe module can be described by the following simulation waveform:\n\n  time  x  y  z\n  0ns   0  0  1\n  5ns   0  0  1\n  10ns  0  0  1\n  15ns  0  0  1\n  20ns  0  0  1\n  25ns  1  0  0\n  30ns  1  0  0\n  35ns  0  1  0\n  40ns  0  1  0\n  45ns  1  1  1\n  50ns  1  1  1\n  55ns  0  0  1\n  60ns  0  1  0\n  65ns  0  1  0\n  70ns  1  1  1\n  75ns  0  1  0\n  80ns  0  1  0\n  85ns  0  1  0\n  90ns  1  0  0",
    "reference_implementation": "module RefModule (\n  input x,\n  input y,\n  output z\n);\n\n  assign z = ~(x^y);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input x,\n  input y,\n  output z\n);\n  assign z = ~(x | y) | (x & y);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input x,\n  input y,\n  output z\n);\n  assign z = ~x ^ y;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 84,
    "problem_name": "ece241_2013_q12",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  enable\n - input  S\n - input  A\n - input  B\n - input  C\n - output Z\n\nThe module should implement a circuit for an 8x1 memory, where writing to\nthe memory is accomplished by shifting-in bits, and reading is \"random\naccess\", as in a typical RAM. You will then use the circuit to realize a\n3-input logic function. First, create an 8-bit shift register with 8\nD-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The\nshift register input should be called S, which feeds the input of Q[0]\n(MSB is shifted in first). The enable input is synchronous active high\nand controls whether to shift. Extend the circuit to have 3 additional\ninputs A,B,C and an output Z. The circuit's behaviour should be as\nfollows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on.\nYour circuit should contain ONLY the 8-bit shift register, and\nmultiplexers. Assume all sequential logic is triggered on the positive\nedge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input enable,\n  input S,\n  input A,\n  input B,\n  input C,\n  output reg Z\n);\n\n  reg [7:0] q;\n  always @(posedge clk) begin\n    if (enable)\n      q <= {q[6:0], S};\n  end\n\n  assign Z = q[ {A, B, C} ];\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input enable,\n  input S,\n  input A,\n  input B,\n  input C,\n  output reg Z\n);\n\n  reg [7:0] q;\n  always @(posedge clk) begin\n    if (enable)\n      q <= {q[6:0], S};\n  end\n\n  always @(*) begin\n    case ({A, B, C})\n      3'b000: Z = q[0];\n      3'b001: Z = q[1];\n      3'b010: Z = q[2];\n      3'b011: Z = q[3];\n      3'b100: Z = q[4];\n      3'b101: Z = q[5];\n      3'b110: Z = q[6];\n      3'b111: Z = q[7];\n      default: Z = 1'b0; // Default case to handle any unexpected conditions\n    endcase\n  end\n\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input enable,\n  input S,\n  input A,\n  input B,\n  input C,\n  output reg Z\n);\n  reg [7:0] q;\n  always @(posedge clk) begin\n    if (enable)\n      q <= {q[6:0], S};\n  end\n  assign Z = q[ {C, B, A} ];\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 85,
    "problem_name": "shift4",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  load\n - input  ena\n - input  data (4 bits)\n - output q (4 bits)\n\nThe module should implement a 4-bit shift register (right shift), with\nasynchronous positive edge triggered areset, synchronous active high\nsignals load, and enable.\n\n  (1) areset: Resets shift register to zero.\n\n  (2) load: Loads shift register with data[3:0] instead of shifting.\n\n  (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and\n       disappears).\n\n  (4) q: The contents of the shift register. If both the load and ena\n       inputs are asserted (1), the load input has higher priority.\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input load,\n  input ena,\n  input [3:0] data,\n  output reg [3:0] q\n);\n\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      q <= 0;\n    else if (load)\n      q <= data;\n    else if (ena)\n      q <= q[3:1];\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input areset,\n  input load,\n  input ena,\n  input [3:0] data,\n  output reg [3:0] q\n);\n  always @(posedge clk or posedge areset) begin\n    if (areset) begin\n      q <= 4'b0;\n    end else begin\n      if (load)\n        q <= data;\n      else if (ena)\n        q <= {1'b0, q[3:1]};\n    end\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input areset,\n  input load,\n  input ena,\n  input [3:0] data,\n  output reg [3:0] q\n);\n  always @(posedge clk or posedge areset) begin\n    if (areset)\n      q <= 0;\n    else if (ena)\n      q <= q[3:1];\n    else if (load)\n      q <= data;\n  end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 86,
    "problem_name": "lfsr5",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output q (5 bits)\n\nA linear feedback shift register is a shift register usually with a few\nXOR gates to produce the next state of the shift register. A Galois LFSR\nis one particular arrangement that shifts right, where a bit position with\na \"tap\" is XORed with the LSB output bit (q[0]) to produce its next value,\nwhile bit positions without a tap shift right unchanged.  If the taps positions\nare carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length\nLFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is\nnever reached).\n\nThe module should implement a 5-bit maximal-length Galois LFSR with taps\nat bit positions 5 and 3. The active-high synchronous reset should reset\nthe LFSR output to 1. Assume all sequential logic is triggered on the\npositive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  output reg [4:0] q\n);\n\n  logic [4:0] q_next;\n  always @(q) begin\n    q_next = q[4:1];\n    q_next[4] = q[0];\n    q_next[2] ^= q[0];\n  end\n\n  always @(posedge clk) begin\n    if (reset)\n      q <= 5'h1;\n    else\n      q <= q_next;\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  output reg [4:0] q\n);\n\n  always @(posedge clk) begin\n    if (reset)\n      q <= 5'h1;\n    else begin\n      q <= {q[0], q[4:1]};\n      q[2] <= q[3] ^ q[0];\n    end\n  end\n\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input reset,\n  output reg [4:0] q\n);\n  logic [4:0] q_next;\n  always @(q) begin\n    q_next = q[4:1];\n    q_next[4] = q[0];\n    q_next[2] = q[0];\n  end\n  always @(posedge clk) begin\n    if (reset)\n      q <= 5'h1;\n    else\n      q <= q_next;\n  end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 87,
    "problem_name": "gates",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - output out_and\n - output out_or\n - output out_xor\n - output out_nand\n - output out_nor\n - output out_xnor\n - output out_anotb\n\nThe module should implement a combinational circuit with two inputs, a\nand b. There are 7 outputs, each with a logic gate driving it:\n\n  (1) out_and: a and b\n  (2) out_or: a or b\n  (3) out_xor: a xor b\n  (4) out_nand: a nand b\n  (5) out_nor: a nor b\n  (6) out_xnor: a xnor b\n  (7) out_anotb: a and-not b",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  output out_and,\n  output out_or,\n  output out_xor,\n  output out_nand,\n  output out_nor,\n  output out_xnor,\n  output out_anotb\n);\n\n  assign out_and = a&b;\n  assign out_or = a|b;\n  assign out_xor = a^b;\n  assign out_nand = ~(a&b);\n  assign out_nor = ~(a|b);\n  assign out_xnor = a^~b;\n  assign out_anotb = a & ~b;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input a,\n  input b,\n  output out_and,\n  output out_or,\n  output out_xor,\n  output out_nand,\n  output out_nor,\n  output out_xnor,\n  output out_anotb\n);\n  assign out_and = b & a;\n  assign out_or = b | a;\n  assign out_xor = b ^ a;\n  assign out_nand = ~(b & a);\n  assign out_nor = ~(b | a);\n  assign out_xnor = b^~a;\n  assign out_anotb = ~b & a;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input a,\n  input b,\n  output out_and,\n  output out_or,\n  output out_xor,\n  output out_nand,\n  output out_nor,\n  output out_xnor,\n  output out_anotb\n);\n  assign out_and = a&b;\n  assign out_or = a|b;\n  assign out_xor = a^b;\n  assign out_nand = ~(a&b);\n  assign out_nor = ~(a|b);\n  assign out_xnor = a^b;\n  assign out_anotb = a & b;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 88,
    "problem_name": "ece241_2014_q5b",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  x\n - output z\n\nThe module should implement the following Mealy finite-state machine\nwhich is an implementation of the 2's complementer. Implement using a\none-hot encoding. Resets into state A and reset is asynchronous\nactive-high.\n\n  A --x=0 (z=0)--> A\n  A --x=1 (z=1)--> B\n  B --x=0 (z=1)--> B\n  B --x=1 (z=0)--> B\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input x,\n  output z\n);\n\n  parameter A=0,B=1;\n  reg state;\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= A;\n    else begin\n      case (state)\n        A: state <= x ? B : A;\n        B: state <= B;\n      endcase\n    end\n  end\n\n  assign z = (state == A && x==1) | (state == B && x==0);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input x,\n  output z\n);\n  parameter A=0,B=1;\n  reg state;\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= A;\n    else\n      case (state)\n        A: if (x) state <= B; else state <= A;\n        B: state <= B;\n      endcase\n  end\n  assign z = (state == B) ? ~x : x;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input x,\n  output z\n);\n  parameter A=0,B=1;\n  reg state;\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= A;\n    else begin\n      case (state)\n        A: state <= x ? B : A;\n        B: state <= B;\n      endcase\n    end\n  end\n  assign z = (state == A && x==1) | (state == B);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 89,
    "problem_name": "ece241_2014_q5a",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  x\n - output z\n\nThe module should implement a one-input one-output serial 2's\ncomplementer Moore state machine. The input (x) is a series of bits (one\nper clock cycle) beginning with the least-significant bit of the number,\nand the output (Z) is the 2's complement of the input. The machine will\naccept input numbers of arbitrary length. The circuit requires a positive\nedge triggered asynchronous reset. The conversion begins when Reset is\nreleased and stops when Reset is asserted. Assume all sequential logic is\ntriggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input x,\n  output z\n);\n\n  parameter A=0,B=1,C=2;\n  reg [1:0] state;\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= A;\n    else begin\n      case (state)\n        A: state <= x ? C : A;\n        B: state <= x ? B : C;\n        C: state <= x ? B : C;\n      endcase\n    end\n  end\n\n  assign z = (state == C);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input x,\n  output z\n);\n  parameter A=0,B=1,C=2;\n  reg [1:0] state;\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= A;\n    else\n      case (state)\n        A: state <= x ? C : A;\n        B: state <= x ? B : C;\n        C: state <= (x == 1'b1) ? B : C;\n      endcase\n  end\n  assign z = (state == C);\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input x,\n  output z\n);\n  parameter A=0,B=1,C=2;\n  reg [1:0] state;\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= A;\n    else\n      case (state)\n        A: state <= x ? C : A;\n        B: state <= x ? B : C;\n        C: state <= x ? B : A;\n      endcase\n  end\n  assign z = (state == C);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 90,
    "problem_name": "circuit1",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - output q\n\nThe module should implement a combinational circuit. Read the simulation\nwaveforms to determine what the circuit does, then implement it.\n\n  time  a  b  q\n  0ns   0  0  0\n  5ns   0  0  0\n  10ns  0  0  0\n  15ns  0  0  0\n  20ns  0  0  0\n  25ns  0  1  0\n  30ns  0  1  0\n  35ns  1  0  0\n  40ns  1  0  0\n  45ns  1  1  1\n  50ns  1  1  1\n  55ns  0  0  0\n  60ns  0  0  0\n  65ns  0  1  0\n  70ns  0  1  0\n  75ns  1  0  0\n  80ns  1  0  0\n  85ns  1  1  1\n  90ns  1  1  1",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  output q\n);\n\n  assign q = a&b;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  output q\n);\n  assign q = b&a;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  output q\n);\n  assign q = a|b;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 91,
    "problem_name": "2012_q2b",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  y (6 bits)\n - input  w\n - output Y1\n - output Y3\n\nConsider the following finite-state machine:\n\n  A (0) --1--> B\n  A (0) --0--> A\n  B (0) --1--> C\n  B (0) --0--> D\n  C (0) --1--> E\n  C (0) --0--> D\n  D (0) --1--> F\n  D (0) --0--> A\n  E (1) --1--> E\n  E (1) --0--> D\n  F (1) --1--> C\n  F (1) --0--> D\n\nAssume that a one-hot code is used with the state assignment y[5:0] =\n000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\nThe module should implement the state output logic for this finite-state\nmachine. The output signal Y1 should be the input of state flip-flop\ny[1]. The output signal Y3 should be the input of state flip-flop y[3].\nDerive the implementation by inspection assuming the above one-hot\nencoding.",
    "reference_implementation": "module RefModule (\n  input [5:0] y,\n  input w,\n  output Y1,\n  output Y3\n);\n\n  assign Y1 = y[0]&w;\n  assign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [5:0] y,\n  input w,\n  output Y1,\n  output Y3\n);\n  assign Y1 = w & y[0];\n  assign Y3 = ~w & (y[1] | y[2] | y[4] | y[5]);\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [5:0] y,\n  input w,\n  output Y1,\n  output Y3\n);\n  assign Y1 = y[0] & w;\n  assign Y3 = (y[1] | y[2] | y[5]) & ~w;\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 92,
    "problem_name": "gatesv100",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in            (100 bits)\n - output out_both      (100 bits)\n - output out_any       (100 bits)\n - output out_different (100 bits)\n\nThe module takes as input a 100-bit input vector in[99:0] and should\nproduce the following three outputs:\n\n  (1) out_both: Each bit of this output vector should indicate whether\n  both the corresponding input bit and its neighbour to the left are '1'.\n  For example, out_both[98] should indicate if in[98] and in[99] are both\n  1. Since in[99] has no neighbour to the left, the answer is obvious so\n  simply set out_both[99] to be zero.\n\n  (2) out_any: Each bit of this output vector should indicate whether any\n  of the corresponding input bit and its neighbour to the right are '1'.\n  For example, out_any[2] should indicate if either in[2] or in[1] are 1.\n  Since in[0] has no neighbour to the right, the answer is obvious so\n  simply set out_any[0] to be zero.\n\n  (3) out_different: Each bit of this output vector should indicate\n  whether the corresponding input bit is different from its neighbour to\n  the left. For example, out_different[98] should indicate if in[98] is\n  different from in[99]. For this part, treat the vector as wrapping\n  around, so in[99]'s neighbour to the left is in[0].",
    "reference_implementation": "module RefModule (\n  input  [99:0] in,\n  output [99:0] out_both,\n  output [99:0] out_any,\n  output [99:0] out_different\n);\n\n  assign out_both = { 1'b0, (in[98:0] & in[99:1]) };\n\n  assign out_any = { (in[98:0] | in[99:1]), 1'b0 };\n\n  assign out_different = in ^ { in[0], in[99:1] };\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input  [99:0] in,\n  output [99:0] out_both,\n  output [99:0] out_any,\n  output [99:0] out_different\n);\n\n  assign out_both = { 1'b0, (in[99:1] & in[98:0]) };\n\n  assign out_any = { (in[99:1] | in[98:0]), 1'b0 };\n\n  assign out_different = in ^ { in[0], in[99:1] };\n\nendmodule",
    "buggy_implementation": "module TopModule (\n  input  [99:0] in,\n  output [99:0] out_both,\n  output [99:0] out_any,\n  output [99:0] out_different\n);\n  assign out_both = { 1'b0, (in[97:0] & in[98:1]) };\n  assign out_any = { (in[98:0] | in[99:1]), 1'b0 };\n  assign out_different = in ^ { in[1], in[99:1] };\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 93,
    "problem_name": "ece241_2014_q3",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  c\n - input  d\n - output mux_in (4 bits)\n\nFor the following Karnaugh map, give the circuit implementation using one\n4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using\nas few as possible. You are not allowed to use any other logic gate and\nyou must use _a_ and _b_ as the multiplexer selector inputs, as shown on\nthe 4-to-1 multiplexer below.\n\n      ab\n  cd  00  01  11  10\n  00 | 0 | 0 | 0 | 1 |\n  01 | 1 | 0 | 0 | 0 |\n  11 | 1 | 0 | 1 | 1 |\n  10 | 1 | 0 | 0 | 1 |\n\nConsider a block diagram with inputs 'c' and 'd' going into a module\ncalled \"TopModule\". This \"TopModule\" has four outputs, mux_in[3:0], that\nconnect to a four input mux. The mux takes as input {a,b} and ab = 00 is\nconnected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You\nare implementing in Verilog just the portion labelled \"TopModule\", such\nthat the entire circuit (including the 4-to-1 mux) implements the K-map.",
    "reference_implementation": "module RefModule (\n  input c,\n  input d,\n  output [3:0] mux_in\n);\n\n  assign mux_in[0] = c | d;\n  assign mux_in[1] = 0;\n  assign mux_in[2] = ~d;\n  assign mux_in[3] = c&d;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input c,\n  input d,\n  output [3:0] mux_in\n);\n  assign mux_in[0] = c || d;\n  assign mux_in[1] = 1'b0;\n  assign mux_in[2] = !d;\n  assign mux_in[3] = c & d;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input c,\n  input d,\n  output [3:0] mux_in\n);\n  assign mux_in[0] = c | d;\n  assign mux_in[1] = 0;\n  assign mux_in[2] = ~c;\n  assign mux_in[3] = c&d;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 94,
    "problem_name": "gatesv",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in            (4 bits)\n - output out_both      (4 bits)\n - output out_any       (4 bits)\n - output out_different (4 bits)\n\nYou are given a four-bit input vector. We want to know some relationships\nbetween each bit and its neighbour:\n\n  (1) out_both: Each bit of this output vector should indicate whether\n  both the corresponding input bit and its neighbour to the left (higher\n  index) are '1'. For example, out_both[2] should indicate if in[2] and\n  in[3] are both 1. Since in[3] has no neighbour to the left, the answer\n  is obvious so we don't need to know out_both[3].\n\n  (2) out_any: Each bit of this output vector should indicate whether any\n  of the corresponding input bit and its neighbour to the right are '1'.\n  For example, out_any[2] should indicate if either in[2] or in[1] are 1.\n  Since in[0] has no neighbour to the right, the answer is obvious so we\n  don't need to know out_any[0].\n\n  (3) out_different: Each bit of this output vector should indicate\n  whether the corresponding input bit is different from its neighbour to\n  the left. For example, out_different[2] should indicate if in[2] is\n  different from in[3]. For this part, treat the vector as wrapping\n  around, so in[3]'s neighbour to the left is in[0].",
    "reference_implementation": "module RefModule (\n  input  [3:0] in,\n  output [3:0] out_both,\n  output [3:0] out_any,\n  output [3:0] out_different\n);\n\n  assign out_both[2:0] = in[2:0] & in[3:1];\n  assign out_any[3:1]  = in[2:0] | in[3:1];\n  assign out_different = in^{in[0], in[3:1]};\n\n  // we don't care about out_both[3] or out_any[0]\n  assign out_both[3] = 1'bx;\n  assign out_any[0]  = 1'bx;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input  [3:0] in,\n  output [3:0] out_both,\n  output [3:0] out_any,\n  output [3:0] out_different\n);\n  assign out_both[2:0] = in[3:1] & in[2:0];\n  assign out_any[3:1]  = in[3:1] | in[2:0];\n  assign out_different = in ^ {in[0], in[3:1]};\n  assign out_both[3] = 1'bx;\n  assign out_any[0]  = 1'bx;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input  [3:0] in,\n  output [3:0] out_both,\n  output [3:0] out_any,\n  output [3:0] out_different\n);\n  assign out_both[2:0] = in[2:0] & in[3:1];\n  assign out_any[3:1]  = in[2:0] | in[3:0];\n  assign out_different = in^{in[0], in[3:1]};\n  assign out_both[3] = 1'bx;\n  assign out_any[0]  = 1'bx;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 95,
    "problem_name": "review2015_fsmshift",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - output shift_ena\n\nThis module is a part of the FSM for controlling a shift register, we\nwant the ability to enable the shift register for exactly 4 clock cycles\nwhenever the proper bit pattern is detected. Whenever the FSM is reset,\nassert shift_ena for 4 cycles, then 0 forever (until reset). Reset should\nbe active high synchronous.\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  output shift_ena\n);\n\n  parameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\n  reg [2:0] state, next;\n\n  always_comb begin\n    case (state)\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = Done;\n      Done: next = Done;\n    endcase\n  end\n\n  always @(posedge clk)\n    if (reset) state <= B0;\n    else state <= next;\n\n  assign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input reset,\n  output shift_ena\n);\n  parameter B0=0, B1=1, B2=2, B3=3, Done=4;\n  reg [2:0] state, next;\n  always_comb begin\n    case (state)\n      B0:   next = B1;\n      B1:   next = B2;\n      B2:   next = B3;\n      B3:   next = Done;\n      default: next = Done;\n    endcase\n  end\n  always @(posedge clk)\n    if (reset) state <= B0;\n    else state <= next;\n  assign shift_ena = (state != Done);\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input reset,\n  output shift_ena\n);\n  parameter B0=0, B1=1, B2=2, B3=3, Done=4;\n  reg [2:0] state, next;\n  always_comb begin\n    case (state)\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = Done;\n      Done: next = Done;\n    endcase\n  end\n  always @(posedge clk)\n    if (reset) state <= B0;\n    else state <= next;\n  assign shift_ena = (state == B0 || state == B1 || state == B2);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 96,
    "problem_name": "review2015_fsmseq",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  data\n - output start_shifting\n\nThe module should implement a finite-state machine that searches for the\nsequence 1101 in an input bit stream. When the sequence is found, it\nshould set start_shifting to 1, forever, until reset. Reset is active\nhigh synchronous. Assume all sequential logic is triggered on the\npositive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input data,\n  output start_shifting\n);\n\n  parameter S=0, S1=1, S11=2, S110=3, Done=4;\n\n  reg [2:0] state, next;\n\n  always_comb begin\n    case (state)\n      S: next = data ? S1: S;\n      S1: next = data ? S11: S;\n      S11: next = data ? S11 : S110;\n      S110: next = data ? Done : S;\n      Done: next = Done;\n    endcase\n  end\n\n  always @(posedge clk)\n    if (reset) state <= S;\n    else state <= next;\n\n  assign start_shifting = state == Done;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  input data,\n  output start_shifting\n);\n  parameter S=0, S1=1, S11=2, S110=3, Done=4;\n  reg [2:0] state;\n  reg [2:0] next_state;\n  always @(*) begin\n    case (state)\n      S: next_state = data ? S1 : S;\n      S1: next_state = data ? S11 : S;\n      S11: next_state = data ? S11 : S110;\n      S110: next_state = data ? Done : S;\n      Done: next_state = Done;\n    endcase\n  end\n  always @(posedge clk)\n    if (reset) state <= S;\n    else state <= next_state;\n  assign start_shifting = (state == Done);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input reset,\n  input data,\n  output start_shifting\n);\n  parameter S=0, S1=1, S11=2, S110=3, Done=4;\n  reg [2:0] state, next;\n  always_comb begin\n    case (state)\n      S: next = data ? S1: S;\n      S1: next = data ? S11: S;\n      S11: next = data ? S11 : S110;\n      S110: next = data ? Done : S110;\n      Done: next = Done;\n    endcase\n  end\n  always @(posedge clk)\n    if (reset) state <= S;\n    else state <= next;\n  assign start_shifting = state == Done;\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 97,
    "problem_name": "mux9to1v",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a   (16 bits)\n - input  b   (16 bits)\n - input  c   (16 bits)\n - input  d   (16 bits)\n - input  e   (16 bits)\n - input  f   (16 bits)\n - input  g   (16 bits)\n - input  h   (16 bits)\n - input  i   (16 bits)\n - input  sel ( 4 bits)\n - output out (16 bits)\n\nThe module should implement a 16-bit wide, 9-to-1 multiplexer. sel=0\nchooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set\nall output bits to '1'.",
    "reference_implementation": "module RefModule (\n  input [15:0] a,\n  input [15:0] b,\n  input [15:0] c,\n  input [15:0] d,\n  input [15:0] e,\n  input [15:0] f,\n  input [15:0] g,\n  input [15:0] h,\n  input [15:0] i,\n  input [3:0] sel,\n  output logic [15:0] out\n);\n\n  always @(*) begin\n    out = '1;\n    case (sel)\n      4'h0: out = a;\n      4'h1: out = b;\n      4'h2: out = c;\n      4'h3: out = d;\n      4'h4: out = e;\n      4'h5: out = f;\n      4'h6: out = g;\n      4'h7: out = h;\n      4'h8: out = i;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [15:0] a,\n  input [15:0] b,\n  input [15:0] c,\n  input [15:0] d,\n  input [15:0] e,\n  input [15:0] f,\n  input [15:0] g,\n  input [15:0] h,\n  input [15:0] i,\n  input [3:0] sel,\n  output reg [15:0] out\n);\n  always @(*) begin\n    case (sel)\n      4'h0: out = a;\n      4'h1: out = b;\n      4'h2: out = c;\n      4'h3: out = d;\n      4'h4: out = e;\n      4'h5: out = f;\n      4'h6: out = g;\n      4'h7: out = h;\n      4'h8: out = i;\n      default: out = '1;\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [15:0] a,\n  input [15:0] b,\n  input [15:0] c,\n  input [15:0] d,\n  input [15:0] e,\n  input [15:0] f,\n  input [15:0] g,\n  input [15:0] h,\n  input [15:0] i,\n  input [3:0] sel,\n  output logic [15:0] out\n);\n  always @(*) begin\n    out = '0;\n    case (sel)\n      4'h0: out = a;\n      4'h1: out = b;\n      4'h2: out = c;\n      4'h3: out = d;\n      4'h4: out = e;\n      4'h5: out = f;\n      4'h6: out = g;\n      4'h7: out = h;\n      4'h8: out = i;\n    endcase\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 98,
    "problem_name": "circuit7",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  a\n - output q\n\nThis is a sequential circuit. Read the simulation waveforms to determine\nwhat the circuit does, then implement it.\n\n  time  clk a   q\n  0ns   0   x   x\n  5ns   1   0   x\n  10ns  0   0   x\n  15ns  1   0   1\n  20ns  0   0   1\n  25ns  1   0   1\n  30ns  0   0   1\n  35ns  1   1   1\n  40ns  0   1   1\n  45ns  1   1   0\n  50ns  0   1   0\n  55ns  1   1   0\n  60ns  0   1   0\n  65ns  1   1   0\n  70ns  0   1   0\n  75ns  1   1   0\n  80ns  0   1   0\n  85ns  1   1   0\n  90ns  0   1   0\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input a,\n  output reg q\n);\n\n  always @(posedge clk)\n    q <= ~a;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input a,\n  output reg q\n);\n  always @(posedge clk) begin\n    q = ~a;\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input a,\n  output reg q\n);\n  always @(posedge clk)\n    q <= ~q;\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 100,
    "problem_name": "fsm3comb",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in\n - input  state (2 bits)\n - output next_state (2 bits)\n - output out\n\nThe module should implement the following is the state transition table\nfor a Moore state machine with one input, one output, and four states.\nUse the following state encoding: A=2'b00, B=2'b01, C=2'b10,\nD=2'b11.Implement only the state transition logic and output logic (the\ncombinational logic portion) for this state machine. Given the current\nstate (state), compute the next_state and output (out) based on the state\ntransition table.\n\n  State | Next state in=0, Next state in=1 | Output\n  A     | A, B                             | 0\n  B     | C, B                             | 0\n  C     | A, D                             | 0\n  D     | C, B                             | 1",
    "reference_implementation": "module RefModule (\n  input in,\n  input [1:0] state,\n  output reg [1:0] next_state,\n  output out\n);\n\n  parameter A=0, B=1, C=2, D=3;\n\n  always_comb begin\n    case (state)\n      A: next_state = in ? B : A;\n      B: next_state = in ? B : C;\n      C: next_state = in ? D : A;\n      D: next_state = in ? B : C;\n    endcase\n  end\n\n  assign out = (state==D);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input in,\n  input [1:0] state,\n  output reg [1:0] next_state,\n  output out\n);\n  parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;\n  always_comb begin\n    case (state)\n      A: next_state = in ? B : A;\n      B: if (in) next_state = B; else next_state = C;\n      C: next_state = in ? D : A;\n      D: next_state = in ? B : C;\n    endcase\n  end\n  assign out = (state == D);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input in,\n  input [1:0] state,\n  output reg [1:0] next_state,\n  output out\n);\n  parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;\n  always_comb begin\n    case (state)\n      A: next_state = in ? B : A;\n      B: next_state = in ? B : A;\n      C: next_state = in ? D : A;\n      D: next_state = in ? B : C;\n    endcase\n  end\n  assign out = (state == D);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 101,
    "problem_name": "circuit4",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  c\n - input  d\n - output q\n\nThe module should implement a combinational circuit. Read the simulation\nwaveforms to determine what the circuit does, then implement it.\n\n  time  a  b  c  d  q\n  0ns   0  0  0  0  0\n  5ns   0  0  0  0  0\n  10ns  0  0  0  0  0\n  15ns  0  0  0  0  0\n  20ns  0  0  0  1  0\n  25ns  0  0  1  0  1\n  30ns  0  0  1  1  1\n  35ns  0  1  0  0  1\n  40ns  0  1  0  1  1\n  45ns  0  1  1  0  1\n  50ns  0  1  1  1  1\n  55ns  1  0  0  0  0\n  60ns  1  0  0  1  0\n  65ns  1  0  1  0  1\n  70ns  1  0  1  1  1\n  75ns  1  1  0  0  1\n  80ns  1  1  0  1  1\n  85ns  1  1  1  0  1\n  90ns  1  1  1  1  1",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n\n  assign q = c | b;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n  assign q = b | c;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n  assign q = b & c;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 102,
    "problem_name": "circuit3",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  c\n - input  d\n - output q\n\nThe module should implement a combinational circuit. Read the simulation\nwaveforms to determine what the circuit does, then implement it.\n\n  time  a  b  c  d  q\n  0ns   0  0  0  0  0\n  5ns   0  0  0  0  0\n  10ns  0  0  0  0  0\n  15ns  0  0  0  0  0\n  20ns  0  0  0  1  0\n  25ns  0  0  1  0  0\n  30ns  0  0  1  1  0\n  35ns  0  1  0  0  0\n  40ns  0  1  0  1  1\n  45ns  0  1  1  0  1\n  50ns  0  1  1  1  1\n  55ns  1  0  0  0  0\n  60ns  1  0  0  1  1\n  65ns  1  0  1  0  1\n  70ns  1  0  1  1  1\n  75ns  1  1  0  0  0\n  80ns  1  1  0  1  1\n  85ns  1  1  1  0  1\n  90ns  1  1  1  1  1",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n\n  assign q = (a|b) & (c|d);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n  wire w1 = a | b;\n  wire w2 = c | d;\n  assign q = w1 & w2;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n  assign q = (a|b) & d;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 103,
    "problem_name": "circuit2",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  c\n - input  d\n - output q\n\nThe module should implement a combinational circuit. Read the simulation\nwaveforms to determine what the circuit does, then implement it.\n\n  time  a  b  c  d  q\n  0ns   0  0  0  0  1\n  5ns   0  0  0  0  1\n  10ns  0  0  0  0  1\n  15ns  0  0  0  0  1\n  20ns  0  0  0  1  0\n  25ns  0  0  1  0  0\n  30ns  0  0  1  1  1\n  35ns  0  1  0  0  0\n  40ns  0  1  0  1  1\n  45ns  0  1  1  0  1\n  50ns  0  1  1  1  0\n  55ns  1  0  0  0  0\n  60ns  1  0  0  1  1\n  65ns  1  0  1  0  1\n  70ns  1  0  1  1  0\n  75ns  1  1  0  0  1\n  80ns  1  1  0  1  0\n  85ns  1  1  1  0  0\n  90ns  1  1  1  1  1",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n\n  assign q = ~a^b^c^d;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n  wire temp1 = a ^ b;\n  wire temp2 = c ^ d;\n  assign q = ~(temp1 ^ temp2);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n  assign q = a^b^c^~d;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 105,
    "problem_name": "rotate100",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  load\n - input  ena  (  2 bits)\n - input  data (100 bits)\n - output q    (100 bits)\n\nThe module should implement a 100-bit left/right rotator, with\nsynchronous load and left/right enable. A rotator shifts-in the\nshifted-out bit from the other end of the register, unlike a shifter that\ndiscards the shifted-out bit and shifts in a zero. If enabled, a rotator\nrotates the bits around and does not modify/discard them.\n\n  (1) load: Loads shift register with data[99:0] instead of rotating.\n      Synchronous active high.\n\n  (2) ena[1:0]: Synchronous. Chooses whether and which direction to\n      rotate:\n      (a) 2'b01 rotates right by one bit,\n      (b) 2'b10 rotates left by one bit,\n      (c) 2'b00 and 2'b11 do not rotate.\n\n  (3) q: The contents of the rotator.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input load,\n  input [1:0] ena,\n  input [99:0] data,\n  output reg [99:0] q\n);\n\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else if (ena == 2'h1)\n      q <= {q[0], q[99:1]};\n    else if (ena == 2'h2)\n      q <= {q[98:0], q[99]};\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input load,\n  input [1:0] ena,\n  input [99:0] data,\n  output reg [99:0] q\n);\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else case (ena)\n      2'b01: q <= {q[0], q[99:1]};\n      2'b10: q <= {q[98:0], q[99]};\n      default: q <= q;\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input load,\n  input [1:0] ena,\n  input [99:0] data,\n  output reg [99:0] q\n);\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else if (ena == 2'b1)\n      q <= {q[0], q[99:1]};\n    else if (ena == 2'b10)\n      q <= {q[97:0], q[99:98]};\n  end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 106,
    "problem_name": "always_nolatches",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  scancode (16 bits)\n - output left\n - output down\n - output right\n - output up\n\nThe module should process scancodes from a PS/2 keyboard for a game.\nGiven the last two bytes of scancodes received, you need to indicate\nwhether one of the arrow keys on the keyboard have been pressed. This\ninvolves a fairly simple mapping, which can be implemented as a case\nstatement (or if-elseif) with four cases.\n\n  Scancode[15:0] | Arrow key\n  16'he06b       | left arrow\n  16'he072       | down arrow\n  16'he074       | right arrow\n  16'he075       | up arrow\n  Anything else  | none\n\nYour circuit has one 16-bit input, and four outputs. Build this circuit\nthat recognizes these four scancodes and asserts the correct output.",
    "reference_implementation": "module RefModule (\n  input [15:0] scancode,\n  output reg left,\n  output reg down,\n  output reg right,\n  output reg up\n);\n\n  always @(*) begin\n    {up, left, down, right} = 0;\n    case (scancode)\n      16'he06b: left = 1;\n      16'he072: down = 1;\n      16'he074: right = 1;\n      16'he075: up = 1;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [15:0] scancode,\n  output reg left,\n  output reg down,\n  output reg right,\n  output reg up\n);\n  always @(*) begin\n    left = (scancode == 16'he06b);\n    down = (scancode == 16'he072);\n    right = (scancode == 16'he074);\n    up = (scancode == 16'he075);\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [15:0] scancode,\n  output reg left,\n  output reg down,\n  output reg right,\n  output reg up\n);\n  always @(*) begin\n    {up, left, down, right} = 0;\n    case (scancode)\n      16'he06b: left = 1;\n      16'he072: down = 1;\n      16'he074: right = 1;\n    endcase\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 107,
    "problem_name": "fsm1s",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  in\n - output out\n\nImplement the following Moore state machine with two states, one input,\nand one output. The reset state is B and reset is active-high\nsynchronous.\n\n  B (out=1) --in=0--> A\n  B (out=1) --in=1--> B\n  A (out=0) --in=0--> B\n  A (out=0) --in=1--> A",
    "reference_implementation": "module RefModule (\n  input clk,\n  input in,\n  input reset,\n  output out\n);\n\n  parameter A=0, B=1;\n  reg state;\n  reg next;\n\n    always_comb begin\n    case (state)\n      A: next = in ? A : B;\n      B: next = in ? B : A;\n    endcase\n    end\n\n    always @(posedge clk) begin\n    if (reset) state <= B;\n        else state <= next;\n  end\n\n  assign out = (state==B);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input in,\n  input reset,\n  output out\n);\n  parameter A=0, B=1;\n  reg state;\n  always @(posedge clk) begin\n    if (reset) state <= B;\n    else begin\n      case (state)\n        A: state <= in ? A : B;\n        B: state <= in ? B : A;\n      endcase\n    end\n  end\n  assign out = (state == B);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input in,\n  input reset,\n  output out\n);\n  parameter A=0, B=1;\n  reg state;\n  reg next;\n  always_comb begin\n    case (state)\n      A: next = in ? A : B;\n      B: next = in ? B : A;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= A;\n    else state <= next;\n  end\n  assign out = (state==B);\nendmodule",
    "difficulty": "easy",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 108,
    "problem_name": "rule90",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk,\n - input  load,\n - input  data (512 bits)\n - output q    (512 bits)\n\nThe module should implement Rule 90, a one-dimensional cellular automaton\nwith interesting properties. The rules are simple. There is a\none-dimensional array of cells (on or off). At each time step, the next\nstate of each cell is the XOR of the cell's two current neighbours:\n\n  Left | Center | Right | Center's next state\n  1    | 1      | 1     | 0\n  1    | 1      | 0     | 1\n  1    | 0      | 1     | 0\n  1    | 0      | 0     | 1\n  0    | 1      | 1     | 1\n  0    | 1      | 0     | 0\n  0    | 0      | 1     | 1\n  0    | 0      | 0     | 0\n\nIn this circuit, create a 512-cell system (q[511:0]), and advance by one\ntime step each clock cycle. The load input indicates the state of the\nsystem should be loaded with data[511:0]. Assume the boundaries (q[-1]\nand q[512]) are both zero (off). Assume all sequential logic is triggered\non the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input load,\n  input [511:0] data,\n  output reg [511:0] q\n);\n\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else begin\n      q <= q[$bits(q)-1:1] ^ {q[$bits(q)-2:0], 1'b0} ;\n    end\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input load,\n  input [511:0] data,\n  output reg [511:0] q\n);\n  always @(posedge clk) begin\n    if (load) begin\n      q <= data;\n    end else begin\n      q <= (q >> 1) ^ (q << 1);\n    end\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input load,\n  input [511:0] data,\n  output reg [511:0] q\n);\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else begin\n      q <= q[511:1] ^ {q[510:0], 1'b1};\n    end\n  end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 109,
    "problem_name": "fsm1",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  in\n - output out\n\nThe module should implement a Moore machine with the diagram described\nbelow:\n\n  B (1) --0--> A\n  B (1) --1--> B\n  A (0) --0--> B\n  A (0) --1--> A\n\nIt should asynchronously reset into state B if reset if high.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input in,\n  input areset,\n  output out\n);\n\n  parameter A=0, B=1;\n  reg state;\n  reg next;\n\n    always_comb begin\n    case (state)\n      A: next = in ? A : B;\n      B: next = in ? B : A;\n    endcase\n    end\n\n    always @(posedge clk, posedge areset) begin\n    if (areset) state <= B;\n        else state <= next;\n  end\n\n  assign out = (state==B);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input in,\n  input areset,\n  output out\n);\n  parameter A=0, B=1;\n  reg state;\n  reg next_state;\n  always_comb begin\n    case (state)\n      A: next_state = in ? A : B;\n      B: next_state = in ? B : A;\n    endcase\n  end\n  always @(posedge clk, posedge areset)\n    if (areset) state <= B;\n    else state <= next_state;\n  assign out = (state == B);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input in,\n  input areset,\n  output out\n);\n  parameter A=0, B=1;\n  reg state;\n  reg next;\n  always_comb begin\n    case (state)\n      A: next = in ? B : A;\n      B: next = in ? B : A;\n    endcase\n  end\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= B;\n    else state <= next;\n  end\n  assign out = (state==B);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 110,
    "problem_name": "fsm2",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  j\n - input  k\n - output out\n\nThe module should implement a Moore state machine with two states, two\ninputs, and one output according to diagram described below. Reset is an\nactive-high asynchronous reset to state OFF.\n\n  OFF (out=0) --j=0--> OFF\n  OFF (out=0) --j=1--> ON\n  ON  (out=1) --k=0--> ON\n  ON  (out=1) --k=1--> OFF",
    "reference_implementation": "module RefModule (\n  input clk,\n  input j,\n  input k,\n  input areset,\n  output out\n);\n\n  parameter A=0, B=1;\n  reg state;\n  reg next;\n\n    always_comb begin\n    case (state)\n      A: next = j ? B : A;\n      B: next = k ? A : B;\n    endcase\n    end\n\n    always @(posedge clk, posedge areset) begin\n    if (areset) state <= A;\n        else state <= next;\n  end\n\n  assign out = (state==B);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input j,\n  input k,\n  input areset,\n  output out\n);\n  parameter A=0, B=1;\n  reg state;\n  reg next_state;\n  always @(*) begin\n    case (state)\n      A: next_state = j ? B : A;\n      B: next_state = k ? A : B;\n    endcase\n  end\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= A;\n    else\n      state <= next_state;\n  end\n  assign out = state == B;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input j,\n  input k,\n  input areset,\n  output out\n);\n  parameter A=0, B=1;\n  reg state;\n  reg next;\n  always_comb begin\n    case (state)\n      A: next = j ? A : B;\n      B: next = k ? A : B;\n    endcase\n  end\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= A;\n    else state <= next;\n  end\n  assign out = (state==B);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 111,
    "problem_name": "fsm2s",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  j\n - input  k\n - output out\n\nThe module should implement a Moore state machine with two states, two\ninputs, and one output according to diagram described below. Reset is an\nactive-high synchronous reset to state OFF.\n\n  OFF (out=0) --j=0--> OFF\n  OFF (out=0) --j=1--> ON\n  ON  (out=1) --k=0--> ON\n  ON  (out=1) --k=1--> OFF",
    "reference_implementation": "module RefModule (\n  input clk,\n  input j,\n  input k,\n  input reset,\n  output out\n);\n\n  parameter A=0, B=1;\n  reg state;\n  reg next;\n\n    always_comb begin\n    case (state)\n      A: next = j ? B : A;\n      B: next = k ? A : B;\n    endcase\n    end\n\n    always @(posedge clk) begin\n    if (reset) state <= A;\n        else state <= next;\n  end\n\n  assign out = (state==B);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input j,\n  input k,\n  input reset,\n  output out\n);\n  parameter A=0, B=1;\n  reg state, next;\n  always @(posedge clk) begin\n    if (reset) state <= A;\n    else state <= next;\n  end\n  always_comb begin\n    case (state)\n      A: next = (j) ? B : A;\n      B: next = (k) ? A : B;\n    endcase\n  end\n  assign out = state == B;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input j,\n  input k,\n  input reset,\n  output out\n);\n  parameter A=0, B=1;\n  reg state;\n  reg next;\n  always_comb begin\n    case (state)\n      A: next = j ? B : A;\n      B: next = k ? A : B;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (!reset) state <= next;\n  end\n  assign out = (state==B);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 112,
    "problem_name": "always_case2",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in  (4 bits)\n - output pos (2 bits)\n\nThe module should implement a priority encoder. A priority encoder is a\ncombinational circuit that, when given an input bit vector, outputs the\nposition of the first 1 bit in the vector. For example, a 8-bit priority\nencoder given the input 8'b10010000 would output 3'd4, because bit[4] is\nfirst bit that is high. Build a 4-bit priority encoder. For this problem,\nif none of the input bits are high (i.e., input is zero), output zero.\nNote that a 4-bit number has 16 possible combinations.",
    "reference_implementation": "module RefModule (\n  input [3:0] in,\n  output reg [1:0] pos\n);\n\n  always @(*) begin\n    case (in)\n      4'h0: pos = 2'h0;\n      4'h1: pos = 2'h0;\n      4'h2: pos = 2'h1;\n      4'h3: pos = 2'h0;\n      4'h4: pos = 2'h2;\n      4'h5: pos = 2'h0;\n      4'h6: pos = 2'h1;\n      4'h7: pos = 2'h0;\n      4'h8: pos = 2'h3;\n      4'h9: pos = 2'h0;\n      4'ha: pos = 2'h1;\n      4'hb: pos = 2'h0;\n      4'hc: pos = 2'h2;\n      4'hd: pos = 2'h0;\n      4'he: pos = 2'h1;\n      4'hf: pos = 2'h0;\n      default: pos = 2'b0;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [3:0] in,\n  output reg [1:0] pos\n);\n  always @(*) begin\n    casez (in)\n      4'b0000: pos = 2'b00;\n      4'b???1: pos = 2'b00;\n      4'b??10: pos = 2'b01;\n      4'b?100: pos = 2'b10;\n      4'b1000: pos = 2'b11;\n      default: pos = 2'b00;\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [3:0] in,\n  output reg [1:0] pos\n);\n  always @(*) begin\n    case (in)\n      4'h0: pos = 2'h0;\n      4'h1: pos = 2'h0;\n      4'h2: pos = 2'h1;\n      4'h3: pos = 2'h0;\n      4'h4: pos = 2'h2;\n      4'h8: pos = 2'h3;\n      4'h9: pos = 2'h0;\n      4'ha: pos = 2'h1;\n      4'hb: pos = 2'h0;\n      4'hc: pos = 2'h2;\n      4'hd: pos = 2'h0;\n      4'he: pos = 2'h1;\n      4'hf: pos = 2'h0;\n      default: pos = 2'b0;\n    endcase\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 113,
    "problem_name": "2012_q1g",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  x (4 bits)\n - output f\n\nThe module should implement the function f shown in the Karnaugh map\nbelow.\n\n             x[0]x[1]\nx[2]x[3]  00  01  11  10\n  00     | 1 | 0 | 0 | 1 |\n  01     | 0 | 0 | 0 | 0 |\n  11     | 1 | 1 | 1 | 0 |\n  10     | 1 | 1 | 0 | 1 |",
    "reference_implementation": "module RefModule (\n  input [3:0] x,\n  output logic f\n);\n\n  always_comb begin\n    case (x)\n      4'h0: f = 1;\n      4'h1: f = 1;\n      4'h2: f = 0;\n      4'h3: f = 0;\n      4'h4: f = 1;\n      4'h5: f = 1;\n      4'h6: f = 1;\n      4'h7: f = 0;\n      4'h8: f = 0;\n      4'h9: f = 0;\n      4'ha: f = 0;\n      4'hb: f = 0;\n      4'hc: f = 1;\n      4'hd: f = 0;\n      4'he: f = 1;\n      4'hf: f = 1;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [3:0] x,\n  output logic f\n);\n  always_comb begin\n    f = 0;\n    case (x)\n      4'h0: f = 1;\n      4'h1: f = 1;\n      4'h2: f = 0;\n      4'h3: f = 0;\n      4'h4: f = 1;\n      4'h5: f = 1;\n      4'h6: f = 1;\n      4'h7: f = 0;\n      4'h8: f = 0;\n      4'h9: f = 0;\n      4'ha: f = 0;\n      4'hb: f = 0;\n      4'hc: f = 1;\n      4'hd: f = 0;\n      4'he: f = 1;\n      4'hf: f = 1;\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [3:0] x,\n  output logic f\n);\n  always_comb begin\n    case (x)\n      4'h0: f = 1;\n      4'h1: f = 1;\n      4'h2: f = 0;\n      4'h3: f = 0;\n      4'h4: f = 1;\n      4'h5: f = 1;\n      4'h6: f = 1;\n      4'h7: f = 0;\n      4'h8: f = 0;\n      4'h9: f = 0;\n      4'ha: f = 0;\n      4'hb: f = 0;\n      4'hc: f = 1;\n      4'hd: f = 1;\n      4'he: f = 1;\n      4'hf: f = 1;\n    endcase\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 114,
    "problem_name": "bugs_case",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  code (8 bits)\n - output out  (4 bits)\n - output valid\n\nThe module should recognize 8-bit keyboard scancodes for keys 0 through\n9. It should indicate whether one of the 10 cases were recognized\n(valid), and if so, which key was detected. If the 8-bit input is 8'h45,\n8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the\n4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively,\nthe 1-bit valid would be set to 1. If the input does not match any of the\ncases, both output signals would be set to 0.",
    "reference_implementation": "module RefModule (\n  input [7:0] code,\n  output reg [3:0] out,\n  output reg valid\n);\n\n  // uhh.. make a case statement: maps scancode to 0-9, but accidentally\n  // infer a latch? and have one of the entries be wrong? (duplicate\n  // case, using different base!)\n\n  always @(*) begin\n    out = 0;\n    valid = 1;\n    case (code)\n      8'h45: out = 0;\n      8'h16: out = 1;\n      8'h1e: out = 2;\n      8'h26: out = 3;\n      8'h25: out = 4;\n      8'h2e: out = 5;\n      8'h36: out = 6;\n      8'h3d: out = 7;\n      8'h3e: out = 8;\n      8'h46: out = 9;\n      default: valid = 0;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [7:0] code,\n  output reg [3:0] out,\n  output reg valid\n);\n  always @(*) begin\n    case (code)\n      8'h45: begin out =854'h0; valid = 1; end\n      8'h16: begin out =854'h1; valid = 1; end\n      8'h1e: begin out =854'h2; valid = 1; end\n      8'h26: begin out =854'h3; valid = 1; end\n      8'h25: begin out =854'h4; valid = 1; end\n      8'h2e: begin out =854'h5; valid = 1; end\n      8'h36: begin out =854'h6; valid = 1; end\n      8'h3d: begin out =854'h7; valid = 1; end\n      8'h3e: begin out =854'h8; valid = 1; end\n      8'h46: begin out =854'h9; valid = 1; end\n      default: begin out = 0; valid = 0; end\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [7:0] code,\n  output reg [3:0] out,\n  output reg valid\n);\n  always @(*) begin\n    out = 0;\n    valid = 1;\n    case (code)\n      8'h45: out = 0;\n      8'h16: out = 1;\n      8'h1e: out = 2;\n      8'h26: out = 3;\n      8'h25: out = 1;\n      8'h2e: out = 5;\n      8'h36: out = 6;\n      8'h3d: out = 7;\n      8'h3e: out = 8;\n      8'h46: out = 9;\n      default: valid = 0;\n    endcase\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 115,
    "problem_name": "shift18",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  load\n - input  ena\n - input  amount (2 bits)\n - input  data (64 bits)\n - output q (64 bits)\n\nThe module should implement a 64-bit arithmetic shift register, with\nsynchronous load. The shifter can shift both left and right, and by 1 or\n8 bit positions, selected by \"amount.\" Assume the right shit is an\narithmetic right shift.\n\nSignals are defined as below:\n\n  (1) load: Loads shift register with data[63:0] instead of shifting.\n       Active high.\n  (2) ena: Chooses whether to shift. Active high.\n  (3) amount: Chooses which direction and how much to shift.\n      (a) 2'b00: shift left by 1 bit.\n      (b) 2'b01: shift left by 8 bits.\n      (c) 2'b10: shift right by 1 bit.\n      (d) 2'b11: shift right by 8 bits.\n  (4) q: The contents of the shifter.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input load,\n  input ena,\n  input [1:0] amount,\n  input [63:0] data,\n  output reg [63:0] q\n);\n\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else if (ena) case (amount)\n      2'b00: q <= {q[62:0], 1'b0};\n      2'b01: q <= {q[55:0], 8'b0};\n      2'b10: q <= {q[63], q[63:1]};\n      2'b11: q <= {{8{q[63]}}, q[63:8]};\n      default: q <= 64'hx;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input load,\n  input ena,\n  input [1:0] amount,\n  input [63:0] data,\n  output reg [63:0] q\n);\n  always @(posedge clk) begin\n    if (load) q <= data;\n    else if (ena)\n      case (amount)\n        2'b00: q <= q << 1;\n        2'b01: q <= q << 8;\n        2'b10: q <= {q[63], q[63:1]};\n        2'b11: q <= {{8{q[63]}}, q[63:8]};\n        default: q <= 64'hx;\n      endcase\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input load,\n  input ena,\n  input [1:0] amount,\n  input [63:0] data,\n  output reg [63:0] q\n);\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else if (ena) case (amount)\n      2'b00: q <= {q[62:0], 1'b0};\n      2'b01: q <= {q[55:0], 8'b0};\n      2'b10: q <= {1'b0, q[63:1]};\n      2'b11: q <= {{8{q[63]}}, q[63:8]};\n      default: q <= 64'hx;\n    endcase\n  end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 116,
    "problem_name": "m2014_q3",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  x (4 bits)\n - output f\n\nThe module should implement the function f shown in the Karnaugh map\nbelow. d is don't-care, which means you may choose to output whatever\nvalue is convenient.\n\n                x[1]x[2]\n  x[3]x[4]   00  01  11  10\n        00 | d | 0 | d | d |\n        01 | 0 | d | 1 | 0 |\n        11 | 1 | 1 | d | d |\n        10 | 1 | 1 | 0 | d |",
    "reference_implementation": "module RefModule (\n  input [3:0] x,\n  output logic f\n);\n\n  always_comb begin\n    case (x)\n      4'h0: f = 1'bx;\n      4'h1: f = 1'bx;\n      4'h2: f = 0;\n      4'h3: f = 1'bx;\n      4'h4: f = 1;\n      4'h5: f = 1'bx;\n      4'h6: f = 1;\n      4'h7: f = 0;\n      4'h8: f = 0;\n      4'h9: f = 0;\n      4'ha: f = 1'bx;\n      4'hb: f = 1;\n      4'hc: f = 1;\n      4'hd: f = 1'bx;\n      4'he: f = 1;\n      4'hf: f = 1'bx;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [3:0] x,\n  output reg f\n);\n  always @(*) begin\n    case (x)\n      4'h0: f = 1'bx;\n      4'h1: f = 1'bx;\n      4'h2: f = 1'b0;\n      4'h3: f = 1'bx;\n      4'h4: f = 1'b1;\n      4'h5: f = 1'bx;\n      4'h6: f = 1'b1;\n      4'h7: f = 1'b0;\n      4'h8: f = 1'b0;\n      4'h9: f = 1'b0;\n      4'ha: f = 1'bx;\n      4'hb: f = 1'b1;\n      4'hc: f = 1'b1;\n      4'hd: f = 1'bx;\n      4'he: f = 1'b1;\n      4'hf: f = 1'bx;\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input [3:0] x,\n  output logic f\n);\n  always_comb begin\n    case (x)\n      4'h0: f = 1'bx;\n      4'h1: f = 1'bx;\n      4'h2: f = 0;\n      4'h3: f = 1'bx;\n      4'h4: f = 1;\n      4'h5: f = 1'bx;\n      4'h6: f = 1;\n      4'h7: f = 0;\n      4'h8: f = 0;\n      4'h9: f = 0;\n      4'ha: f = 1'bx;\n      4'hb: f = 1;\n      4'hc: f = 1;\n      4'hd: f = 1'bx;\n      4'he: f = 1;\n      4'hf: f = 1'bx;\n    endcase\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 117,
    "problem_name": "circuit9",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  a\n - output q (3 bits)\n\nThe module implements a sequential circuit. Read the simulation waveforms\nto determine what the circuit does, then implement it.\n\n  time  clk a   q\n  0ns   0   1   x\n  5ns   1   1   4\n  10ns  0   1   4\n  15ns  1   1   4\n  20ns  0   1   4\n  25ns  1   1   4\n  30ns  0   1   4\n  35ns  1   1   4\n  40ns  0   1   4\n  45ns  1   0   4\n  50ns  0   0   4\n  55ns  1   0   5\n  60ns  0   0   5\n  65ns  1   0   6\n  70ns  0   0   6\n  75ns  1   0   0\n  80ns  0   0   0\n  85ns  1   0   1\n  90ns  0   0   1",
    "reference_implementation": "module RefModule (\n  input clk,\n  input a,\n  output reg [2:0] q\n);\n\n  always @(posedge clk)\n    if (a)\n      q <= 4;\n    else if (q == 6)\n      q <= 0;\n    else\n      q <= q + 1'b1;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input a,\n  output reg [2:0] q\n);\n  always @(posedge clk) begin\n    if (a)\n      q <= 3'd4;\n    else if (q == 3'd6)\n      q <= 3'd0;\n    else\n      q <= q + 3'd1;\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input a,\n  output reg [2:0] q\n);\n  always @(posedge clk)\n    if (a)\n      q <= 4;\n    else if (q == 5)\n      q <= 0;\n    else\n      q <= q + 1'b1;\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 118,
    "problem_name": "history_shift",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  predict_valid\n - input  predict_taken\n - input  train_mispredicted\n - input  train_taken\n - input  train_history   (32 bits)\n - output predict_history (32 bits)\n\nThe module should implement a 32-bit global history shift register,\nincluding support for rolling back state in response to a pipeline flush\ncaused by a branch misprediction. When a branch prediction is made\n(predict_valid = 1), shift in predict_taken from the LSB side to update\nthe branch history for the predicted branch. (predict_history[0] is the\ndirection of the youngest branch.) When a branch misprediction occurs\n(train_mispredicted = 1), load the branch history register with the\nhistory after the completion of the mispredicted branch. This is the\nhistory before the mispredicted branch (train_history) concatenated with\nthe actual result of the branch (train_taken). If both a prediction and\nmisprediction occur at the same time, the misprediction takes precedence,\nbecause the pipeline flush will also flush out the branch that is\ncurrently making a prediction. predict_history is the value of the branch\nhistory register. areset is a positive edge triggered asynchronous reset\nthat resets the history counter to zero. Assume all sequential logic is\ntriggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input predict_valid,\n  input predict_taken,\n  output logic [31:0] predict_history,\n\n  input train_mispredicted,\n  input train_taken,\n  input [31:0] train_history\n);\n\n  always@(posedge clk, posedge areset)\n    if (areset) begin\n      predict_history = 0;\n        end  else begin\n      if (train_mispredicted)\n        predict_history <= {train_history, train_taken};\n      else if (predict_valid)\n        predict_history <= {predict_history, predict_taken};\n    end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input areset,\n  input predict_valid,\n  input predict_taken,\n  output logic [31:0] predict_history,\n  input train_mispredicted,\n  input train_taken,\n  input [31:0] train_history\n);\n  always @(posedge clk or posedge areset)\n    if (areset)\n      predict_history <= 0;\n    else begin\n      if (train_mispredicted)\n        predict_history <= {train_history, train_taken};\n      else\n        if (predict_valid)\n          predict_history <= {predict_history[30:0], predict_taken};\n    end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input areset,\n  input predict_valid,\n  input predict_taken,\n  output logic [31:0] predict_history,\n  input train_mispredicted,\n  input train_taken,\n  input [31:0] train_history\n);\n  always @(posedge clk or posedge areset)\n    if (areset)\n      predict_history <= 0;\n    else begin\n      if (train_mispredicted)\n        predict_history <= {train_history, 1'b1};\n      else if (predict_valid)\n        predict_history <= {predict_history, predict_taken};\n    end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 119,
    "problem_name": "fsm3",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  in\n - output out\n\nThe module should implement a Moore state machine with the following\nstate transition table with one input, one output, and four states.\nImplement this state machine. Include a positive edge triggered\nasynchronous reset that resets the FSM to state A. Assume all sequential\nlogic is triggered on the positive edge of the clock.\n\n  state | next state in=0, next state in=1 | output\n  A     | A, B                             | 0\n  B     | C, B                             | 0\n  C     | A, D                             | 0\n  D     | C, B                             | 1",
    "reference_implementation": "module RefModule (\n  input clk,\n  input in,\n  input areset,\n  output out\n);\n\n  parameter A=0, B=1, C=2, D=3;\n  reg [1:0] state;\n  reg [1:0] next;\n\n  always_comb begin\n  case (state)\n    A: next = in ? B : A;\n    B: next = in ? B : C;\n    C: next = in ? D : A;\n    D: next = in ? B : C;\n  endcase\n  end\n\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= A;\n      else state <= next;\n  end\n\n  assign out = (state==D);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input in,\n  input areset,\n  output out\n);\n  parameter A=0, B=1, C=2, D=3;\n  reg [1:0] state;\n  reg [1:0] next_state;\n  always_comb begin\n    case (state)\n      A: next_state = in ? B : A;\n      B: next_state = in ? B : C;\n      C: next_state = in ? D : A;\n      D: next_state = in ? B : C;\n    endcase\n  end\n  always @(posedge clk, posedge areset) begin\n    if (areset)\n      state <= A;\n    else\n      state <= next_state;\n  end\n  assign out = (state == D);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input in,\n  input areset,\n  output out\n);\n  parameter A=0, B=1, C=2, D=3;\n  reg [1:0] state;\n  reg [1:0] next;\n  always_comb begin\n    case (state)\n      A: next = in ? B : A;\n      B: next = in ? C : C;\n      C: next = in ? D : A;\n      D: next = in ? B : C;\n    endcase\n  end\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= A;\n      else state <= next;\n  end\n  assign out = (state==D);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 120,
    "problem_name": "fsm3s",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  in\n - output out\n\nThe module should implement a Moore state machine with the following\nstate transition table with one input, one output, and four states.\nInclude a synchronous active high reset that resets the FSM to state A.\nAssume all sequential logic is triggered on the positive edge of the\nclock.\n\n  State | Next state in=0, Next state in=1 | Output\n  A     | A, B                             | 0\n  B     | C, B                             | 0\n  C     | A, D                             | 0\n  D     | C, B                             | 1",
    "reference_implementation": "module RefModule (\n  input clk,\n  input in,\n  input reset,\n  output out\n);\n\n  parameter A=0, B=1, C=2, D=3;\n  reg [1:0] state;\n  reg [1:0] next;\n\n  always_comb begin\n    case (state)\n      A: next = in ? B : A;\n      B: next = in ? B : C;\n      C: next = in ? D : A;\n      D: next = in ? B : C;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= A;\n      else state <= next;\n  end\n\n  assign out = (state==D);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input in,\n  input reset,\n  output out\n);\n  parameter A=0, B=1, C=2, D=3;\n  reg [1:0] state, next;\n  always_comb begin\n    case (state)\n      A: if (in) next = B; else next = A;\n      B: if (in) next = B; else next = C;\n      C: if (in) next = D; else next = A;\n      D: if (in) next = B; else next = C;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= A;\n    else state <= next;\n  end\n  assign out = (state == D);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input in,\n  input reset,\n  output out\n);\n  parameter A=0, B=1, C=2, D=3;\n  reg [1:0] state;\n  reg [1:0] next;\n  always_comb begin\n    case (state)\n      A: next = in ? B : A;\n      B: next = in ? B : C;\n      C: next = in ? D : A;\n      D: next = in ? B : A;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= A;\n      else state <= next;\n  end\n  assign out = (state==D);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 121,
    "problem_name": "2014_q3bfsm",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  x\n - output z\n\nThe module should implement a finite-state machine with the\nstate-assigned table shown below. Reset should synchronous active high\nreset the FSM to state 000. Assume all sequential logic is triggered on\nthe positive edge of the clock.\n\n  Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1 | Output z\n  000 | 000, 001 | 0\n  001 | 001, 100 | 0\n  010 | 010, 001 | 0\n  011 | 001, 010 | 1\n  100 | 011, 100 | 1",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input x,\n  output reg z\n);\n\n  parameter A=0, B=1, C=2, D=3, E=4;\n  reg [2:0] state, next;\n\n  always @(posedge clk) begin\n    if (reset) state <= A;\n    else state <= next;\n  end\n\n  always_comb begin\n    case (state)\n      A: next = x ? B : A;\n      B: next = x ? E : B;\n      C: next = x ? B : C;\n      D: next = x ? C : B;\n      E: next = x ? E : D;\n      default: next = 'x;\n    endcase\n  end\n\n  assign z = (state == D) || (state == E);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input x,\n  output reg z\n);\n  parameter A=0, B=1, C=2, D=3, E=4;\n  reg [2:0] state, next_state;\n  always @(posedge clk) begin\n    if (reset) state <= A;\n    else state <= next_state;\n  end\n  always_comb begin\n    case (state)\n      A: next_state = x ? B : A;\n      B: next_state = x ? E : B;\n      C: next_state = x ? B : C;\n      D: next_state = x ? C : B;\n      E: next_state = x ? E : D;\n      default: next_state = A;\n    endcase\n  end\n  always @(*) begin\n    z = (state == D) || (state == E);\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input x,\n  output reg z\n);\n  parameter A=0, B=1, C=2, D=3, E=4;\n  reg [2:0] state, next;\n  always @(posedge clk) begin\n    if (reset) state <= A;\n    else state <= next;\n  end\n  always_comb begin\n    case (state)\n      A: next = x ? B : A;\n      B: next = x ? E : B;\n      C: next = x ? B : C;\n      D: next = x ? C : B;\n      E: next = x ? E : A;\n      default: next = 'x;\n    endcase\n  end\n  assign z = (state == D) || (state == E);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 122,
    "problem_name": "kmap4",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  c\n - input  d\n - output out\n\nThe module should implement the Karnaugh map below.\n\n             ab\n  cd   00  01  11  10\n  00 | 0 | 1 | 0 | 1 |\n  01 | 1 | 0 | 1 | 0 |\n  11 | 0 | 1 | 0 | 1 |\n  10 | 1 | 0 | 1 | 0 |",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output reg out\n);\n\n  always @(*) begin\n    case({a,b,c,d})\n      4'h0: out = 0;\n      4'h1: out = 1;\n      4'h3: out = 0;\n      4'h2: out = 1;\n      4'h4: out = 1;\n      4'h5: out = 0;\n      4'h7: out = 1;\n      4'h6: out = 0;\n      4'hc: out = 0;\n      4'hd: out = 1;\n      4'hf: out = 0;\n      4'he: out = 1;\n      4'h8: out = 1;\n      4'h9: out = 0;\n      4'hb: out = 1;\n      4'ha: out = 0;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output reg out\n);\n\n  always @(*) begin\n    case({c,d,a,b})\n      4'b0000: out = 0;\n      4'b0001: out = 1;\n      4'b0011: out = 0;\n      4'b0010: out = 1;\n      4'b0100: out = 1;\n      4'b0101: out = 0;\n      4'b0111: out = 1;\n      4'b0110: out = 0;\n      4'b1100: out = 0;\n      4'b1101: out = 1;\n      4'b1111: out = 0;\n      4'b1110: out = 1;\n      4'b1000: out = 1;\n      4'b1001: out = 0;\n      4'b1011: out = 1;\n      4'b1010: out = 0;\n    endcase\n  end\n\nendmodule",
    "buggy_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output reg out\n);\n  always @(*) begin\n    case({a,b,c,d})\n      4'h0: out = 0;\n      4'h1: out = 1;\n      4'h3: out = 0;\n      4'h2: out = 1;\n      4'h4: out = 1;\n      4'h5: out = 0;\n      4'h7: out = 0;\n      4'h6: out = 0;\n      4'hc: out = 0;\n      4'hd: out = 1;\n      4'hf: out = 0;\n      4'he: out = 1;\n      4'h8: out = 1;\n      4'h9: out = 0;\n      4'hb: out = 1;\n      4'ha: out = 0;\n    endcase\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 123,
    "problem_name": "bugs_addsubz",
    "original_prompt": "Consider the following adder-subtractor with a zero flag:\n\n  synthesis verilog_input_version verilog_2001\n  module TopModule (\n      input do_sub,\n      input [7:0] a,\n      input [7:0] b,\n      output reg [7:0] out,\n      output reg result_is_zero\n  );\n\n      always @(*) begin\n          case (do_sub)\n            0: out = a+b;\n            1: out = a-b;\n          endcase\n\n          if (~out)\n              result_is_zero = 1;\n      end\n\n  endmodule\n\nUnfortunately, this module has a bug. Implement a new version of this\nmodule that fixes the bug.",
    "reference_implementation": "module RefModule (\n  input do_sub,\n  input [7:0] a,\n  input [7:0] b,\n  output reg [7:0] out,\n  output reg result_is_zero\n);\n\n  always @(*) begin\n    case (do_sub)\n      0: out = a + b;\n      1: out = a - b;\n    endcase\n    result_is_zero = (out == 0);\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n    always @(*) begin\n        if (do_sub)\n            out = a - b;\n        else\n            out = a + b;\n        result_is_zero = (out == 8'b0);\n    end\nendmodule",
    "buggy_implementation": "module TopModule (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n        if (|out)\n            result_is_zero = 0;\n    end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 124,
    "problem_name": "rule110",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  load\n - input  data (512 bits)\n - output q    (512 bits)\n\nThe module should implement Rule 110, a one-dimensional cellular\nautomaton with interesting properties (such as being Turing-complete).\nThere is a one-dimensional array of cells (on or off). At each time step,\nthe state of each cell changes. In Rule 110, the next state of each cell\ndepends only on itself and its two neighbours, according to the following\ntable:\n\n  Left[i+1] | Center[i] | Right[i-1] | Center's next state \n  1         | 1         | 1          | 0\n  1         | 1         | 0          | 1\n  1         | 0         | 1          | 1\n  1         | 0         | 0          | 0\n  0         | 1         | 1          | 1\n  0         | 1         | 0          | 1\n  0         | 0         | 1          | 1\n  0         | 0         | 0          | 0\n\nIn this circuit, create a 512-cell system (q[511:0]), and advance by one\ntime step each clock cycle. The synchronous active high load input\nindicates the state of the system should be loaded with data[511:0].\nAssume the boundaries (q[-1] and q[512], if they existed) are both zero\n(off). Assume all sequential logic is triggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input load,\n  input [511:0] data,\n  output reg [511:0] q\n);\n\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else begin\n      q <=\n      ~((q[$bits(q)-1:1] & q[$bits(q)-1:0] & {q[$bits(q)-2:0], 1'b0}) |\n      (~q[$bits(q)-1:1] & ~q[$bits(q)-1:0] & ~{q[$bits(q)-2:0], 1'b0}) |\n      (q[$bits(q)-1:1] & ~q[$bits(q)-1:0] & ~{q[$bits(q)-2:0], 1'b0}) )\n      ;\n    end\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input load,\n  input [511:0] data,\n  output reg [511:0] q\n);\n  always @(posedge clk) begin\n    if (load) begin\n      q <= data;\n    end else begin\n      q <=\n      ~( (q[511:1]  & q[511:0]  & {q[510:0], 1'b0}) |\n         (~q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}) |\n         (q[511:1]  & ~q[511:0] & ~{q[510:0], 1'b0}) )\n      ;\n    end\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input load,\n  input [511:0] data,\n  output reg [511:0] q\n);\n  always @(posedge clk) begin\n    if (load)\n      q <= data;\n    else begin\n      q <=\n      ~( (q[511:1]  & q[511:0]  & {q[510:0], 1'b0}) |\n         (~q[511:1] & ~q[511:0] & ~{q[510:0], 1'b0}) |\n         (q[511:1]  & ~q[511:0] & ~{q[510:0], 1'b1}) )\n      ;\n    end\n  end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 125,
    "problem_name": "kmap3",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a\n - input  b\n - input  c\n - input  d\n - output out\n\nThe module should implement the Karnaugh map below. d is don't-care,\nwhich means you may choose to output whatever value is convenient.\n\n              ab\n   cd   01  00  10  11\n   00 | d | 0 | 1 | 1 |\n   01 | 0 | 0 | d | d |\n   11 | 0 | 1 | 1 | 1 |\n   10 | 0 | 1 | 1 | 1 |",
    "reference_implementation": "module RefModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output reg out\n);\n\n  always @(*) begin\n    case({a,b,c,d})\n      4'h0: out = 0;\n      4'h1: out = 0;\n      4'h3: out = 1;\n      4'h2: out = 1;\n      4'h4: out = 1'bx;\n      4'h5: out = 0;\n      4'h7: out = 0;\n      4'h6: out = 0;\n      4'hc: out = 1;\n      4'hd: out = 1'bx;\n      4'hf: out = 1;\n      4'he: out = 1;\n      4'h8: out = 1;\n      4'h9: out = 1'bx;\n      4'hb: out = 1;\n      4'ha: out = 1;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output reg out\n);\n  always @(*) begin\n    case({a,b,c,d})\n      4'h0: out = 0;\n      4'h1: out = 0;\n      4'h2: out = 1;\n      4'h3: out = 1;\n      4'h4: out = 1'bx;\n      4'h5: out = 0;\n      6, 7, 4'h6: out = 0;\n      4'h8: out = 1;\n      4'h9: out = 1'bx;\n      4'ha: out = 1;\n      4'hb: out = 1;\n      4'hc: out = 1;\n      4'hd: out = 1'bx;\n      4'he: out = 1;\n      4'hf: out = 1;\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output reg out\n);\n  always @(*) begin\n    case({a,b,c})\n      3'b000: out = 0;\n      3'b001: out = 0;\n      3'b010: out = 1;\n      3'b011: out = 1;\n      3'b100: out = 0;\n      3'b101: out = 0;\n      3'b110: out = 0;\n      3'b111: out = 1;\n      default: out = 1'bx;\n    endcase\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 126,
    "problem_name": "circuit6",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a ( 3 bits)\n - output q (16 bits)\n\nThe module should implement a combinational circuit. Read the simulation\nwaveforms to determine what the circuit does, then implement it.\n\n  time  a     q\n  0ns   x     x\n  5ns   x     x\n  10ns  x     x\n  15ns  0  1232\n  20ns  1  aee0\n  25ns  2  27d4\n  30ns  3  5a0e\n  35ns  4  2066\n  40ns  5  64ce\n  45ns  6  c526\n  50ns  7  2f19\n  55ns  0  1232\n  60ns  1  aee0\n  65ns  2  27d4\n  70ns  4  2066\n  75ns  1  aee0\n  80ns  1  aee0\n  85ns  3  5a0e\n  90ns  5  64ce",
    "reference_implementation": "module RefModule (\n  input [2:0] a,\n  output reg [15:0] q\n);\n\n  always @(*)\n    case (a)\n      0: q = 4658;\n      1: q = 44768;\n      2: q = 10196;\n      3: q = 23054;\n      4: q = 8294;\n      5: q = 25806;\n      6: q = 50470;\n      7: q = 12057;\n    endcase\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input [2:0] a,\n  output reg [15:0] q\n);\n  always @(*)\n    begin\n      case (a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n      endcase\n    end\nendmodule",
    "buggy_implementation": "module BuggyModule (\n  input [2:0] a,\n  output reg [15:0] q\n);\n  always @(*)\n    case (a)\n      0: q = 4658;\n      1: q = 44768;\n      2: q = 10196;\n      3: q = 23054;\n      4: q = 8294;\n      5: q = 25806;\n      6: q = 50470;\n    endcase\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 127,
    "problem_name": "lemmings1",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  bump_left\n - input  bump_right\n - output walk_left\n - output walk_right\n\nThe module should implement a simple game called Lemmings which involves\ncritters with fairly simple brains. So simple that we are going to model\nit using a finite state machine. In the Lemmings' 2D world, Lemmings can\nbe in one of two states: walking left (walk_left is 1) or walking right\n(walk_right is 1). It will switch directions if it hits an obstacle. In\nparticular, if a Lemming is bumped on the left (by receiving a 1 on\nbump_left), it will walk right. If it's bumped on the right (by receiving\na 1 on bump_right), it will walk left. If it's bumped on both sides at\nthe same time, it will still switch directions.\n\nThe module should implement a Moore state machine with two states, two\ninputs, and one output (internal to the module) that models this\nbehaviour. areset is positive edge triggered asynchronous resetting the\nLemming machine to walk left. Assume all sequential logic is triggered on\nthe positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  output walk_left,\n  output walk_right\n);\n\n  parameter WL=0, WR=1;\n  reg state;\n  reg next;\n\n  always_comb begin\n    case (state)\n      WL: next = bump_left ? WR : WL;\n      WR: next = bump_right ? WL: WR;\n    endcase\n  end\n\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n      else state <= next;\n  end\n\n  assign walk_left = (state==WL);\n  assign walk_right = (state==WR);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  output walk_left,\n  output walk_right\n);\n  parameter WL=0, WR=1;\n  reg state;\n  reg next;\n  always @(*) begin\n    case (state)\n      WL: next = bump_left ? WR : WL;\n      WR: next = bump_right ? WL : WR;\n    endcase\n  end\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n    else state <= next;\n  end\n  assign walk_left = (state == WL);\n  assign walk_right = !walk_left;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  output walk_left,\n  output walk_right\n);\n  parameter WL=0, WR=1;\n  reg state;\n  reg next;\n  always_comb begin\n    case (state)\n      WL: next = bump_left ? WR : state;\n      WR: next = bump_right ? WL : state;\n    endcase\n  end\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WR;\n      else state <= next;\n  end\n  assign walk_left = (state==WL);\n  assign walk_right = (state==WR);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 128,
    "problem_name": "fsm_ps2",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  in (8 bits)\n - output done\n\nThe PS/2 mouse protocol sends messages that are three bytes long.\nHowever, within a continuous byte stream, it's not obvious where messages\nstart and end. The only indication is that the first byte of each three\nbyte message always has in[3]=1 (but in[3] of the other two bytes may be\n1 or 0 depending on data).\n\nThe module should implement a finite state machine that will search for\nmessage boundaries when given an input byte stream. The algorithm we'll\nuse is to discard bytes until we see one with in[3]=1. We then assume\nthat this is byte 1 of a message, and signal the receipt of a message\nonce all 3 bytes have been received (done). The FSM should signal done in\nthe cycle immediately after the third byte of each message was\nsuccessfully received. Reset should be active high synchronous. Assume\nall sequential logic is triggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input [7:0] in,\n  input reset,\n  output done\n);\n\n  parameter BYTE1=0, BYTE2=1, BYTE3=2, DONE=3;\n  reg [1:0] state;\n  reg [1:0] next;\n\n  wire in3 = in[3];\n\n  always_comb begin\n    case (state)\n      BYTE1: next = in3 ? BYTE2 : BYTE1;\n      BYTE2: next = BYTE3;\n      BYTE3: next = DONE;\n      DONE: next = in3 ? BYTE2 : BYTE1;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= BYTE1;\n      else state <= next;\n  end\n\n  assign done = (state==DONE);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input [7:0] in,\n  input reset,\n  output done\n);\n  parameter BYTE1=0, BYTE2=1, BYTE3=2, DONE=3;\n  reg [1:0] state;\n  reg [1:0] next;\n  wire in3 = in[3];\n  always_comb begin\n    next = state;\n    case (state)\n      BYTE1: if (in3) next = BYTE2;\n      BYTE2: next = BYTE3;\n      BYTE3: next = DONE;\n      DONE: next = in3 ? BYTE2 : BYTE1;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= BYTE1;\n    else state <= next;\n  end\n  assign done = (state == DONE);\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input [7:0] in,\n  input reset,\n  output done\n);\n  parameter BYTE1=0, BYTE2=1, BYTE3=2, DONE=3;\n  reg [1:0] state;\n  reg [1:0] next;\n  wire in3 = in[3];\n  always_comb begin\n    case (state)\n      BYTE1: next = in3 ? BYTE2 : BYTE1;\n      BYTE2: next = BYTE3;\n      BYTE3: next = DONE;\n      DONE: next = BYTE1;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= BYTE1;\n      else state <= next;\n  end\n  assign done = (state==DONE);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 129,
    "problem_name": "ece241_2013_q8",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  aresetn\n - input  x\n - output z\n\nThe module should implement a Mealy-type finite state machine that\nrecognizes the sequence \"101\" on an input signal named x. Your FSM should\nhave an output signal, z, that is asserted to logic-1 when the \"101\"\nsequence is detected. Your FSM should also have a negative edge triggered\nasynchronous reset. You may only have 3 states in your state machine.\nYour FSM should recognize overlapping sequences. Assume all sequential\nlogic is triggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input aresetn,\n  input x,\n  output reg z\n);\n\n  parameter S=0, S1=1, S10=2;\n  reg[1:0] state, next;\n\n  always@(posedge clk, negedge aresetn)\n    if (!aresetn)\n      state <= S;\n    else\n      state <= next;\n\n  always_comb begin\n    case (state)\n      S: next = x ? S1 : S;\n      S1: next = x ? S1 : S10;\n      S10: next = x ? S1 : S;\n      default: next = 'x;\n    endcase\n  end\n\n  always_comb begin\n    case (state)\n      S: z = 0;\n      S1: z = 0;\n      S10: z = x;\n      default: z = 'x;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input aresetn,\n  input x,\n  output reg z\n);\n  parameter S=0, S1=1, S10=2;\n  reg [1:0] state, next_state;\n  always @(posedge clk, negedge aresetn)\n    if (!aresetn)\n      state <= S;\n    else\n      state <= next_state;\n  always @(*) begin\n    case (state)\n      S: next_state = x ? S1 : S;\n      S1: next_state = x ? S1 : S10;\n      S10: next_state = x ? S1 : S;\n      default: next_state = 'x;\n    endcase\n  end\n  always @(*) begin\n    case (state)\n      S: z = 0;\n      S1: z = 0;\n      S10: z = x;\n      default: z = 'x;\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input aresetn,\n  input x,\n  output reg z\n);\n  parameter S=0, S1=1, S10=2;\n  reg [1:0] state, next;\n  always @(posedge clk, negedge aresetn)\n    if (!aresetn)\n      state <= S;\n    else\n      state <= next;\n  always @(*) begin\n    case (state)\n      S: next = x ? S1 : S;\n      S1: next = x ? S1 : S10;\n      S10: next = x ? S1 : S;\n      default: next = 'x;\n    endcase\n  end\n  always @(*) begin\n    case (state)\n      S: z = 0;\n      S1: z = 0;\n      S10: z = 0;\n      default: z = 'x;\n    endcase\n  end\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 130,
    "problem_name": "circuit5",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  a (4 bits)\n - input  b (4 bits)\n - input  c (4 bits)\n - input  d (4 bits)\n - input  e (4 bits)\n - output q (4 bits)\n\nThe module should implement a combinational circuit. Read the simulation\nwaveforms to determine what the circuit does, then implement it.\n\n  time  a  b  c  d  e  q\n  0ns   x  x  x  x  x  x\n  5ns   x  x  x  x  x  x\n  10ns  x  x  x  x  x  x\n  15ns  a  b  0  d  e  b\n  20ns  a  b  1  d  e  e\n  25ns  a  b  2  d  e  a\n  30ns  a  b  3  d  e  d\n  35ns  a  b  4  d  e  f\n  40ns  a  b  5  d  e  f\n  45ns  a  b  6  d  e  f\n  50ns  a  b  7  d  e  f\n  55ns  a  b  8  d  e  f\n  60ns  a  b  9  d  e  f\n  65ns  a  b  a  d  e  f\n  70ns  a  b  b  d  e  f\n  75ns  a  b  c  d  e  f\n  80ns  a  b  d  d  e  f\n  85ns  a  b  e  d  e  f\n  90ns  a  b  f  d  e  f",
    "reference_implementation": "module RefModule (\n  input [3:0] a,\n  input [3:0] b,\n  input [3:0] c,\n  input [3:0] d,\n  input [3:0] e,\n  output reg [3:0] q\n);\n\n  always @(*)\n    case (c)\n      0: q = b;\n      1: q = e;\n      2: q = a;\n      3: q = d;\n      default: q = 4'hf;\n    endcase\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [3:0] a,\n  input [3:0] b,\n  input [3:0] c,\n  input [3:0] d,\n  input [3:0] e,\n  output reg [3:0] q\n);\n  always @(*) begin\n    case (c)\n      2'b00: q = b;\n      2'b01: q = e;\n      2'b10: q = a;\n      2'b11: q = d;\n      default: q = 4'hf;\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [3:0] a,\n  input [3:0] b,\n  input [3:0] c,\n  input [3:0] d,\n  input [3:0] e,\n  output reg [3:0] q\n);\n  always @(*)\n    case (c)\n      0: q = b;\n      1: q = e;\n      2: q = a;\n      3: q = d;\n      default: q = 4'h0;\n    endcase\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 131,
    "problem_name": "mt2015_q4",
    "original_prompt": "Module A implements the boolean function z = (x^y) & x.\n\nModule B can be described by the following simulation waveform:\n\n  time  x  y  z\n  0ns   0  0  1\n  5ns   0  0  1\n  10ns  0  0  1\n  15ns  0  0  1\n  20ns  0  0  1\n  25ns  1  0  0\n  30ns  1  0  0\n  35ns  0  1  0\n  40ns  0  1  0\n  45ns  1  1  1\n  50ns  1  1  1\n  55ns  0  0  1\n  60ns  0  1  0\n  65ns  0  1  0\n  70ns  1  1  1\n  75ns  0  1  0\n  80ns  0  1  0\n  85ns  0  1  0\n  90ns  1  0  0\n\nNow consider a top-level module with the following interface:\n\n - input  x\n - input  y\n - output z\n\nThe module is implemented with two A submodules and two B submodules. The\nfirst input of all four submodules is connect to input 'x', and the\nsecond input of all four submodules is connected to 'y'. The output of\nthe first A submodule is connected to a two-input OR, along with the\noutput of the first B submodule. The second pair of A and B submodules is\nsimilarly connected to an AND gate. The output of the OR and the AND is\nconnected to an XOR, whose output is 'z'.",
    "reference_implementation": "module RefModule (\n  input x,\n  input y,\n  output z\n);\n\n  assign z = x|~y;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input x,\n  input y,\n  output z\n);\n  wire t1 = ~y;\n  wire t2 = x | t1;\n  assign z = t2;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input x,\n  input y,\n  output z\n);\n  assign z = x ^ ~y;\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 132,
    "problem_name": "always_if2",
    "original_prompt": "Consider the following adder-subtractor with a zero flag:\n\n  module TopModule (\n      input      cpu_overheated,\n      output reg shut_off_computer,\n      input      arrived,\n      input      gas_tank_empty,\n      output reg keep_driving\n  );\n\n      always @(*) begin\n          if (cpu_overheated)\n             shut_off_computer = 1;\n      end\n\n      always @(*) begin\n          if (~arrived)\n             keep_driving = ~gas_tank_empty;\n      end\n\n  endmodule\n\nUnfortunately, this module has a bug. Implement a new version of this\nmodule that fixes the bug.",
    "reference_implementation": "module RefModule (\n  input cpu_overheated,\n  output reg shut_off_computer,\n  input arrived,\n  input gas_tank_empty,\n  output reg keep_driving\n);\n\n  always @(*) begin\n    if (cpu_overheated)\n      shut_off_computer = 1;\n    else\n      shut_off_computer = 0;\n  end\n\n  always @(*) begin\n    if (~arrived)\n      keep_driving = !gas_tank_empty;\n    else\n      keep_driving = 1'b0;\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input cpu_overheated,\n  output reg shut_off_computer,\n  input arrived,\n  input gas_tank_empty,\n  output reg keep_driving\n);\n\n  always @(*) begin\n    if (cpu_overheated)\n      shut_off_computer = 1;\n    else\n      shut_off_computer = 0;\n  end\n\n  always @(*) begin\n    if (~arrived)\n      keep_driving = !gas_tank_empty;\n    else\n      keep_driving = 1'b0;\n  end\n\nendmodule",
    "buggy_implementation": "module BuggyModule (\n  input cpu_overheated,\n  output reg shut_off_computer,\n  input arrived,\n  input gas_tank_empty,\n  output reg keep_driving\n);\n  always @(*) begin\n    if (cpu_overheated)\n      shut_off_computer = 1;\n    else\n      shut_off_computer = 0;\n  end\n  always @(*) begin\n    if (~arrived)\n      keep_driving = gas_tank_empty;\n    else\n      keep_driving = 0;\n  end\nendmodule",
    "difficulty": "easy",
    "category": "combinational_logic"
  },
  {
    "problem_number": 133,
    "problem_name": "2014_q3fsm",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  s\n - input  w\n - output z\n\nThe module should implement a finite state machine with inputs s and w.\nAssume that the FSM begins in a reset state called A, as depicted below.\nThe FSM remains in state A as long as s = 0, and it moves to state B when\ns = 1. Once in state B the FSM examines the value of the input w in the\nnext three clock cycles. If w = 1 in exactly two of these clock cycles,\nthen the FSM has to set an output z to 1 in the following clock cycle.\nOtherwise z has to be 0. The FSM continues checking w for the next three\nclock cycles, and so on. Use as few states as possible. Note that the s\ninput is used only in state A, so you need to consider just the w input.\nAssume reset is active high synchronous. Assume all sequential logic is\ntriggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input s,\n  input w,\n  output reg z\n);\n\n  parameter A=0, B=1, C=2, S10=3, S11=4, S20=5, S21=6, S22=7;\n  reg [2:0] state, next;\n\n  always @(posedge clk) begin\n    if (reset) state <= A;\n    else state <= next;\n  end\n\n  always_comb begin\n    case (state)\n      A: next = s ? B : A;\n      B: next = w ? S11 : S10;\n      C: next = w ? S11 : S10;\n      S10: next = w ? S21 : S20;\n      S11: next = w ? S22 : S21;\n      S20: next = B;\n      S21: next = w ? C : B;\n      S22: next = w ? B : C;\n      default: next = 'x;\n    endcase\n  end\n\n  assign z = (state == C);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input s,\n  input w,\n  output reg z\n);\n  parameter A=0, B=1, C=2, S10=3, S11=4, S20=5, S21=6, S22=7;\n  reg [2:0] state, next_state;\n  always @(posedge clk) begin\n    if (reset) state <= A;\n    else state <= next_state;\n  end\n  always @* begin\n    case (state)\n      A: next_state = s ? B : A;\n      B: next_state = w ? S11 : S10;\n      C: next_state = w ? S11 : S10;\n      S10: next_state = w ? S21 : S20;\n      S11: next_state = w ? S22 : S21;\n      S20: next_state = B;\n      S21: next_state = w ? C : B;\n      S22: next_state = w ? B : C;\n      default: next_state = 'x;\n    endcase\n  end\n  assign z = (state == C);\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input s,\n  input w,\n  output reg z\n);\n  parameter A=0, B=1, C=2, S10=3, S11=4, S20=5, S21=6, S22=7;\n  reg [2:0] state, next;\n  always @(posedge clk) begin\n    if (reset) state <= A;\n    else state <= next;\n  end\n  always_comb begin\n    case (state)\n      A: next = s ? B : A;\n      B: next = w ? S11 : S10;\n      C: next = w ? S11 : S10;\n      S10: next = w ? S21 : S20;\n      S11: next = w ? S22 : S21;\n      S20: next = B;\n      S21: next = w ? C : B;\n      S22: next = w ? B : C;\n      default: next = 'x;\n    endcase\n  end\n  assign z = (state == C);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 134,
    "problem_name": "2014_q3c",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  x\n - input  y (3 bits)\n - output Y0\n - output z\n\nThe module should implement the output logic and next state logic for an\nFSM using the table shown below. Note that the output Y0 is Y[0] of the\nnext state signal.\n\n   Present state input y[2:0] | Next state Y[2:0] when x=0, Next state Y[2:0] when x=1 | Output z\n   000 | 000, 001 | 0\n   001 | 001, 100 | 0\n   010 | 010, 001 | 0\n   011 | 001, 010 | 1\n   100 | 011, 100 | 1",
    "reference_implementation": "module RefModule (\n  input clk,\n  input x,\n  input [2:0] y,\n  output reg Y0,\n  output reg z\n);\n\n  always_comb begin\n    case ({y[2:0], x})\n      4'h0: Y0 = 0;\n      4'h1: Y0 = 1;\n      4'h2: Y0 = 1;\n      4'h3: Y0 = 0;\n      4'h4: Y0 = 0;\n      4'h5: Y0 = 1;\n      4'h6: Y0 = 1;\n      4'h7: Y0 = 0;\n      4'h8: Y0 = 1;\n      4'h9: Y0 = 0;\n      default: Y0 = 1'bx;\n    endcase\n\n    case (y[2:0])\n      3'h0: z = 0;\n      3'h1: z = 0;\n      3'h2: z = 0;\n      3'h3: z = 1;\n      3'h4: z = 1;\n      default: z = 1'bx;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input x,\n  input [2:0] y,\n  output reg Y0,\n  output reg z\n);\n  always_comb begin\n    case (y[2:0])\n      3'h0: z = 0;\n      3'h1: z = 0;\n      3'h2: z = 0;\n      3'h3: z = 1;\n      3'h4: z = 1;\n      default: z = 1'bx;\n    endcase\n    case ({y[2:0], x})\n      4'h0: Y0 = 0;\n      4'h1: Y0 = 1;\n      4'h2: Y0 = 1;\n      4'h3: Y0 = 0;\n      4'h4: Y0 = 0;\n      4'h5: Y0 = 1;\n      4'h6: Y0 = 1;\n      4'h7: Y0 = 0;\n      4'h8: Y0 = 1;\n      4'h9: Y0 = 0;\n      default: Y0 = 1'bx;\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input x,\n  input [2:0] y,\n  output reg Y0,\n  output reg z\n);\n  always_comb begin\n    case ({y[2:0], x})\n      4'h0: Y0 = 0;\n      4'h1: Y0 = 1;\n      4'h2: Y0 = 1;\n      4'h3: Y0 = 0;\n      4'h4: Y0 = 0;\n      4'h5: Y0 = 1;\n      4'h6: Y0 = 1;\n      4'h7: Y0 = 0;\n      4'h8: Y0 = 1;\n      4'h9: Y0 = 1;\n      default: Y0 = 1'bx;\n    endcase\n    case (y[2:0])\n      3'h0: z = 0;\n      3'h1: z = 0;\n      3'h2: z = 0;\n      3'h3: z = 1;\n      3'h4: z = 1;\n      default: z = 1'bx;\n    endcase\n  end\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 135,
    "problem_name": "m2014_q6b",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  y (3 bits)\n - input  w\n - output Y1\n\nThe module should implement the state machine shown below:\n\n  A (0) --0--> B\n  A (0) --1--> A\n  B (0) --0--> C\n  B (0) --1--> D\n  C (0) --0--> E\n  C (0) --1--> D\n  D (0) --0--> F\n  D (0) --1--> A\n  E (1) --0--> E\n  E (1) --1--> D\n  F (1) --0--> C\n  F (1) --1--> D\n\nThe FSM should be implemented using three flip-flops and state codes\ny = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement\njust the next-state logic for y[1]. The output Y1 is y[1].",
    "reference_implementation": "module RefModule (\n  input [2:0] y,\n  input w,\n  output reg Y1\n);\n\n  always_comb begin\n    case ({y, w})\n      4'h0: Y1 = 1'b0;\n      4'h1: Y1 = 1'b0;\n      4'h2: Y1 = 1'b1;\n      4'h3: Y1 = 1'b1;\n      4'h4: Y1 = 1'b0;\n      4'h5: Y1 = 1'b1;\n      4'h6: Y1 = 1'b0;\n      4'h7: Y1 = 1'b0;\n      4'h8: Y1 = 1'b0;\n      4'h9: Y1 = 1'b1;\n      4'ha: Y1 = 1'b1;\n      4'hb: Y1 = 1'b1;\n      default: Y1 = 1'bx;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input [2:0] y,\n  input w,\n  output reg Y1\n);\n  always_comb begin\n    case ({w, y})\n      4'b0_000: Y1 = 1'b0;\n      4'b1_000: Y1 = 1'b0;\n      4'b0_001: Y1 = 1'b1;\n      4'b1_001: Y1 = 1'b1;\n      4'b0_010: Y1 = 1'b0;\n      4'b1_010: Y1 = 1'b1;\n      4'b0_011: Y1 = 1'b0;\n      4'b1_011: Y1 = 1'b0;\n      4'b0_100: Y1 = 1'b0;\n      4'b1_100: Y1 = 1'b1;\n      4'b0_101: Y1 = 1'b1;\n      4'b1_101: Y1 = 1'b1;\n      default: Y1 = 1'bx;\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input [2:0] y,\n  input w,\n  output reg Y1\n);\n  always_comb begin\n    case ({y, w})\n      4'h0: Y1 = 1'b0;\n      4'h1: Y1 = 1'b0;\n      4'h2: Y1 = 1'b1;\n      4'h3: Y1 = 1'b0;\n      4'h4: Y1 = 1'b0;\n      4'h5: Y1 = 1'b1;\n      4'h6: Y1 = 1'b0;\n      4'h7: Y1 = 1'b0;\n      4'h8: Y1 = 1'b0;\n      4'h9: Y1 = 1'b1;\n      4'ha: Y1 = 1'b1;\n      4'hb: Y1 = 1'b1;\n      default: Y1 = 1'bx;\n    endcase\n  end\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 136,
    "problem_name": "m2014_q6",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  w\n - output z\n\nThe module should implement the state machine shown below:\n\n  A (0) --0--> B\n  A (0) --1--> A\n  B (0) --0--> C\n  B (0) --1--> D\n  C (0) --0--> E\n  C (0) --1--> D\n  D (0) --0--> F\n  D (0) --1--> A\n  E (1) --0--> E\n  E (1) --1--> D\n  F (1) --0--> C\n  F (1) --1--> D\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input w,\n  output z\n);\n\n  parameter A=0, B=1, C=2, D=3, E=4, F=5;\n  reg [2:0] state, next;\n\n  always @(posedge clk)\n    if (reset)\n      state <= A;\n    else\n      state <= next;\n\n  always_comb begin\n    case(state)\n      A: next = w ? A : B;\n      B: next = w ? D : C;\n      C: next = w ? D : E;\n      D: next = w ? A : F;\n      E: next = w ? D : E;\n      F: next = w ? D : C;\n      default: next = 'x;\n    endcase\n  end\n\n  assign z = (state == E || state == F);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  input w,\n  output z\n);\n  parameter A=0, B=1, C=2, D=3, E=4, F=5;\n  reg [2:0] state, next_state;\n  always @(posedge clk) begin\n    if (reset)\n      state <= A;\n    else\n      state <= next_state;\n  end\n  always @(*) begin\n    case (state)\n      A: next_state = w ? A : B;\n      B: next_state = w ? D : C;\n      C: next_state = w ? D : E;\n      D: next_state = w ? A : F;\n      E: next_state = w ? D : E;\n      F: next_state = w ? D : C;\n      default: next_state = 'x;\n    endcase\n  end\n  assign z = (state == E) | (state == F);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input reset,\n  input w,\n  output z\n);\n  parameter A=0, B=1, C=2, D=3, E=4, F=5;\n  reg [2:0] state, next;\n  always @(posedge clk)\n    if (reset)\n      state <= A;\n    else\n      state <= next;\n  always_comb begin\n    case(state)\n      A: next = w ? A : B;\n      B: next = w ? D : C;\n      C: next = w ? D : E;\n      D: next = w ? A : F;\n      E: next = w ? D : C;\n      F: next = w ? D : C;\n      default: next = 'x;\n    endcase\n  end\n  assign z = (state == E || state == F);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 137,
    "problem_name": "fsm_serial",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  in\n - output done\n\nIn many (older) serial communications protocols, each data byte is sent\nalong with a start bit and a stop bit, to help the receiver delimit bytes\nfrom the stream of bits. One common scheme is to use one start bit (0), 8\ndata bits, and 1 stop bit (1). The line is also at logic 1 when nothing\nis being transmitted (idle).\n\nImplement a finite state machine that will identify when bytes have been\ncorrectly received when given a stream of bits. It needs to identify the\nstart bit, wait for all 8 data bits, then verify that the stop bit was\ncorrect. If the stop bit does not appear when expected, the FSM must wait\nuntil it finds a stop bit before attempting to receive the next byte.\nInclude a active-high synchronous reset. Note that the serial protocol\nsends the least significant bit first.\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input in,\n  input reset,\n  output done\n);\n\n  parameter B0=0, B1=1, B2=2, B3=3, B4=4, B5=5, B6=6, B7=7, START=8, STOP=9, DONE=10, ERR=11;\n  reg [3:0] state;\n  reg [3:0] next;\n\n  always_comb begin\n    case (state)\n      START: next = in ? START : B0;  // start bit is 0\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = B4;\n      B4: next = B5;\n      B5: next = B6;\n      B6: next = B7;\n      B7: next = STOP;\n      STOP: next = in ? DONE : ERR;  // stop bit is 1. Idle state is 1.\n      DONE: next = in ? START : B0;\n      ERR: next = in ? START : ERR;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= START;\n      else state <= next;\n  end\n\n  assign done = (state==DONE);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input in,\n  input reset,\n  output done\n);\n  parameter B0=0, B1=1, B2=2, B3=3, B4=4, B5=5, B6=6, B7=7, START=8, STOP=9, DONE=10, ERR=11;\n  reg [3:0] state, next;\n  always_comb begin\n    case (state)\n      START: next = in ? START : B0;\n      B0:    next = B1;\n      B1:    next = B2;\n      B2:    next = B3;\n      B3:    next = B4;\n      B4:    next = B5;\n      B5:    next = B6;\n      B6:    next = B7;\n      B7:    next = STOP;\n      STOP:  next = in ? DONE : ERR;\n      DONE:  next = in ? START : B0;\n      ERR:   next = in ? START : ERR;\n      default: next = START;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= START;\n    else state <= next;\n  end\n  assign done = (state == DONE);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input in,\n  input reset,\n  output done\n);\n  parameter B0=0, B1=1, B2=2, B3=3, B4=4, B5=5, B6=6, B7=7, START=8, STOP=9, DONE=10, ERR=11;\n  reg [3:0] state;\n  reg [3:0] next;\n  always_comb begin\n    case (state)\n      START: next = in ? START : B0;\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = B4;\n      B4: next = B5;\n      B5: next = B6;\n      B6: next = B7;\n      B7: next = STOP;\n      STOP: next = in ? DONE : ERR;\n      DONE: next = in ? START : B0;\n      ERR: next = in ? ERR : START;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= START;\n    else state <= next;\n  end\n  assign done = (state==DONE);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 138,
    "problem_name": "2012_q2fsm",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  w\n - output z\n\nThe module should implement the state machine shown below:\n\n  A (0) --1--> B\n  A (0) --0--> A\n  B (0) --1--> C\n  B (0) --0--> D\n  C (0) --1--> E\n  C (0) --0--> D\n  D (0) --1--> F\n  D (0) --0--> A\n  E (1) --1--> E\n  E (1) --0--> D\n  F (1) --1--> C\n  F (1) --0--> D\n\nReset resets into state A and is synchronous active-high. Assume all\nsequential logic is triggered on the positive edge of the clock.\n\nUse separate always blocks for the state table and the state flip-flops.\nDescribe the FSM output, which is called _z_, using either continuous\nassignment statement(s) or an always block (at your discretion). Assign\nany state codes that you wish to use.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input w,\n  output z\n);\n\n  parameter A=0,B=1,C=2,D=3,E=4,F=5;\n  reg[2:0] state, next;\n\n  always @(posedge clk)\n    if (reset) state <= A;\n    else state <= next;\n\n  always_comb begin\n    case (state)\n      A: next = w ? B : A;\n      B: next = w ? C : D;\n      C: next = w ? E : D;\n      D: next = w ? F : A;\n      E: next = w ? E : D;\n      F: next = w ? C : D;\n      default: next = 'x;\n    endcase\n  end\n\n  assign z = (state == E) || (state == F);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input w,\n  output z\n);\n  parameter A=0,B=1,C=2,D=3,E=4,F=5;\n  reg[2:0] state, next_state;\n  always @(posedge clk) begin\n    if (reset) state <= A;\n    else state <= next_state;\n  end\n  always @(*) begin\n    case (state)\n      A: next_state = w ? B : A;\n      B: next_state = w ? C : D;\n      C: next_state = w ? E : D;\n      D: next_state = w ? F : A;\n      E: next_state = w ? E : D;\n      F: next_state = w ? C : D;\n      default: next_state = 'x;\n    endcase\n  end\n  assign z = (state == E) | (state == F);\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input w,\n  output z\n);\n  parameter A=0,B=1,C=2,D=3,E=4,F=5;\n  reg[2:0] state, next;\n  always @(posedge clk)\n    if (reset) state <= A;\n    else state <= next;\n  always_comb begin\n    case (state)\n      A: next = w ? B : A;\n      B: next = w ? C : D;\n      C: next = w ? E : D;\n      D: next = w ? F : A;\n      E: next = w ? E : D;\n      F: next = w ? C : A;\n      default: next = 'x;\n    endcase\n  end\n  assign z = (state == E) || (state == F);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 139,
    "problem_name": "2013_q2bfsm",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  resetn\n - input  x\n - input  y\n - output f\n - output g\n\nConsider a finite state machine that is used to control some type of\nmotor. The FSM has inputs x and y, which come from the motor, and\nproduces outputs f and g, which control the motor. There is also a clock\ninput called clk and a reset input (synchronous, active low) called\nresetn. The FSM has to work as follows. As long as the reset input is\nasserted, the FSM stays in a beginning state, called state A. When the\nreset signal is de-asserted, then after the next clock edge the FSM has\nto set the output f to 1 for one clock cycle. Then, the FSM has to\nmonitor the x input. When x has produced the values 1, 0, 1 in three\nsuccessive clock cycles, then g should be set to 1 on the following clock\ncycle. While maintaining g = 1 the FSM has to monitor the y input. If y\nhas the value 1 within at most two clock cycles, then the FSM should\nmaintain g = 1 permanently (that is, until reset). But if y does not\nbecome 1 within two clock cycles, then the FSM should set g = 0\npermanently (until reset). Assume all sequential logic is triggered on\nthe positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input resetn,\n  input x,\n  input y,\n  output f,\n  output g\n);\n\n  parameter A=0, B=1, S0=2, S1=3, S10=4, G1=5, G2=6, P0=7, P1=8;\n  reg [3:0] state, next;\n\n  always @(posedge clk) begin\n    if (~resetn) state <= A;\n    else state <= next;\n  end\n\n  always_comb begin\n    case (state)\n      A: next = B;\n      B: next = S0;\n      S0: next = x ? S1 : S0;\n      S1: next = x ? S1 : S10;\n      S10: next = x? G1 : S0;\n      G1: next = y ? P1 : G2;\n      G2: next = y ? P1 : P0;\n      P0: next = P0;\n      P1: next = P1;\n      default: next = 'x;\n    endcase\n  end\n\n  assign f = (state == B);\n  assign g = (state == G1) || (state == G2) || (state == P1);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input resetn,\n  input x,\n  input y,\n  output f,\n  output g\n);\n  parameter A=0, B=1, S0=2, S1=3, S10=4, G1=5, G2=6, P0=7, P1=8;\n  reg [3:0] state, next;\n  always @(posedge clk) begin\n    state <= ~resetn ? A : next;\n  end\n  always @(*) begin\n    case (state)\n      A: next = B;\n      B: next = S0;\n      S0: if (x) next = S1; else next = S0;\n      S1: next = x ? S1 : S10;\n      S10: next = x ? G1 : S0;\n      G1: next = y ? P1 : G2;\n      G2: next = y ? P1 : P0;\n      P0,P1: next = state;\n      default: next = 'x;\n    endcase\n  end\n  assign f = (state == B);\n  assign g = (state == P1) || (state == G1) || (state == G2);\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input resetn,\n  input x,\n  input y,\n  output f,\n  output g\n);\n  parameter A=0, B=1, S0=2, S1=3, S10=4, G1=5, G2=6, P0=7, P1=8;\n  reg [2:0] state, next;\n  always @(posedge clk) begin\n    if (~resetn) state <= A;\n    else state <= next;\n  end\n  always_comb begin\n    case (state)\n      A: next = B;\n      B: next = S0;\n      S0: next = x ? S1 : S0;\n      S1: next = x ? S1 : S10;\n      S10: next = x ? G1 : S0;\n      G1: next = y ? P1 : G2;\n      G2: next = y ? P1 : P0;\n      P0: next = P0;\n      P1: next = P1;\n      default: next = 'x;\n    endcase\n  end\n  assign f = (state == B);\n  assign g = (state == G1) || (state == G2) || (state == P1);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 140,
    "problem_name": "fsm_hdlc",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  in\n - output disc\n - output flag\n - output err\n\nSynchronous HDLC framing involves decoding a continuous bit stream of\ndata to look for bit patterns that indicate the beginning and end of\nframes (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a\n\"flag\" that indicate frame boundaries. To avoid the data stream from\naccidentally containing \"flags\", the sender inserts a zero after every 5\nconsecutive 1s which the receiver must detect and discard. We also need\nto signal an error if there are 7 or more consecutive 1s. Create a\nMoore-type finite state machine to recognize these three sequences:\n\n  (1) 0111110: Signal a bit needs to be discarded (disc).\n  (2) 01111110: Flag the beginning/end of a frame (flag).\n  (3) 01111111...: Error (7 or more 1s) (err).\n\nWhen the FSM is reset, it should be in a state that behaves as though the\nprevious input were 0. The reset signal is active high synchronous. The\noutput signals should be asserted for a complete cycle beginning on the\nclock cycle after the condition occurs. Assume all sequential\nlogic is triggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input in,\n  output disc,\n  output flag,\n  output err\n);\n\n  parameter [3:0] S0=0, S1=1, S2=2, S3=3, S4=4, S5=5, S6=6, SERR=7, SDISC=8, SFLAG=9;\n  reg [3:0] state, next;\n\n  assign disc = state == SDISC;\n  assign flag = state == SFLAG;\n  assign err = state == SERR;\n\n  always @(posedge clk) begin\n    case (state)\n      S0: state <= in ? S1 : S0;\n      S1: state <= in ? S2 : S0;\n      S2: state <= in ? S3 : S0;\n      S3: state <= in ? S4 : S0;\n      S4: state <= in ? S5 : S0;\n      S5: state <= in ? S6 : SDISC;\n      S6: state <= in ? SERR : SFLAG;\n      SERR: state <= in ? SERR : S0;\n      SFLAG: state <= in ? S1 : S0;\n      SDISC: state <= in ? S1 : S0;\n      default: state <= 'x;\n    endcase\n\n    if (reset) state <= S0;\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input in,\n  output disc,\n  output flag,\n  output err\n);\n  parameter [3:0] S0=0, S1=1, S2=2, S3=3, S4=4, S5=5, S6=6, SERR=7, SDISC=8, SFLAG=9;\n  reg [3:0] state, next;\n  assign disc = (state == SDISC);\n  assign flag = (state == SFLAG);\n  assign err  = (state == SERR);\n  always @(posedge clk) begin\n    if (reset) state <= S0;\n    else begin\n      case (state)\n        S0:    state <= in ? S1 : S0;\n        S1:    state <= in ? S2 : S0;\n        S2:    state <= in ? S3 : S0;\n        S3:    state <= in ? S4 : S0;\n        S4:    state <= in ? S5 : S0;\n        S5:    state <= in ? S6 : SDISC;\n        S6:    state <= in ? SERR : SFLAG;\n        SERR:  state <= in ? SERR : S0;\n        SFLAG: state <= in ? S1 : S0;\n        SDISC: state <= in ? S1 : S0;\n        default: state <= S0;\n      endcase\n    end\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input in,\n  output disc,\n  output flag,\n  output err\n);\n  parameter [3:0] S0=0, S1=1, S2=2, S3=3, S4=4, S5=5, S6=6, SERR=7, SDISC=8, SFLAG=9;\n  reg [3:0] state, next;\n  assign disc = state == SDISC;\n  assign flag = state == SFLAG;\n  assign err = state == SERR;\n  always @(posedge clk) begin\n    case (state)\n      S0: state <= in ? S1 : S0;\n      S1: state <= in ? S2 : S0;\n      S2: state <= in ? S3 : S0;\n      S3: state <= in ? S4 : S0;\n      S4: state <= in ? S5 : S0;\n      S5: state <= in ? S6 : SDISC;\n      S6: state <= in ? SERR : S0;\n      SERR: state <= in ? SERR : S0;\n      SFLAG: state <= in ? S1 : S0;\n      SDISC: state <= in ? S1 : S0;\n      default: state <= 'x;\n    endcase\n    if (reset) state <= S0;\n  end\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 141,
    "problem_name": "count_clock",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  ena\n - output pm\n - output hh (8 bits)\n - output mm (8 bits)\n - output ss (8 bits)\n\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm\nindicator). Your counters are clocked by a fast-running clk, with a pulse\non ena whenever your clock should increment (i.e., once per second, while\n\"clk\" is much faster than once per second). The signal \"pm\" is asserted\nif the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD\n(Binary- Coded Decimal) digits each for hours (01-12), minutes (00-59),\nand seconds (00-59). Reset is the active high synchronous signal that\nresets the clock to \"12:00 AM.\" Reset has higher priority than enable and\ncan occur even when not enabled. Assume all sequential logic is triggered\non the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input ena,\n  output reg pm,\n  output reg [7:0] hh,\n  output reg [7:0] mm,\n  output reg [7:0] ss\n);\n\n  wire [6:0] enable = {\n    {hh[7:0],mm[7:0],ss[7:0]}==24'h115959,\n    {hh[3:0],mm[7:0],ss[7:0]}==20'h95959,\n    {mm[7:0],ss[7:0]}==16'h5959,\n    {mm[3:0],ss[7:0]}==12'h959,\n    ss[7:0]==8'h59,\n    ss[3:0] == 4'h9,\n    1'b1};\n\n  always @(posedge clk)\n    if (reset)\n      {pm,hh,mm,ss} <= 25'h0120000;\n    else if (ena) begin\n      if (enable[0] && ss[3:0] == 9) ss[3:0] <= 0;\n      else if (enable[0]) ss[3:0] <= ss[3:0] + 1;\n\n      if (enable[1] && ss[7:4] == 4'h5) ss[7:4] <= 0;\n      else if (enable[1]) ss[7:4] <= ss[7:4] + 1;\n\n      if (enable[2] && mm[3:0] == 9) mm[3:0] <= 0;\n      else if (enable[2]) mm[3:0] <= mm[3:0] + 1;\n\n      if (enable[3] && mm[7:4] == 4'h5) mm[7:4] <= 0;\n      else if (enable[3]) mm[7:4] <= mm[7:4] + 1;\n\n      if (enable[4] && hh[3:0] == 4'h9) hh[3:0] <= 0;\n      else if (enable[4]) hh[3:0] <= hh[3:0] + 1;\n\n      if (enable[4] && hh[7:0] == 8'h12) hh[7:0] <= 8'h1;\n      else if (enable[5]) hh[7:4] <= hh[7:4] + 1;\n\n      if (enable[6]) pm <= ~pm;\n    end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  input ena,\n  output reg pm,\n  output reg [7:0] hh,\n  output reg [7:0] mm,\n  output reg [7:0] ss\n);\n\n  wire [6:0] enable = {\n    {hh[7:0],mm[7:0],ss[7:0]}==24'h115959,\n    {hh[3:0],mm[7:0],ss[7:0]}==20'h95959,\n    {mm[7:0],ss[7:0]}==16'h5959,\n    {mm[3:0],ss[7:0]}==12'h959,\n    ss[7:0]==8'h59,\n    ss[3:0] == 4'h9,\n    1'b1};\n\n  always @(posedge clk)\n    if (reset)\n      {pm,hh,mm,ss} <= 25'h0120000;\n    else if (ena) begin\n      if (enable[0] && ss[3:0] == 9) ss[3:0] <= 0;\n      else if (enable[0]) ss[3:0] <= ss[3:0] + 1;\n\n      if (enable[1] && ss[7:4] == 4'h5) ss[7:4] <= 0;\n      else if (enable[1]) ss[7:4] <= ss[7:4] + 1;\n\n      if (enable[2] && mm[3:0] == 9) mm[3:0] <= 0;\n      else if (enable[2]) mm[3:0] <= mm[3:0] + 1;\n\n      if (enable[3] && mm[7:4] == 4'h5) mm[7:4] <= 0;\n      else if (enable[3]) mm[7:4] <= mm[7:4] + 1;\n\n      if (enable[4] && hh[3:0] == 4'h9) hh[3:0] <= 0;\n      else if (enable[4]) hh[3:0] <= hh[3:0] + 1;\n\n      if (enable[4] && hh[7:0] == 8'h12) hh[7:0] <= 8'h01;\n      else if (enable[5]) hh[7:4] <= hh[7:4] + 1;\n\n      if (enable[6]) pm <= ~pm;\n    end\n\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input ena,\n  output reg pm,\n  output reg [7:0] hh,\n  output reg [7:0] mm,\n  output reg [7:0] ss\n);\n  wire [6:0] enable = {\n    {hh[7:0],mm[7:0],ss[7:0]}==24'h115959,\n    {hh[3:0],mm[7:0],ss[7:0]}==20'h95959,\n    {mm[7:0],ss[7:0]}==16'h5959,\n    {mm[3:0],ss[7:0]}==12'h959,\n    ss[7:0]==8'h59,\n    ss[3:0] == 4'h9,\n    1'b1};\n  always @(posedge clk)\n    if (reset)\n      {pm,hh,mm,ss} <= 25'h0120000;\n    else if (ena) begin\n      if (enable[0] && ss[3:0] == 9) ss[3:0] <= 0;\n      else if (enable[0]) ss[3:0] <= ss[3:0] + 1;\n      if (enable[1] && ss[7:4] == 4'h5) ss[7:4] <= 0;\n      else if (enable[1]) ss[7:4] <= ss[7:4] + 1;\n      if (enable[2] && mm[3:0] == 9) mm[3:0] <= 0;\n      else if (enable[2]) mm[3:0] <= mm[3:0] + 1;\n      if (enable[3] && mm[7:4] == 4'h5) mm[7:4] <= 0;\n      else if (enable[3]) mm[7:4] <= mm[7:4] + 1;\n      if (enable[4] && hh[3:0] == 4'h9) hh[3:0] <= 0;\n      else if (enable[4]) hh[3:0] <= hh[3:0] + 1;\n      if (enable[5] && hh[7:0] == 8'h12) hh[7:0] <= 8'h1;\n      if (enable[6]) pm <= ~pm;\n    end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 142,
    "problem_name": "lemmings2",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  bump_left\n - input  bump_right\n - input  ground\n - output walk_left\n - output walk_right\n - output aaah\n\nThe game Lemmings involves critters with fairly simple brains. So simple\nthat we are going to model it using a finite state machine. In the\nLemmings' 2D world, Lemmings can be in one of two states: walking left\n(walk_left is 1) or walking right (walk_right is 1). It will switch\ndirections if it hits an obstacle. In particular, if a Lemming is bumped\non the left (by receiving a 1 on bump_left), it will walk right. If it's\nbumped on the right (by receiving a 1 on bump_right), it will walk left.\nIf it's bumped on both sides at the same time, it will still switch\ndirections.\n\nIn addition to walking left and right and changing direction when bumped,\nwhen ground=0, the Lemming will fall and say \"aaah!\". When the ground\nreappears (ground=1), the Lemming will resume walking in the same\ndirection as before the fall. Being bumped while falling does not affect\nthe walking direction, and being bumped in the same cycle as ground\ndisappears (but not yet falling), or when the ground reappears while\nstill falling, also does not affect the walking direction.\n\nImplement a Moore state machine that models this behaviour. areset is\npositive edge triggered asynchronous reseting the Lemming machine to walk\nleft. Assume all sequential logic is triggered on the positive edge of\nthe clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  output walk_left,\n  output walk_right,\n  output aaah\n);\n\n  parameter WL=0, WR=1, FALLL=2, FALLR=3;\n  reg [1:0] state;\n  reg [1:0] next;\n\n  always_comb begin\n    case (state)\n      WL: next = ground ? (bump_left ? WR : WL) : FALLL;\n      WR: next = ground ? (bump_right ? WL: WR) : FALLR;\n      FALLL: next = ground ? WL : FALLL;\n      FALLR: next = ground ? WR : FALLR;\n    endcase\n  end\n\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n      else state <= next;\n  end\n\n  assign walk_left = (state==WL);\n  assign walk_right = (state==WR);\n  assign aaah = (state == FALLL) || (state == FALLR);\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  output walk_left,\n  output walk_right,\n  output aaah\n);\n  parameter WL=0, WR=1, FALLL=2, FALLR=3;\n  reg [1:0] state, next;\n  always_comb\n    case (state)\n      WL: next = !ground ? FALLL : (bump_left ? WR : WL);\n      WR: next = !ground ? FALLR : (bump_right ? WL : WR);\n      FALLL: next = ground ? WL : FALLL;\n      FALLR: next = ground ? WR : FALLR;\n    endcase\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n    else state <= next;\n  end\n  assign walk_left = (state == WL);\n  assign walk_right = (state == WR);\n  assign aaah = (state == FALLL) || (state == FALLR);\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  output walk_left,\n  output walk_right,\n  output aaah\n);\n  parameter WL=0, WR=1, FALLL=2, FALLR=3;\n  reg [1:0] state;\n  reg [1:0] next;\n  always_comb begin\n    case (state)\n      WL: next = ground ? (bump_left ? WR : WL) : FALLL;\n      WR: next = ground ? (bump_right ? WL : WR) : FALLR;\n      FALLL: next = ground ? WL : FALLL;\n      FALLR: next = ground ? WR : FALLL;\n    endcase\n  end\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n      else state <= next;\n  end\n  assign walk_left = (state==WL);\n  assign walk_right = (state==WR);\n  assign aaah = (state == FALLL) || (state == FALLR);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 143,
    "problem_name": "fsm_onehot",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  in\n - input  state (10 bits)\n - output next_state (10 bits)\n - output out1\n - output out2\n\nGiven the follow state machine with 1 input and 2 outputs (the outputs\nare given as \"(out1, out2)\"):\n\n  S0 (0, 0) --0--> S0\n  S0 (0, 0) --1--> S1\n  S1 (0, 0) --0--> S0\n  S1 (0, 0) --1--> S2\n  S2 (0, 0) --0--> S0\n  S2 (0, 0) --1--> S3\n  S3 (0, 0) --0--> S0\n  S3 (0, 0) --1--> S4\n  S4 (0, 0) --0--> S0\n  S4 (0, 0) --1--> S5\n  S5 (0, 0) --0--> S8\n  S5 (0, 0) --1--> S6\n  S6 (0, 0) --0--> S9\n  S6 (0, 0) --1--> S7\n  S7 (0, 1) --0--> S0\n  S7 (0, 1) --1--> S7\n  S8 (1, 0) --0--> S0\n  S8 (1, 0) --1--> S1\n  S9 (1, 1) --0--> S0\n  S9 (1, 1) --1--> S1\n\nSuppose this state machine uses one-hot encoding, where state[0] through\nstate[9] correspond to the states S0 though S9, respectively. The outputs\nare zero unless otherwise specified. The next_state[0] through next_state[9] \ncorrespond to the transition to next states S0 though S9. For example, The \nnext_state[1] is set to 1 when the next state is S1 , otherwise, it is set to 0.\n\nHere, the input state[9:0] can be a combinational of multiple states, and \nthe TopModule is expected to response.\nFor example: \nWhen the state[9:0] = 10'b0000010100, state[4] == 1, and state[2] == 1, the \nstates includes S4, and S2 states.\n\nThe module should implement the state transition logic and output logic\nportions of the state machine (but not the state flip-flops). You are\ngiven the current state in state[9:0] and must implement next_state[9:0] \nand the two outputs.",
    "reference_implementation": "module RefModule (\n  input in,\n  input [9:0] state,\n  output [9:0] next_state,\n  output out1,\n  output out2\n);\n\n  assign out1 = state[8] | state[9];\n  assign out2 = state[7] | state[9];\n\n  assign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n  assign next_state[1] = in && (state[0] | state[8] | state[9]);\n  assign next_state[2] = in && state[1];\n  assign next_state[3] = in && state[2];\n  assign next_state[4] = in && state[3];\n  assign next_state[5] = in && state[4];\n  assign next_state[6] = in && state[5];\n  assign next_state[7] = in && (state[6] | state[7]);\n  assign next_state[8] = !in && state[5];\n  assign next_state[9] = !in && state[6];\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input in,\n  input [9:0] state,\n  output [9:0] next_state,\n  output out1,\n  output out2\n);\n  assign out1 = state[8] | state[9];\n  assign out2 = state[9] | state[7];\n  assign next_state[0] = (|state[4:0] | state[7] | state[8] | state[9]) && !in;\n  assign next_state[1] = (state[0] | state[8] | state[9]) && in;\n  assign next_state[2] = state[1] && in;\n  assign next_state[3] = state[2] && in;\n  assign next_state[4] = state[3] && in;\n  assign next_state[5] = state[4] && in;\n  assign next_state[6] = state[5] && in;\n  assign next_state[7] = (state[6] | state[7]) && in;\n  assign next_state[8] = state[5] && !in;\n  assign next_state[9] = state[6] && !in;\nendmodule",
    "buggy_implementation": "module TopModule (\n  input in,\n  input [9:0] state,\n  output [9:0] next_state,\n  output out1,\n  output out2\n);\n  assign out1 = state[8] | state[9];\n  assign out2 = state[7];\n  assign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n  assign next_state[1] = in && (state[0] | state[8] | state[9]);\n  assign next_state[2] = in && state[1];\n  assign next_state[3] = in && state[2];\n  assign next_state[4] = in && state[3];\n  assign next_state[5] = in && state[4];\n  assign next_state[6] = in && state[5];\n  assign next_state[7] = in && (state[6] | state[7]);\n  assign next_state[8] = !in && state[5];\n  assign next_state[9] = !in && state[6];\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 144,
    "problem_name": "conwaylife",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  load\n - input  data (256 bits)\n - output q (256 bits)\n\nThe module should implemement a \"game\" played on a two-dimensional grid\nof cells, where each cell is either 1 (alive) or 0 (dead). At each time\nstep, each cell changes state depending on how many neighbours it has:\n\n  (1) 0-1 neighbour: Cell becomes 0.\n  (2) 2 neighbours: Cell state does not change.\n  (3) 3 neighbours: Cell becomes 1.\n  (4) 4+ neighbours: Cell becomes 0.\n\nThe game is formulated for an infinite grid. In this circuit, we will use\na 16x16 grid. To make things more interesting, we will use a 16x16\ntoroid, where the sides wrap around to the other side of the grid. For\nexample, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15),\n(0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by\na length 256 vector, where each row of 16 cells is represented by a\nsub-vector: q[15:0] is row 0, q[31:16] is row 1, etc.\n\n  (1) load: Loads data into q at the next clock edge, for loading initial\n       state. Active high synchronous.\n  (2) q: The 16x16 current state of the game, updated every clock cycle.\n\nThe game state should advance by one timestep every clock cycle. Assume\nall sequential logic is triggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input load,\n  input [255:0] data,\n  output reg [255:0] q\n);\n\n  logic [323:0] q_pad;\n  always@(*) begin\n    for (int i=0;i<16;i++)\n      q_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];\n    q_pad[1 +: 16] = q[16*15 +: 16];\n    q_pad[18*17+1 +: 16] = q[0 +: 16];\n\n    for (int i=0; i<18; i++) begin\n      q_pad[i*18] = q_pad[i*18+16];\n      q_pad[i*18+17] = q_pad[i*18+1];\n    end\n  end\n\n  always @(posedge clk) begin\n    for (int i=0;i<16;i++)\n    for (int j=0;j<16;j++) begin\n      q[i*16+j] <=\n        ((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n        q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n        q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18]) & 3'h7 | q[i*16+j]) == 3'h3;\n    end\n\n    if (load)\n      q <= data;\n\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input load,\n  input [255:0] data,\n  output reg [255:0] q\n);\n\n  reg [323:0] q_pad;\n  integer i, j;\n\n  always @(*) begin\n    // Padding the grid with wrap-around for toroidal effect\n    for (i = 0; i < 16; i = i + 1) begin\n      q_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];\n    end\n    q_pad[1 +: 16] = q[16*15 +: 16];\n    q_pad[18*17+1 +: 16] = q[0 +: 16];\n\n    for (i = 0; i < 18; i = i + 1) begin\n      q_pad[i*18] = q_pad[i*18+16];\n      q_pad[i*18+17] = q_pad[i*18+1];\n    end\n  end\n\n  always @(posedge clk) begin\n    if (load) begin\n      q <= data;\n    end else begin\n      for (i = 0; i < 16; i = i + 1) begin\n        for (j = 0; j < 16; j = j + 1) begin\n          integer neighbors;\n          neighbors = q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n                      q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n                      q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18];\n          if (neighbors == 3 || (neighbors == 2 && q[i*16+j]))\n            q[i*16+j] <= 1;\n          else\n            q[i*16+j] <= 0;\n        end\n      end\n    end\n  end\n\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input load,\n  input [255:0] data,\n  output reg [255:0] q\n);\n  logic [323:0] q_pad;\n  always @(*) begin\n    for (int i=0;i<16;i++)\n      q_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];\n    q_pad[1 +: 16] = q[16*15 +: 16];\n    q_pad[18*17+1 +: 16] = q[0 +: 16];\n    for (int i=0; i<18; i++) begin\n      q_pad[i*18] = q_pad[i*18+16];\n      q_pad[i*18+17] = q_pad[i*18+1];\n    end\n  end\n  always @(posedge clk) begin\n    for (int i=0;i<16;i++)\n    for (int j=0;j<16;j++) begin\n      q[i*16+j] <=\n        ((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n        q_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n        q_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18]) & 3'h7 | q[i*16+j]) == 3'h3;\n    end\n    if (load)\n      q <= data;\n  end\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 145,
    "problem_name": "circuit8",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clock\n - input  a\n - output p\n - output q\n\nThe module should implement a sequential circuit. Read the simulation\nwaveforms to determine what the circuit does, then implement it.\n\n  time   clock   a   p   q\n  0ns    0       0   x   x\n  5ns    0       0   x   x\n  10ns   0       0   x   x\n  15ns   0       0   x   x\n  20ns   0       0   x   x\n  25ns   1       0   0   x\n  30ns   1       0   0   x\n  35ns   1       0   0   x\n  40ns   1       0   0   x\n  45ns   1       0   0   x\n  50ns   1       0   0   x\n  55ns   0       0   0   0\n  60ns   0       0   0   0\n  65ns   0       0   0   0\n  70ns   0       1   0   0\n  75ns   0       0   0   0\n  80ns   0       1   0   0\n  85ns   1       0   0   0\n  90ns   1       1   1   0\n  95ns   1       0   0   0\n  100ns  1       1   1   0\n  105ns  1       0   0   0\n  110ns  1       1   1   0\n  115ns  0       0   1   1\n  120ns  0       1   1   1\n  125ns  0       0   1   1\n  130ns  0       1   1   1\n  135ns  0       0   1   1\n  140ns  0       0   1   1\n  145ns  1       0   0   1\n  150ns  1       0   0   1\n  155ns  1       0   0   1\n  160ns  1       0   0   1\n  165ns  1       1   1   1\n  170ns  1       0   0   1\n  175ns  0       1   0   0\n  180ns  0       0   0   0\n  185ns  0       1   0   0\n  190ns  0       0   0   0",
    "reference_implementation": "module RefModule (\n  input clock,\n  input a,\n  output reg p,\n  output reg q\n);\n\n  always @(negedge clock)\n    q <= a;\n\n  always @(*)\n    if (clock)\n      p = a;\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clock,\n  input a,\n  output reg p,\n  output reg q\n);\n\n  always @(negedge clock)\n    q <= a;\n\n  always @(*)\n    if (clock)\n      p = a;\n\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clock,\n  input a,\n  output reg p,\n  output reg q\n);\n  always @(negedge clock)\n    q <= ~a;\n  always @(*)\n    if (clock)\n      p = a;\nendmodule",
    "difficulty": "easy",
    "category": "sequential_logic"
  },
  {
    "problem_number": 146,
    "problem_name": "fsm_serialdata",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  in\n - input  reset\n - output out_byte (8 bits)\n - output done\n\nIn many (older) serial communications protocols, each data byte is sent\nalong with a start bit and a stop bit, to help the receiver delimit bytes\nfrom the stream of bits. One common scheme is to use one start bit (0), 8\ndata bits, and 1 stop bit (1). The line is also at logic 1 when nothing\nis being transmitted (idle). Design a finite state machine that will\nidentify when bytes have been correctly received when given a stream of\nbits. It needs to identify the start bit, wait for all 8 data bits, then\nverify that the stop bit was correct. The module will also output the\ncorrectly-received data byte. `out_byte` needs to be valid when `done` is\n1, and is don't-care otherwise. If the stop bit does not appear when\nexpected, the FSM must wait until it finds a stop bit before attempting\nto receive the next byte. Include a active-high synchronous reset. Note\nthat the serial protocol sends the least significant bit first. It should\nassert done each time it finds a stop bit. Assume all sequential logic is\ntriggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input in,\n  input reset,\n  output [7:0] out_byte,\n  output done\n);\n\n  parameter B0=0, B1=1, B2=2, B3=3, B4=4, B5=5, B6=6, B7=7, START=8, STOP=9, DONE=10, ERR=11;\n  reg [3:0] state;\n  reg [3:0] next;\n\n  reg [9:0] byte_r;\n\n  always_comb begin\n    case (state)\n      START: next = in ? START : B0;  // start bit is 0\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = B4;\n      B4: next = B5;\n      B5: next = B6;\n      B6: next = B7;\n      B7: next = STOP;\n      STOP: next = in ? DONE : ERR;  // stop bit is 1. Idle state is 1.\n      DONE: next = in ? START : B0;\n      ERR: next = in ? START : ERR;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= START;\n      else state <= next;\n  end\n\n  always @(posedge clk) begin\n    byte_r <= {in, byte_r[9:1]};\n  end\n\n  assign done = (state==DONE);\n  assign out_byte = done ? byte_r[8:1] : 8'hx;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input in,\n  input reset,\n  output [7:0] out_byte,\n  output done\n);\n  parameter B0=0, B1=1, B2=2, B3=3, B4=4, B5=5, B6=6, B7=7, START=8, STOP=9, DONE=10, ERR=11;\n  reg [3:0] state;\n  reg [3:0] next;\n  reg [9:0] byte_r;\n  always @(*) begin\n    case (state)\n      START: next = in ? START : B0;\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = B4;\n      B4: next = B5;\n      B5: next = B6;\n      B6: next = B7;\n      B7: next = STOP;\n      STOP: next = in ? DONE : ERR;\n      DONE: next = in ? START : B0;\n      ERR: next = in ? START : ERR;\n      default: next = START;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= START;\n    else state <= next;\n    byte_r <= {in, byte_r[9:1]};\n  end\n  assign done = (state==DONE);\n  assign out_byte = done ? byte_r[8:1] : 8'hx;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input in,\n  input reset,\n  output [7:0] out_byte,\n  output done\n);\n  parameter B0=0, B1=1, B2=2, B3=3, B4=4, B5=5, B6=6, B7=7, START=8, STOP=9, DONE=10, ERR=11;\n  reg [3:0] state;\n  reg [3:0] next;\n  reg [9:0] byte_r;\n  always_comb begin\n    case (state)\n      START: next = in ? START : B0;\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = B4;\n      B4: next = B5;\n      B5: next = B6;\n      B6: next = B7;\n      B7: next = STOP;\n      STOP: next = in ? DONE : ERR;\n      DONE: next = in ? START : B0;\n      ERR: next = in ? START : B0;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= START;\n      else state <= next;\n  end\n  always @(posedge clk) begin\n    byte_r <= {in, byte_r[9:1]};\n  end\n  assign done = (state==DONE);\n  assign out_byte = done ? byte_r[8:1] : 8'hx;\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 147,
    "problem_name": "circuit10",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  a\n - input  b\n - output q\n - output state\n\nThe module should implement a sequential circuit. The circuit consists of\ncombinational logic and one bit of memory (i.e., one flip-flop). The\noutput of the flip-flop has been made observable through the output\nstate. Assume all sequential logic is triggered on the positive edge of\nthe clock.\n\nRead the simulation waveforms to determine what the circuit does, then\nimplement it.\n\n  time   clk a   b   state q\n  0ns    0   1   x   x     x\n  5ns    1   1   x   x     x\n  10ns   0   0   0   x     x\n  15ns   1   0   0   0     0\n  20ns   0   0   0   0     0\n  25ns   1   0   0   0     0\n  30ns   0   0   0   0     0\n  35ns   1   0   0   0     0\n  40ns   0   0   0   0     0\n  45ns   1   0   1   0     1\n  50ns   0   0   1   0     1\n  55ns   1   1   0   0     1\n  60ns   0   1   0   0     1\n  65ns   1   1   1   0     0\n  70ns   0   1   1   0     0\n  75ns   1   0   0   1     1\n  80ns   0   0   0   1     1\n  85ns   1   1   1   0     0\n  90ns   0   1   1   0     0\n  95ns   1   1   1   1     1\n  100ns  0   1   1   1     1\n  105ns  1   1   1   1     1\n  110ns  0   1   1   1     1\n  115ns  1   1   0   1     0\n  120ns  0   1   0   1     0\n  125ns  1   0   1   1     0\n  130ns  0   0   1   1     0\n  135ns  1   0   0   1     1\n  140ns  0   0   0   1     1\n  145ns  1   0   0   0     0\n  150ns  0   0   0   0     0\n  155ns  1   0   0   0     0\n  160ns  0   0   0   0     0\n  165ns  1   0   0   0     0\n  170ns  0   0   0   0     0\n  175ns  1   0   0   0     0\n  180ns  0   0   0   0     0\n  185ns  1   0   0   0     0\n  190ns  0   0   0   0     0",
    "reference_implementation": "module RefModule (\n  input clk,\n  input a,\n  input b,\n  output q,\n  output state\n);\n\n  reg c;\n  always @(posedge clk)\n    c <= a&b | a&c | b&c;\n\n  assign q = a^b^c;\n  assign state = c;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input a,\n  input b,\n  output q,\n  output state\n);\n  reg c;\n  always @(posedge clk)\n    c <= (a & b) | (a & c) | (b & c);\n  assign state = c;\n  assign q = a ^ b ^ c;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input a,\n  input b,\n  output q,\n  output state\n);\n  reg c;\n  always @(posedge clk)\n    c <= a & b | a & c;\n  assign q = a ^ b ^ c;\n  assign state = c;\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 148,
    "problem_name": "2013_q2afsm",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  resetn\n - input  r (3 bits)\n - output g (3 bits)\n\nThe module should implement the FSM described by the state diagram shown\nbelow:\n\n  A        --r0=0,r1=0,r2=0--> A\n  A        -------r0=1-------> B\n  A        -----r0=0,r1=1----> C\n  A        --r0=0,r1=0,r2=0--> D\n  B (g0=1) -------r0=1-------> B\n  B (g0=1) -------r0=0-------> A\n  C (g1=1) -------r1=1-------> C\n  C (g1=1) -------r1=0-------> A\n\nResetn is an active-low synchronous reset that resets into state A. This\nFSM acts as an arbiter circuit, which controls access to some type of\nresource by three requesting devices. Each device makes its request for\nthe resource by setting a signal _r[i]_ = 1, where _r[i]_ is either\n_r[0]_, _r[1]_, or _r[2]_. Each r[i] is an input signal to the FSM, and\nrepresents one of the three devices. The FSM stays in state _A_ as long\nas there are no requests. When one or more request occurs, then the FSM\ndecides which device receives a grant to use the resource and changes to\na state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an\noutput from the FSM. There is a priority system, in that device 0 has a\nhigher priority than device 1, and device 2 has the lowest priority.\nHence, for example, device 2 will only receive a grant if it is the only\ndevice making a request when the FSM is in state _A_. Once a device, _i_,\nis given a grant by the FSM, that device continues to receive the grant\nas long as its request, _r[i]_ = 1.\n\nImplement a module that represents this FSM. Use separate always blocks\nfor the state table and the state flip-flops, as done in lectures.\nDescribe the FSM outputs, _g[i]_, using either continuous assignment\nstatement(s) or an always block (at your discretion). Assign any state\ncodes that you wish to use. Assume all sequential logic is triggered on\nthe positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input resetn,\n  input  [2:0] r,\n  output [2:0] g\n);\n\n  parameter A=0, B=1, C=2, D=3;\n  reg [1:0] state, next;\n\n  always @(posedge clk) begin\n    if (~resetn) state <= A;\n    else state <= next;\n  end\n\n  always@(state,r) begin\n    case (state)\n      A: if (r[0]) next = B;\n         else if (r[1]) next = C;\n         else if (r[2]) next = D;\n         else next = A;\n      B: next = r[0] ? B : A;\n      C: next = r[1] ? C : A;\n      D: next = r[2] ? D : A;\n      default: next = 'x;\n    endcase\n  end\n\n  assign g[0] = (state == B);\n  assign g[1] = (state == C);\n  assign g[2] = (state == D);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input resetn,\n  input [2:0] r,\n  output [2:0] g\n);\n  parameter A=0, B=1, C=2, D=3;\n  reg [1:0] state, next_state;\n  always @(posedge clk) begin\n    if (~resetn) state <= A;\n    else state <= next_state;\n  end\n  always @(*) begin\n    case (state)\n      A: begin\n           if (r[0]) next_state = B;\n           else if (r[1]) next_state = C;\n           else if (r[2]) next_state = D;\n           else next_state = A;\n         end\n      B: next_state = r[0] ? B : A;\n      C: next_state = r[1] ? C : A;\n      D: next_state = r[2] ? D : A;\n      default: next_state = A;\n    endcase\n  end\n  assign g = {state==D, state==C, state==B};\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input resetn,\n  input [2:0] r,\n  output [2:0] g\n);\n  parameter A=0, B=1, C=2, D=3;\n  reg [1:0] state, next;\n  always @(posedge clk) begin\n    if (~resetn) state <= A;\n    else state <= next;\n  end\n  always@(state,r) begin\n    case (state)\n      A: if (r[0]) next = B;\n         else if (r[1]) next = C;\n         else if (r[2]) next = D;\n         else next = A;\n      B: next = r[0] ? B : A;\n      C: next = r[1] ? C : A;\n      D: next = r[0] ? D : A;\n      default: next = 'x;\n    endcase\n  end\n  assign g[0] = (state == B);\n  assign g[1] = (state == C);\n  assign g[2] = (state == D);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 149,
    "problem_name": "ece241_2013_q4",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  s (3 bits)\n - output fr2\n - output fr1\n - output fr0\n - output dfr\n\nA large reservior of water serves several users. In order to keep the\nlevel of water succificently high, three sensors are placed vertically at\n5-inch intervals. When the water level is above the highest sensor s[2],\nthe input flow rate should be zero. When the level is below the lowest\nsensor s[0], the flow rate should be at maximum (both Nominal flow valve\nand Supplemental flow valve opened). The flow rate when the level is\nbetween the upper and lower sensors is determined by two factors: the\nwater level and the level previous to the last sensor change. Each water\nlevel has a nominal flow rate associated with it as show in the table\nbelow. If the sensor change indicates that the previous level was lower\nthan the current level, the flow rate should be increased by opening the\nSupplemental flow valve (controlled by dfr).\n\n  Water Level           | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n  Above s[2]            | s[0], s[1], s[2] | None\n  Between s[2] and s[1] | s[0], s[1]       | fr0\n  Between s[1] and s[0] | s[0]             | fr0, fr1\n  Below s[0]            | None             | fr0, fr1, fr2\n\nAlso include an active-high synchronous reset that resets the state\nmachine to a state equivalent to if the water level had been low for a\nlong time (no sensors asserted, and all four outputs asserted).",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input [2:0] s,\n  output reg fr2,\n  output reg fr1,\n  output reg fr0,\n  output reg dfr\n);\n\n  parameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;\n  reg [2:0] state, next;\n\n  always @(posedge clk) begin\n    if (reset) state <= A2;\n    else state <= next;\n  end\n\n  always@(*) begin\n    case (state)\n      A2: next = s[0] ? B1 : A2;\n      B1: next = s[1] ? C1 : (s[0] ? B1 : A2);\n      B2: next = s[1] ? C1 : (s[0] ? B2 : A2);\n      C1: next = s[2] ? D1 : (s[1] ? C1 : B2);\n      C2: next = s[2] ? D1 : (s[1] ? C2 : B2);\n      D1: next = s[2] ? D1 : C2;\n      default: next = 'x;\n    endcase\n  end\n  reg [3:0] fr;\n  assign {fr2, fr1, fr0, dfr} = fr;\n  always_comb begin\n    case (state)\n      A2: fr = 4'b1111;\n      B1: fr = 4'b0110;\n      B2: fr = 4'b0111;\n      C1: fr = 4'b0010;\n      C2: fr = 4'b0011;\n      D1: fr = 4'b0000;\n      default: fr = 'x;\n    endcase\n  end\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input [2:0] s,\n  output reg fr2,\n  output reg fr1,\n  output reg fr0,\n  output reg dfr\n);\n  parameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;\n  reg [2:0] state, next_state;\n  always @(posedge clk) begin\n    if (reset) state <= A2;\n    else state <= next_state;\n  end\n  always @(*) begin\n    case (state)\n      A2: next_state = s[0] ? B1 : A2;\n      B1: next_state = s[1] ? C1 : (s[0] ? B1 : A2);\n      B2: next_state = s[1] ? C1 : (s[0] ? B2 : A2);\n      C1: next_state = s[2] ? D1 : (s[1] ? C1 : B2);\n      C2: next_state = s[2] ? D1 : (s[1] ? C2 : B2);\n      D1: next_state = s[2] ? D1 : C2;\n      default: next_state = 'x;\n    endcase\n  end\n  always @(*) begin\n    case (state)\n      A2: {fr2, fr1, fr0, dfr} = 4'b1111;\n      B1: {fr2, fr1, fr0, dfr} = 4'b0110;\n      B2: {fr2, fr1, fr0, dfr} = 4'b0111;\n      C1: {fr2, fr1, fr0, dfr} = 4'b0010;\n      C2: {fr2, fr1, fr0, dfr} = 4'b0011;\n      D1: {fr2, fr1, fr0, dfr} = 4'b0000;\n      default: {fr2, fr1, fr0, dfr} = 'x;\n    endcase\n  end\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input [2:0] s,\n  output reg fr2,\n  output reg fr1,\n  output reg fr0,\n  output reg dfr\n);\n  parameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;\n  reg [2:0] state, next;\n  always @(posedge clk) begin\n    if (reset) state <= A2;\n    else state <= next;\n  end\n  always @(*) begin\n    case (state)\n      A2: next = s[0] ? B1 : A2;\n      B1: next = s[1] ? C1 : (s[0] ? B1 : A2);\n      B2: next = s[1] ? C1 : (s[0] ? B2 : A2);\n      C1: next = s[2] ? D1 : (s[1] ? C1 : B2);\n      C2: next = s[2] ? D1 : (s[1] ? C2 : B2);\n      D1: next = s[2] ? D1 : C2;\n      default: next = 'x;\n    endcase\n  end\n  always @(*) begin\n    case (state)\n      A2: {fr2, fr1, fr0, dfr} = 4'b1111;\n      B1: {fr2, fr1, fr0, dfr} = 4'b0110;\n      B2: {fr2, fr1, fr0, dfr} = 4'b0111;\n      C1: {fr2, fr1, fr0, dfr} = 4'b0010;\n      C2: {fr2, fr1, fr0, dfr} = 4'b0011;\n      D1: {fr2, fr1, fr0, dfr} = 4'b0001;\n      default: {fr2, fr1, fr0, dfr} = 'x;\n    endcase\n  end\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 151,
    "problem_name": "review2015_fsm",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  data\n - input  done_counting\n - input  ack\n - output shift_ena\n - output counting\n - output done\n\nThe module should implement a timer that:\n\n  (1) is started when a particular pattern (1101) is detected,\n  (2) shifts in 4 more bits to determine the duration to delay,\n  (3) waits for the counters to finish counting, and\n  (4) notifies the user and waits for the user to acknowledge the timer.\n\nIn this problem, implement just the finite-state machine that controls\nthe timer. The data path (counters and some comparators) are not included\nhere.\n\nThe serial data is available on the data input pin. When the pattern 1101\nis received, the state machine must then assert output shift_ena for\nexactly 4 clock cycles. After that, the state machine asserts its\ncounting output to indicate it is waiting for the counters, and waits\nuntil input done_counting is high.At that point, the state machine must\nassert done to notify the user the timer has timed out, and waits until\ninput ack is 1 before being reset to look for the next occurrence of the\nstart sequence (1101). The state machine should have a active high\nsynchronous reset, setting the state to where it begins searching for the\ninput sequence 1101. Assume all sequential logic is triggered on the\npositive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input reset,\n  input data,\n  output reg shift_ena,\n  output reg counting,\n  input done_counting,\n  output reg done,\n  input ack\n);\n\n  typedef enum logic[3:0] {\n    S, S1, S11, S110, B0, B1, B2, B3, Count, Wait\n  } States;\n\n  States state, next;\n\n  always_comb begin\n    case (state)\n      S: next = States'(data ? S1: S);\n      S1: next = States'(data ? S11: S);\n      S11: next = States'(data ? S11 : S110);\n      S110: next = States'(data ? B0 : S);\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = Count;\n      Count: next = States'(done_counting ? Wait : Count);\n      Wait: next = States'(ack ? S : Wait);\n      default: next = States'(4'bx);\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= S;\n    else state <= next;\n  end\n\n  always_comb begin\n    shift_ena = 0; counting = 0; done = 0;\n    if (state == B0 || state == B1 || state == B2 || state == B3)\n      shift_ena = 1;\n    if (state == Count)\n      counting = 1;\n    if (state == Wait)\n      done = 1;\n\n    if (|state === 1'bx) begin\n      {shift_ena, counting, done} = 'x;\n    end\n\n  end\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input reset,\n  input data,\n  output reg shift_ena,\n  output reg counting,\n  input done_counting,\n  output reg done,\n  input ack\n);\n  typedef enum logic [3:0] {\n    S, S1, S11, S110, B0, B1, B2, B3, Count, Wait\n  } States;\n  States state, next;\n  always_comb begin\n    next = state;\n    case (state)\n      S:    next = data ? S1 : S;\n      S1:   next = data ? S11 : S;\n      S11:  next = data ? S11 : S110;\n      S110: next = data ? B0 : S;\n      B0:   next = B1;\n      B1:   next = B2;\n      B2:   next = B3;\n      B3:   next = Count;\n      Count: next = done_counting ? Wait : Count;\n      Wait: next = ack ? S : Wait;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= S;\n    else state <= next;\n  end\n  always_comb begin\n    shift_ena = (state == B0) || (state == B1) || (state == B2) || (state == B3);\n    counting = (state == Count);\n    done = (state == Wait);\n    if (|state === 1'bx) begin\n      {shift_ena, counting, done} = 'x;\n    end\n  end\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input reset,\n  input data,\n  output reg shift_ena,\n  output reg counting,\n  input done_counting,\n  output reg done,\n  input ack\n);\n  typedef enum logic [3:0] {\n    S, S1, S11, S110, B0, B1, B2, B3, Count, Wait\n  } States;\n  States state, next;\n  always_comb begin\n    case (state)\n      S: next = States'(data ? S1: S);\n      S1: next = States'(data ? S11: S);\n      S11: next = States'(data ? S11 : S110);\n      S110: next = States'(data ? B0 : S);\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = Count;\n      Count: next = States'(done_counting ? Wait : Count);\n      Wait: next = States'(ack ? S : Wait);\n      default: next = States'(4'bx);\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= S;\n    else state <= next;\n  end\n  always_comb begin\n    shift_ena = 0; counting = 0; done = 0;\n    if (state == B0 || state == B1 || state == B2)\n      shift_ena = 1;\n    if (state == Count)\n      counting = 1;\n    if (state == Wait)\n      done = 1;\n    if (|state === 1'bx) begin\n      {shift_ena, counting, done} = 'x;\n    end\n  end\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 152,
    "problem_name": "lemmings3",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  bump_left\n - input  bump_right\n - input  ground\n - input  dig\n - output walk_left\n - output walk_right\n - output aaah\n - output digging\n\nThe game Lemmings involves critters with fairly simple brains. So simple\nthat we are going to model it using a finite state machine. In the\nLemmings' 2D world, Lemmings can be in one of two states: walking left\n(walk_left is 1) or walking right (walk_right is 1). It will switch\ndirections if it hits an obstacle. In particular, if a Lemming is bumped\non the left (by receiving a 1 on bump_left), it will walk right. If it's\nbumped on the right (by receiving a 1 on bump_right), it will walk left.\nIf it's bumped on both sides at the same time, it will still switch\ndirections.\n\nIn addition to walking left and right and changing direction when bumped,\nwhen ground=0, the Lemming will fall and say \"aaah!\". When the ground\nreappears (ground=1), the Lemming will resume walking in the same\ndirection as before the fall. Being bumped while falling does not affect\nthe walking direction, and being bumped in the same cycle as ground\ndisappears (but not yet falling), or when the ground reappears while\nstill falling, also does not affect the walking direction.\n\nIn addition to walking and falling, Lemmings can sometimes be told to do\nuseful things, like dig (it starts digging when dig=1). A Lemming can dig\nif it is currently walking on ground (ground=1 and not falling), and will\ncontinue digging until it reaches the other side (ground=0). At that\npoint, since there is no ground, it will fall (aaah!), then continue\nwalking in its original direction once it hits ground again. As with\nfalling, being bumped while digging has no effect, and being told to dig\nwhen falling or when there is no ground is ignored. (In other words, a\nwalking Lemming can fall, dig, or switch directions. If more than one of\nthese conditions are satisfied, fall has higher precedence than dig,\nwhich has higher precedence than switching directions.)\n\nImplement a Moore state machine that models this behaviour. areset is\npositive edge triggered asynchronous reseting the Lemming machine to walk\nleft. Assume all sequential logic is triggered on the positive edge of\nthe clock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  input dig,\n  output walk_left,\n  output walk_right,\n  output aaah,\n  output digging\n);\n\n  parameter WL=0, WR=1, FALLL=2, FALLR=3, DIGL=4, DIGR=5;\n  reg [2:0] state;\n  reg [2:0] next;\n\n  always_comb begin\n    case (state)\n      WL: if (!ground) next = FALLL;\n        else if (dig) next = DIGL;\n        else if (bump_left) next = WR;\n        else next = WL;\n      WR:\n        if (!ground) next = FALLR;\n        else if (dig) next = DIGR;\n        else if (bump_right) next = WL;\n        else next = WR;\n      FALLL: next = ground ? WL : FALLL;\n      FALLR: next = ground ? WR : FALLR;\n      DIGL: next = ground ? DIGL : FALLL;\n      DIGR: next = ground ? DIGR : FALLR;\n    endcase\n  end\n\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n      else state <= next;\n  end\n\n  assign walk_left = (state==WL);\n  assign walk_right = (state==WR);\n  assign aaah = (state == FALLL) || (state == FALLR);\n  assign digging = (state == DIGL) || (state == DIGR);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  input dig,\n  output walk_left,\n  output walk_right,\n  output aaah,\n  output digging\n);\n  parameter WL=0, WR=1, FALLL=2, FALLR=3, DIGL=4, DIGR=5;\n  reg [2:0] state, next;\n  always @(*) begin\n    case (state)\n      WL: begin\n        if (!ground) next = FALLL;\n        else if (dig) next = DIGL;\n        else if (bump_left) next = WR;\n        else next = WL;\n      end\n      WR: begin\n        if (!ground) next = FALLR;\n        else if (dig) next = DIGR;\n        else if (bump_right) next = WL;\n        else next = WR;\n      end\n      FALLL: next = ground ? WL : FALLL;\n      FALLR: next = ground ? WR : FALLR;\n      DIGL: next = ground ? DIGL : FALLL;\n      DIGR: next = ground ? DIGR : FALLR;\n    endcase\n  end\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n    else state <= next;\n  end\n  assign walk_left = (state == WL);\n  assign walk_right = (state == WR);\n  assign aaah = (state == FALLL || state == FALLR);\n  assign digging = (state == DIGL || state == DIGR);\nendmodule",
    "buggy_implementation": "module TopModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  input dig,\n  output walk_left,\n  output walk_right,\n  output aaah,\n  output digging\n);\n  parameter WL=0, WR=1, FALLL=2, FALLR=3, DIGL=4, DIGR=5;\n  reg [2:0] state, next;\n  always @(*) begin\n    case (state)\n      WL: begin\n        if (!ground) next = FALLL;\n        else if (dig) next = DIGL;\n        else if (bump_left) next = WR;\n        else next = WL;\n      end\n      WR: begin\n        if (!ground) next = FALLR;\n        else if (dig) next = DIGR;\n        else if (bump_right) next = WL;\n        else next = WR;\n      end\n      FALLL: next = ground ? WL : FALLL;\n      FALLR: next = ground ? WR : FALLR;\n      DIGL: next = ground ? DIGL : FALLL;\n      DIGR: next = ground ? DIGR : FALLR;\n      default: next = state;\n    endcase\n  end\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n    else state <= next;\n  end\n  assign walk_left = (state == WL);\n  assign walk_right = (state == WR);\n  assign aaah = (state == FALLL) && (state == FALLR);\n  assign digging = (state == DIGL || state == DIGR);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 153,
    "problem_name": "gshare",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n\n - input  predict_valid,\n - input  predict_pc (7 bits)\n - output predict_taken\n - output predict_history (7 bits)\n\n - input  train_valid\n - input  train_taken\n - input  train_mispredicted\n - input  train_history (7 bits)\n - input  train_pc (7 bits)\n\nThe module should implement a gshare branch predictor with 7-bit pc and\n7-bit global history, hashed (using xor) into a 7-bit index. This index\naccesses a 128-entry table of two-bit saturating counters. The branch\npredictor should contain a 7-bit global branch history register. The\nbranch predictor has two sets of interfaces: One for doing predictions\nand one for doing training. The prediction interface is used in the\nprocessor's Fetch stage to ask the branch predictor for branch direction\npredictions for the instructions being fetched. Once these branches\nproceed down the pipeline and are executed, the true outcomes of the\nbranches become known. The branch predictor is then trained using the\nactual branch direction outcomes.\n\nWhen a branch prediction is requested (predict_valid = 1) for a given pc,\nthe branch predictor produces the predicted branch direction and state of\nthe branch history register used to make the prediction. The branch\nhistory register is then updated (at the next positive clock edge) for\nthe predicted branch.\n\nWhen training for a branch is requested (train_valid = 1), the branch\npredictor is told the pc and branch history register value for the branch\nthat is being trained, as well as the actual branch outcome and whether\nthe branch was a misprediction (needing a pipeline flush). Update the\npattern history table (PHT) to train the branch predictor to predict this\nbranch more accurately next time. In addition, if the branch being\ntrained is mispredicted, also recover the branch history register to the\nstate immediately after the mispredicting branch completes execution.\n\nIf training for a misprediction and a prediction (for a different,\nyounger instruction) occurs in the same cycle, both operations will want\nto modify the branch history register. When this happens, training takes\nprecedence, because the branch being predicted will be discarded anyway.\nIf training and prediction of the same PHT entry happen at the same time,\nthe prediction sees the PHT state before training because training only\nmodifies the PHT at the next positive clock edge. The following timing\ndiagram shows the timing when training and predicting PHT entry 0 at the\nsame time. The training request at cycle 4 changes the PHT entry state in\ncycle 5, but the prediction request in cycle 4 outputs the PHT state at\ncycle 4, without considering the effect of the training request in cycle\n4. Reset is asynchronous active-high.\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input areset,\n\n  input predict_valid,\n  input [6:0] predict_pc,\n  output predict_taken,\n  output [6:0] predict_history,\n\n  input train_valid,\n  input train_taken,\n  input train_mispredicted,\n  input [6:0] train_history,\n  input [6:0] train_pc\n);\n\n  parameter n = 7;\n  logic [1:0] pht [2**n-1:0];\n\n  parameter [1:0] SNT = 0, LNT = 1, LT = 2, ST = 3;\n\n  logic [n-1:0] predict_history_r;\n  wire [n-1:0] predict_index = predict_history_r ^ predict_pc;\n  wire [n-1:0] train_index = train_history ^ train_pc;\n\n  always@(posedge clk, posedge areset)\n    if (areset) begin\n      for (integer i=0; i<2**n; i=i+1)\n        pht[i] = LNT;\n      predict_history_r = 0;\n        end  else begin\n      if (predict_valid)\n        predict_history_r <= {predict_history_r, predict_taken};\n      if(train_valid) begin\n        if(pht[train_index] < 3 && train_taken)\n          pht[train_index] <= pht[train_index] + 1;\n        else if(pht[train_index] > 0 && !train_taken)\n          pht[train_index] <= pht[train_index] - 1;\n        if (train_mispredicted)\n          predict_history_r <= {train_history, train_taken};\n      end\n    end\n\n  assign predict_taken = predict_valid ? pht[predict_index][1] : 1'bx;\n  assign predict_history = predict_valid ? predict_history_r : {n{1'bx}};\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input areset,\n\n  input predict_valid,\n  input [6:0] predict_pc,\n  output predict_taken,\n  output [6:0] predict_history,\n\n  input train_valid,\n  input train_taken,\n  input train_mispredicted,\n  input [6:0] train_history,\n  input [6:0] train_pc\n);\n\n  parameter n = 7;\n  reg [1:0] pht [2**n-1:0];\n\n  parameter [1:0] SNT = 0, LNT = 1, LT = 2, ST = 3;\n\n  reg [n-1:0] predict_history_r;\n  wire [n-1:0] predict_index = predict_history_r ^ predict_pc;\n  wire [n-1:0] train_index = train_history ^ train_pc;\n\n  always@(posedge clk, posedge areset)\n    if (areset) begin\n      for (integer i=0; i<2**n; i=i+1)\n        pht[i] = LNT;\n      predict_history_r = 0;\n    end else begin\n      if (predict_valid)\n        predict_history_r <= {predict_history_r[n-2:0], predict_taken};\n      if(train_valid) begin\n        if(pht[train_index] < 3 && train_taken)\n          pht[train_index] <= pht[train_index] + 1;\n        else if(pht[train_index] > 0 && !train_taken)\n          pht[train_index] <= pht[train_index] - 1;\n        if (train_mispredicted)\n          predict_history_r <= {train_history[n-2:0], train_taken};\n      end\n    end\n\n  assign predict_taken = predict_valid ? pht[predict_index][1] : 1'bx;\n  assign predict_history = predict_valid ? predict_history_r : {n{1'bx}};\n\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input predict_valid,\n  input [6:0] predict_pc,\n  output predict_taken,\n  output [6:0] predict_history,\n  input train_valid,\n  input train_taken,\n  input train_mispredicted,\n  input [6:0] train_history,\n  input [6:0] train_pc\n);\n  parameter n = 7;\n  logic [1:0] pht [2n-1:0];\n  parameter [1:0] SNT = 0, LNT = 1, LT = 2, ST = 3;\n  logic [n-1:0] predict_history_r;\n  wire [n-1:0] predict_index = predict_history_r ^ predict_pc;\n  wire [n-1:0] train_index = train_history ^ train_pc;\n  always@(posedge clk, posedge areset)\n    if (areset) begin\n      for (integer i=0; i<2n; i=i+1)\n        pht[i] = LNT;\n      predict_history_r = 0;\n        end  else begin\n      if (predict_valid)\n        predict_history_r <= {predict_history_r, predict_taken};\n      if(train_valid) begin\n        if(pht[train_index] < 2 && train_taken)\n          pht[train_index] <= pht[train_index] + 1;\n        else if(pht[train_index] > 0 && !train_taken)\n          pht[train_index] <= pht[train_index] - 1;\n        if (train_mispredicted)\n          predict_history_r <= {train_history, train_taken};\n      end\n    end\n  assign predict_taken = predict_valid ? pht[predict_index][1] : 1'bx;\n  assign predict_history = predict_valid ? predict_history_r : {n{1'bx}};\nendmodule",
    "difficulty": "medium",
    "category": "sequential_logic"
  },
  {
    "problem_number": 154,
    "problem_name": "fsm_ps2data",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  in (8 bits)\n - output out_bytes (24 bits)\n - output done\n\nThe module should implement a finite state machine that will search for\nmessage boundaries when given an input byte stream. The algorithm we'll\nuse is to discard bytes until we see one with in[3]=1. We then assume\nthat this is byte 1 of a message, and signal the receipt of a message\nonce all 3 bytes have been received (done). The FSM should signal done in\nthe cycle immediately after the third byte of each message was\nsuccessfully received.\n\nImplement the datapath module that will output the 24-bit (3 byte)\nmessage whenever a packet is received (out_bytes[23:16] is the first\nbyte, out_bytes[15:8] is the second byte, etc.). The reset signal is\nactive high synchronous. out_bytes needs to be valid whenever the done\nsignal is asserted. You may output anything at other times (i.e.,\ndon't-care). Assume all sequential logic is triggered on the positive\nedge of the clock.\n\nHere is an example waveform:\n\n  time   clk rst in  done out_bytes\n  0ns    0   1    0  x         x\n  5ns    1   1    0  0         x\n  10ns   0   1    0  0         x\n  15ns   1   0   2c  0         x\n  20ns   0   0   2c  0         x\n  25ns   1   0   81  0         x\n  30ns   0   0   81  0         x\n  35ns   1   0    9  0         x\n  40ns   0   0    9  0         x\n  45ns   1   0   6b  1    2c8109\n  50ns   0   0   6b  1    2c8109\n  55ns   1   0    d  0         x\n  60ns   0   0    d  0         x\n  65ns   1   0   8d  0         x\n  70ns   0   0   8d  0         x\n  75ns   1   0   6d  1    6b0d8d\n  80ns   0   0   6d  1    6b0d8d\n  85ns   1   0   12  0         x\n  90ns   0   0   12  0         x\n  95ns   1   0    1  0         x\n  100ns  0   0    1  0         x\n  105ns  1   0    d  1    6d1201\n  110ns  0   0    d  1    6d1201\n  115ns  1   0   76  0         x\n  120ns  0   0   76  0         x\n  125ns  1   0   3d  0         x\n  130ns  0   0   3d  0         x\n  135ns  1   0   ed  1     d763d\n  140ns  0   0   ed  1     d763d\n  145ns  1   0   8c  0         x\n  150ns  0   0   8c  0         x\n  155ns  1   0   f9  0         x\n  160ns  0   0   f9  0         x\n  165ns  1   0   ce  1    ed8cf9\n  170ns  0   0   ce  1    ed8cf9\n  175ns  1   0   c5  0         x\n  180ns  0   0   c5  0         x\n  185ns  1   0   aa  0         x\n  190ns  0   0   aa  0         x",
    "reference_implementation": "module RefModule (\n  input clk,\n  input [7:0] in,\n  input reset,\n  output [23:0] out_bytes,\n  output done\n);\n\n  parameter BYTE1=0, BYTE2=1, BYTE3=2, DONE=3;\n  reg [1:0] state;\n  reg [1:0] next;\n\n  wire in3 = in[3];\n\n  always_comb begin\n    case (state)\n      BYTE1: next = in3 ? BYTE2 : BYTE1;\n      BYTE2: next = BYTE3;\n      BYTE3: next = DONE;\n      DONE: next = in3 ? BYTE2 : BYTE1;\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= BYTE1;\n      else state <= next;\n  end\n\n  assign done = (state==DONE);\n\n  reg [23:0] out_bytes_r;\n  always @(posedge clk)\n    out_bytes_r <= {out_bytes_r[15:0], in};\n\n  // Implementations may vary: Allow user to do anything while the output\n  // doesn't have to be valid.\n\n  assign out_bytes = done ? out_bytes_r : 'x;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input clk,\n  input [7:0] in,\n  input reset,\n  output [23:0] out_bytes,\n  output done\n);\n  parameter BYTE1=0, BYTE2=1, BYTE3=2, DONE=3;\n  reg [1:0] state;\n  reg [1:0] next_state;\n  wire in3 = in[3];\n  always_comb begin\n    case (state)\n      BYTE1: next_state = in3 ? BYTE2 : BYTE1;\n      BYTE2: next_state = BYTE3;\n      BYTE3: next_state = DONE;\n      DONE: next_state = in3 ? BYTE2 : BYTE1;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= BYTE1;\n    else state <= next_state;\n  end\n  assign done = (state == DONE);\n  reg [23:0] message_buffer;\n  always @(posedge clk)\n    message_buffer <= {message_buffer[15:0], in};\n  assign out_bytes = done ? message_buffer : 'x;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input [7:0] in,\n  input reset,\n  output [23:0] out_bytes,\n  output done\n);\n  parameter BYTE1=0, BYTE2=1, BYTE3=2, DONE=3;\n  reg [1:0] state;\n  reg [1:0] next;\n  wire in3 = in[2];\n  always_comb begin\n    case (state)\n      BYTE1: next = in3 ? BYTE2 : BYTE1;\n      BYTE2: next = BYTE3;\n      BYTE3: next = DONE;\n      DONE: next = in3 ? BYTE2 : BYTE1;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= BYTE1;\n      else state <= next;\n  end\n  assign done = (state==DONE);\n  reg [23:0] out_bytes_r;\n  always @(posedge clk)\n    out_bytes_r <= {out_bytes_r[15:0], in};\n  assign out_bytes = done ? out_bytes_r : 'x;\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 155,
    "problem_name": "lemmings4",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  areset\n - input  bump_left\n - input  bump_right\n - input  ground\n - input  dig\n - output walk_left\n - output walk_right\n - output aaah\n - output digging\n\nThe game Lemmings involves critters with fairly simple brains. So simple\nthat we are going to model it using a finite state machine. In the\nLemmings' 2D world, Lemmings can be in one of two states: walking left\n(walk_left is 1) or walking right (walk_right is 1). It will switch\ndirections if it hits an obstacle. In particular, if a Lemming is bumped\non the left (by receiving a 1 on bump_left), it will walk right. If it's\nbumped on the right (by receiving a 1 on bump_right), it will walk left.\nIf it's bumped on both sides at the same time, it will still switch\ndirections.\n\nIn addition to walking left and right and changing direction when bumped,\nwhen ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground\nreappears (ground=1), the Lemming will resume walking in the same\ndirection as before the fall. Being bumped while falling does not affect\nthe walking direction, and being bumped in the same cycle as ground\ndisappears (but not yet falling), or when the ground reappears while\nstill falling, also does not affect the walking direction.\n\nIn addition to walking and falling, Lemmings can sometimes be told to do\nuseful things, like dig (it starts digging when dig=1). A Lemming can dig\nif it is currently walking on ground (ground=1 and not falling), and will\ncontinue digging until it reaches the other side (ground=0). At that\npoint, since there is no ground, it will fall (aaah!), then continue\nwalking in its original direction once it hits ground again. As with\nfalling, being bumped while digging has no effect, and being told to dig\nwhen falling or when there is no ground is ignored. (In other words, a\nwalking Lemming can fall, dig, or switch directions. If more than one of\nthese conditions are satisfied, fall has higher precedence than dig,\nwhich has higher precedence than switching directions.)\n\nAlthough Lemmings can walk, fall, and dig, Lemmings aren't invulnerable.\nIf a Lemming falls for too long then hits the ground, it can splatter. In\nparticular, if a Lemming falls for more than 20 clock cycles then hits\nthe ground, it will splatter and cease walking, falling, or digging (all\n4 outputs become 0), forever (Or until the FSM gets reset). There is no\nupper limit on how far a Lemming can fall before hitting the ground.\nLemmings only splatter when hitting the ground; they do not splatter in\nmid-air.\n\nImplement a Moore state machine that models this behaviour. areset is\npositive edge triggered asynchronous reseting the Lemming machine to walk\nleft.\n\nAssume all sequential logic is triggered on the positive edge of the\nclock.",
    "reference_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  input dig,\n  output walk_left,\n  output walk_right,\n  output aaah,\n  output digging\n);\n\n  parameter WL=0, WR=1, FALLL=2, FALLR=3, DIGL=4, DIGR=5, DEAD=6;\n  reg [2:0] state;\n  reg [2:0] next;\n\n  reg [4:0] fall_counter;\n\n  always_comb begin\n    case (state)\n      WL: if (!ground) next = FALLL;\n        else if (dig) next = DIGL;\n        else if (bump_left) next = WR;\n        else next = WL;\n      WR:\n        if (!ground) next = FALLR;\n        else if (dig) next = DIGR;\n        else if (bump_right) next = WL;\n        else next = WR;\n      FALLL: next = ground ? (fall_counter >= 20 ? DEAD : WL) : FALLL;\n      FALLR: next = ground ? (fall_counter >= 20 ? DEAD : WR) : FALLR;\n      DIGL: next = ground ? DIGL : FALLL;\n      DIGR: next = ground ? DIGR : FALLR;\n      DEAD: next = DEAD;\n    endcase\n  end\n\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n      else state <= next;\n  end\n\n  always @(posedge clk) begin\n    if (state == FALLL || state == FALLR) begin\n      if (fall_counter < 20)\n        fall_counter <= fall_counter + 1'b1;\n    end\n    else\n      fall_counter <= 0;\n  end\n\n  assign walk_left = (state==WL);\n  assign walk_right = (state==WR);\n  assign aaah = (state == FALLL) || (state == FALLR);\n  assign digging = (state == DIGL) || (state == DIGR);\n\nendmodule",
    "slightly_different_implementation": "module TopModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  input dig,\n  output walk_left,\n  output walk_right,\n  output aaah,\n  output digging\n);\n\n  parameter WL=0, WR=1, FALLL=2, FALLR=3, DIGL=4, DIGR=5, DEAD=6;\n  reg [2:0] state, next_state;\n  reg [4:0] fall_counter;\n\n  always @(*) begin\n    case (state)\n      WL: begin\n        if (!ground) next_state = FALLL;\n        else if (dig) next_state = DIGL;\n        else if (bump_left) next_state = WR;\n        else next_state = WL;\n      end\n      WR: begin\n        if (!ground) next_state = FALLR;\n        else if (dig) next_state = DIGR;\n        else if (bump_right) next_state = WL;\n        else next_state = WR;\n      end\n      FALLL: begin\n        if (ground) next_state = (fall_counter >= 20) ? DEAD : WL;\n        else next_state = FALLL;\n      end\n      FALLR: begin\n        if (ground) next_state = (fall_counter >= 20) ? DEAD : WR;\n        else next_state = FALLR;\n      end\n      DIGL: begin\n        if (!ground) next_state = FALLL;\n        else next_state = DIGL;\n      end\n      DIGR: begin\n        if (!ground) next_state = FALLR;\n        else next_state = DIGR;\n      end\n      DEAD: next_state = DEAD;\n      default: next_state = WL;\n    endcase\n  end\n\n  always @(posedge clk or posedge areset) begin\n    if (areset) begin\n      state <= WL;\n      fall_counter <= 0;\n    end else begin\n      state <= next_state;\n      if (state == FALLL || state == FALLR) begin\n        if (fall_counter < 20)\n          fall_counter <= fall_counter + 1;\n      end else begin\n        fall_counter <= 0;\n      end\n    end\n  end\n\n  assign walk_left = (state == WL);\n  assign walk_right = (state == WR);\n  assign aaah = (state == FALLL) || (state == FALLR);\n  assign digging = (state == DIGL) || (state == DIGR);\n\nendmodule",
    "buggy_implementation": "module RefModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  input dig,\n  output walk_left,\n  output walk_right,\n  output aaah,\n  output digging\n);\n  parameter WL=0, WR=1, FALLL=2, FALLR=3, DIGL=4, DIGR=5, DEAD=6;\n  reg [2:0] state;\n  reg [2:0] next;\n  reg [4:0] fall_counter;\n  always_comb begin\n    case (state)\n      WL: if (!ground) next = FALLL;\n        else if (dig) next = DIGL;\n        else if (bump_left) next = WR;\n        else next = WL;\n      WR:\n        if (!ground) next = FALLR;\n        else if (dig) next = DIGR;\n        else if (bump_right) next = WL;\n        else next = WR;\n      FALLL: next = ground ? (fall_counter > 20 ? DEAD : WL) : FALLL;\n      FALLR: next = ground ? (fall_counter > 20 ? DEAD : WR) : FALLR;\n      DIGL: next = ground ? DIGL : FALLL;\n      DIGR: next = ground ? DIGR : FALLR;\n      DEAD: next = DEAD;\n    endcase\n  end\n  always @(posedge clk, posedge areset) begin\n    if (areset) state <= WL;\n      else state <= next;\n  end\n  always @(posedge clk) begin\n    if (state == FALLL || state == FALLR) begin\n      if (fall_counter < 21)\n        fall_counter <= fall_counter + 1'b1;\n    end\n    else\n      fall_counter <= 0;\n  end\n  assign walk_left = (state==WL);\n  assign walk_right = (state==WR);\n  assign aaah = (state == FALLL) || (state == FALLR);\n  assign digging = (state == DIGL) || (state == DIGR);\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  },
  {
    "problem_number": 156,
    "problem_name": "review2015_fancytimer",
    "original_prompt": "I would like you to implement a module named TopModule with the following\ninterface. All input and output ports are one bit unless otherwise\nspecified.\n\n - input  clk\n - input  reset\n - input  data\n - output count (4 bits)\n - output counting\n - output done\n - input  ack\n\nThe module should implement a timer with one input that:\n\n  (1) is started when a particular input pattern (1101) is detected,\n  (2) shifts in 4 more bits to determine the duration to delay,\n  (3) waits for the counters to finish counting, and\n  (4) notifies the user and waits for the user to acknowledge the timer.\n\nThe serial data is available on the data input pin. When the pattern 1101\nis received, the circuit must then shift in the next 4 bits,\nmost-significant-bit first. These 4 bits determine the duration of the\ntimer delay, referred to as delay[3:0]. After that, the state machine\nasserts its counting output to indicate it is counting. Once the 1101 and\ndelay[3:0] have been read, the circuit no longer looks at the data input\nuntil it resumes searching after everything else is done.\n\nThe state machine must count for exactly (delay[3:0] + 1) * 1000 clock\ncycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count\n6000 cycles. Also output the current remaining time. This should be equal\nto delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until\nit is 0 for 1000 cycles.\n\nWhen the circuit isn't counting, the count[3:0] output is don't-care\n(whatever value is convenient for you to implement). At that point, the\ncircuit must assert done to notify the user the timer has timed out, and\nwaits until input ack is 1 before being reset to look for the next\noccurrence of the start sequence (1101).\n\nThe circuit should reset into a state where it begins searching for the\ninput sequence 1101. The reset signal is active high synchronous. Assume\nall sequential logic is triggered on the positive edge of the clock.",
    "reference_implementation": "module RefModule (\n  input wire clk,\n  input wire reset,\n  input wire data,\n  output wire [3:0] count,\n  output reg counting,\n  output reg done,\n  input wire ack\n);\n\n  typedef enum logic[3:0] {\n    S, S1, S11, S110, B0, B1, B2, B3, Count, Wait\n  } States;\n\n  States state, next;\n\n  reg shift_ena;\n  reg [9:0] fcount;\n  reg [3:0] scount;\n  wire done_counting = (scount == 0) && (fcount == 999);\n\n  always_comb begin\n    case (state)\n      S: next = States'(data ? S1: S);\n      S1: next = States'(data ? S11: S);\n      S11: next = States'(data ? S11 : S110);\n      S110: next = States'(data ? B0 : S);\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = Count;\n      Count: next = States'(done_counting ? Wait : Count);\n      Wait: next = States'(ack ? S : Wait);\n      default: next = States'(4'bx);\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset) state <= S;\n    else state <= next;\n  end\n\n  always_comb begin\n    shift_ena = 0; counting = 0; done = 0;\n    if (state == B0 || state == B1 || state == B2 || state == B3)\n      shift_ena = 1;\n    if (state == Count)\n      counting = 1;\n    if (state == Wait)\n      done = 1;\n\n    if (|state === 1'bx) begin\n      {shift_ena, counting, done} = 'x;\n    end\n  end\n\n  // Shift register\n  always @(posedge clk) begin\n    if (shift_ena)\n      scount <= {scount[2:0], data};\n    else if (counting && fcount == 999)\n      scount <= scount - 1'b1;\n  end\n\n  // Fast counter\n  always @(posedge clk)\n    if (!counting)\n      fcount <= 10'h0;\n    else if (fcount == 999)\n      fcount <= 10'h0;\n    else\n      fcount <= fcount + 1'b1;\n\n  assign count = counting ? scount : 'x;\n\nendmodule",
    "slightly_different_implementation": "module RefModule (\n  input wire clk,\n  input wire reset,\n  input wire data,\n  output wire [3:0] count,\n  output reg counting,\n  output reg done,\n  input wire ack\n);\n  typedef enum logic[3:0] {\n    S, S1, S11, S110, B0, B1, B2, B3, Count, Wait\n  } States;\n  reg [3:0] state, next;\n  reg shift_ena;\n  reg [9:0] fcount;\n  reg [3:0] scount;\n  wire done_counting = (scount == 0) && (fcount == 999);\n  always @(*) begin\n    case (state)\n      S: next = data ? S1 : S;\n      S1: next = data ? S11 : S;\n      S11: next = data ? S11 : S110;\n      S110: next = data ? B0 : S;\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = Count;\n      Count: next = done_counting ? Wait : Count;\n      Wait: next = ack ? S : Wait;\n      default: next = 'bx;\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= S;\n    else state <= next;\n  end\n  always @(*) begin\n    shift_ena = 0; counting = 0; done = 0;\n    case (state)\n      B0,B1,B2,B3: shift_ena = 1;\n      Count: counting = 1;\n      Wait: done = 1;\n      default: begin end\n    endcase\n  end\n  always @(posedge clk) begin\n    if (shift_ena)\n      scount <= {scount[2:0], data};\n    else if (counting && fcount == 999)\n      scount <= scount - 1;\n  end\n  always @(posedge clk)\n    if (!counting) fcount <= 0;\n    else if (fcount == 999) fcount <= 0;\n    else fcount <= fcount + 1;\n  assign count = counting ? scount : 'x;\nendmodule",
    "buggy_implementation": "module RefModule (\n  input wire clk,\n  input wire reset,\n  input wire data,\n  output wire [3:0] count,\n  output reg counting,\n  output reg done,\n  input wire ack\n);\n  typedef enum logic[3:0] {\n    S, S1, S11, S110, B0, B1, B2, B3, Count, Wait\n  } States;\n  States state, next;\n  reg shift_ena;\n  reg [9:0] fcount;\n  reg [3:0] scount;\n  wire done_counting = (scount == 0) && (fcount == 999);\n  always_comb begin\n    case (state)\n      S: next = States'(data ? S1: S);\n      S1: next = States'(data ? S11: S);\n      S11: next = States'(data ? S11 : S110);\n      S110: next = States'(data ? B0 : S);\n      B0: next = B1;\n      B1: next = B2;\n      B2: next = B3;\n      B3: next = Count;\n      Count: next = States'(done_counting ? Wait : Count);\n      Wait: next = States'(ack ? S : Wait);\n      default: next = States'(4'bx);\n    endcase\n  end\n  always @(posedge clk) begin\n    if (reset) state <= S;\n    else state <= next;\n  end\n  always_comb begin\n    shift_ena = 0; counting = 0; done = 0;\n    if (state == B0 || state == B1 || state == B2 || state == B3)\n      shift_ena = 1;\n    if (state == Count)\n      counting = 1;\n    if (state == Wait)\n      done = 1;\n  end\n  always @(posedge clk) begin\n    if (shift_ena)\n      scount <= {scount[2:0], data};\n    else if (counting)\n      scount <= scount - 1'b1;\n  end\n  always @(posedge clk)\n    if (!counting)\n      fcount <= 10'h0;\n    else if (fcount == 999)\n      fcount <= 10'h0;\n    else\n      fcount <= fcount + 1'b1;\n  assign count = counting ? scount : 'x;\nendmodule",
    "difficulty": "medium",
    "category": "finite_state_machine"
  }
]